"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/geotiff";
exports.ids = ["vendor-chunks/geotiff"];
exports.modules = {

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BaseDecoder)\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"(ssr)/./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDs7QUFFbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxjb21wcmVzc2lvblxcYmFzZWRlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQcmVkaWN0b3IgfSBmcm9tICcuLi9wcmVkaWN0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRGVjb2RlciB7XG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdGhpcy5kZWNvZGVCbG9jayhidWZmZXIpO1xuICAgIGNvbnN0IHByZWRpY3RvciA9IGZpbGVEaXJlY3RvcnkuUHJlZGljdG9yIHx8IDE7XG4gICAgaWYgKHByZWRpY3RvciAhPT0gMSkge1xuICAgICAgY29uc3QgaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0cztcbiAgICAgIGNvbnN0IHRpbGVXaWR0aCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IGZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHRpbGVIZWlnaHQgPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIDogKFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFwcGx5UHJlZGljdG9yKFxuICAgICAgICBkZWNvZGVkLCBwcmVkaWN0b3IsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/deflate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DeflateDecoder)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n\nclass DeflateDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  decodeBlock(buffer) {\n    return (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNZOztBQUU1Qiw2QkFBNkIsdURBQVc7QUFDdkQ7QUFDQSxXQUFXLDZDQUFPO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGNvbXByZXNzaW9uXFxkZWZsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZmxhdGUgfSBmcm9tICdwYWtvJztcbmltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmbGF0ZURlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHJldHVybiBpbmZsYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpLmJ1ZmZlcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDecoder: () => (/* binding */ addDecoder),\n/* harmony export */   getDecoder: () => (/* binding */ getDecoder)\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/pako\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/pako\"), __webpack_require__.e(\"vendor-chunks/zstddec\"), __webpack_require__.e(\"vendor-chunks/lerc\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"vendor-chunks/geotiff\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVPO0FBQ1A7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaU1BQWtCO0FBQ25ELG9CQUFvQixpTUFBa0I7QUFDdEM7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0IsbU1BQW1CO0FBQ3ZDLDZCQUE2QixvUUFBc0I7QUFDbkQsd0JBQXdCLDJNQUF1QjtBQUMvQyx3QkFBd0IsMlZBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCLDJNQUF1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcY29tcHJlc3Npb25cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlcihjYXNlcywgaW1wb3J0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNhc2VzKSkge1xuICAgIGNhc2VzID0gW2Nhc2VzXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICB9XG4gIGNhc2VzLmZvckVhY2goKGMpID0+IHJlZ2lzdHJ5LnNldChjLCBpbXBvcnRGbikpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KSB7XG4gIGNvbnN0IGltcG9ydEZuID0gcmVnaXN0cnkuZ2V0KGZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb24pO1xuICBpZiAoIWltcG9ydEZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke2ZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb259YCk7XG4gIH1cbiAgY29uc3QgRGVjb2RlciA9IGF3YWl0IGltcG9ydEZuKCk7XG4gIHJldHVybiBuZXcgRGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbn1cblxuLy8gQWRkIGRlZmF1bHQgZGVjb2RlcnMgdG8gcmVnaXN0cnkgKGVuZC11c2VyIG1heSBvdmVycmlkZSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucylcbmFkZERlY29kZXIoW3VuZGVmaW5lZCwgMV0sICgpID0+IGltcG9ydCgnLi9yYXcuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoNSwgKCkgPT4gaW1wb3J0KCcuL2x6dy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2Rlcig2LCAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignb2xkIHN0eWxlIEpQRUcgY29tcHJlc3Npb24gaXMgbm90IHN1cHBvcnRlZC4nKTtcbn0pO1xuYWRkRGVjb2Rlcig3LCAoKSA9PiBpbXBvcnQoJy4vanBlZy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcihbOCwgMzI5NDZdLCAoKSA9PiBpbXBvcnQoJy4vZGVmbGF0ZS5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcigzMjc3MywgKCkgPT4gaW1wb3J0KCcuL3BhY2tiaXRzLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDM0ODg3LCAoKSA9PiBpbXBvcnQoJy4vbGVyYy5qcycpXG4gIC50aGVuKGFzeW5jIChtKSA9PiB7XG4gICAgYXdhaXQgbS56c3RkLmluaXQoKTtcbiAgICByZXR1cm4gbTtcbiAgfSlcbiAgLnRoZW4oKG0pID0+IG0uZGVmYXVsdCksXG4pO1xuYWRkRGVjb2Rlcig1MDAwMSwgKCkgPT4gaW1wb3J0KCcuL3dlYmltYWdlLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/jpeg.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JpegDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nclass JpegDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9qcGVnLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJDOztBQUUzQyxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3Qjs7QUFFdEM7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQ0FBMEM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FB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cEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxzQkFBc0IsV0FBVztBQUNqQyx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwwQkFBMEIsdURBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxjb21wcmVzc2lvblxcanBlZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbi8qIC0qLSB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC9cbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cbi8qXG4gICBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXRcbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4vLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MVxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2l0dS10ODEucGRmKVxuLy8gLSBUaGUgSkZJRiBzcGVjaWZpY2F0aW9uIGNhbiBiZSBmb3VuZCBpbiB0aGUgSlBFRyBGaWxlIEludGVyY2hhbmdlIEZvcm1hdFxuLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZilcbi8vIC0gVGhlIEFkb2JlIEFwcGxpY2F0aW9uLVNwZWNpZmljIEpQRUcgbWFya2VycyBpbiB0aGUgU3VwcG9ydGluZyB0aGUgRENUIEZpbHRlcnNcbi8vICAgaW4gUG9zdFNjcmlwdCBMZXZlbCAyLCBUZWNobmljYWwgTm90ZSAjNTExNlxuLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpXG5cbmNvbnN0IGRjdFppZ1phZyA9IG5ldyBJbnQzMkFycmF5KFtcbiAgMCxcbiAgMSwgOCxcbiAgMTYsIDksIDIsXG4gIDMsIDEwLCAxNywgMjQsXG4gIDMyLCAyNSwgMTgsIDExLCA0LFxuICA1LCAxMiwgMTksIDI2LCAzMywgNDAsXG4gIDQ4LCA0MSwgMzQsIDI3LCAyMCwgMTMsIDYsXG4gIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LFxuICA1NywgNTAsIDQzLCAzNiwgMjksIDIyLCAxNSxcbiAgMjMsIDMwLCAzNywgNDQsIDUxLCA1OCxcbiAgNTksIDUyLCA0NSwgMzgsIDMxLFxuICAzOSwgNDYsIDUzLCA2MCxcbiAgNjEsIDU0LCA0NyxcbiAgNTUsIDYyLFxuICA2Myxcbl0pO1xuXG5jb25zdCBkY3RDb3MxID0gNDAxNzsgLy8gY29zKHBpLzE2KVxuY29uc3QgZGN0U2luMSA9IDc5OTsgLy8gc2luKHBpLzE2KVxuY29uc3QgZGN0Q29zMyA9IDM0MDY7IC8vIGNvcygzKnBpLzE2KVxuY29uc3QgZGN0U2luMyA9IDIyNzY7IC8vIHNpbigzKnBpLzE2KVxuY29uc3QgZGN0Q29zNiA9IDE1Njc7IC8vIGNvcyg2KnBpLzE2KVxuY29uc3QgZGN0U2luNiA9IDM3ODQ7IC8vIHNpbig2KnBpLzE2KVxuY29uc3QgZGN0U3FydDIgPSA1NzkzOyAvLyBzcXJ0KDIpXG5jb25zdCBkY3RTcXJ0MWQyID0gMjg5NjsvLyBzcXJ0KDIpIC8gMlxuXG5mdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7XG4gIGxldCBrID0gMDtcbiAgY29uc3QgY29kZSA9IFtdO1xuICBsZXQgbGVuZ3RoID0gMTY7XG4gIHdoaWxlIChsZW5ndGggPiAwICYmICFjb2RlTGVuZ3Roc1tsZW5ndGggLSAxXSkge1xuICAgIC0tbGVuZ3RoO1xuICB9XG4gIGNvZGUucHVzaCh7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7XG5cbiAgbGV0IHAgPSBjb2RlWzBdO1xuICBsZXQgcTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29kZUxlbmd0aHNbaV07IGorKykge1xuICAgICAgcCA9IGNvZGUucG9wKCk7XG4gICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdO1xuICAgICAgd2hpbGUgKHAuaW5kZXggPiAwKSB7XG4gICAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgfVxuICAgICAgcC5pbmRleCsrO1xuICAgICAgY29kZS5wdXNoKHApO1xuICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgY29kZS5wdXNoKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICAgIHAuY2hpbGRyZW5bcC5pbmRleF0gPSBxLmNoaWxkcmVuO1xuICAgICAgICBwID0gcTtcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XG4gICAgICAvLyBwIGhlcmUgcG9pbnRzIHRvIGxhc3QgY29kZVxuICAgICAgY29kZS5wdXNoKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7XG4gICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgIHAgPSBxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29kZVswXS5jaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlU2NhbihkYXRhLCBpbml0aWFsT2Zmc2V0LFxuICBmcmFtZSwgY29tcG9uZW50cywgcmVzZXRJbnRlcnZhbCxcbiAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7XG4gIGNvbnN0IHsgbWN1c1BlckxpbmUsIHByb2dyZXNzaXZlIH0gPSBmcmFtZTtcblxuICBjb25zdCBzdGFydE9mZnNldCA9IGluaXRpYWxPZmZzZXQ7XG4gIGxldCBvZmZzZXQgPSBpbml0aWFsT2Zmc2V0O1xuICBsZXQgYml0c0RhdGEgPSAwO1xuICBsZXQgYml0c0NvdW50ID0gMDtcbiAgZnVuY3Rpb24gcmVhZEJpdCgpIHtcbiAgICBpZiAoYml0c0NvdW50ID4gMCkge1xuICAgICAgYml0c0NvdW50LS07XG4gICAgICByZXR1cm4gKGJpdHNEYXRhID4+IGJpdHNDb3VudCkgJiAxO1xuICAgIH1cbiAgICBiaXRzRGF0YSA9IGRhdGFbb2Zmc2V0KytdO1xuICAgIGlmIChiaXRzRGF0YSA9PT0gMHhGRikge1xuICAgICAgY29uc3QgbmV4dEJ5dGUgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgIGlmIChuZXh0Qnl0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbWFya2VyOiAkeygoYml0c0RhdGEgPDwgOCkgfCBuZXh0Qnl0ZSkudG9TdHJpbmcoMTYpfWApO1xuICAgICAgfVxuICAgICAgLy8gdW5zdHVmZiAwXG4gICAgfVxuICAgIGJpdHNDb3VudCA9IDc7XG4gICAgcmV0dXJuIGJpdHNEYXRhID4+PiA3O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUh1ZmZtYW4odHJlZSkge1xuICAgIGxldCBub2RlID0gdHJlZTtcbiAgICBsZXQgYml0O1xuICAgIHdoaWxlICgoYml0ID0gcmVhZEJpdCgpKSAhPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICBub2RlID0gbm9kZVtiaXRdO1xuICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGh1ZmZtYW4gc2VxdWVuY2UnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVjZWl2ZShpbml0aWFsTGVuZ3RoKSB7XG4gICAgbGV0IGxlbmd0aCA9IGluaXRpYWxMZW5ndGg7XG4gICAgbGV0IG4gPSAwO1xuICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBiaXQgPSByZWFkQml0KCk7XG4gICAgICBpZiAoYml0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBuID0gKG4gPDwgMSkgfCBiaXQ7XG4gICAgICAtLWxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHtcbiAgICBjb25zdCBuID0gcmVjZWl2ZShsZW5ndGgpO1xuICAgIGlmIChuID49IDEgPDwgKGxlbmd0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgcmV0dXJuIG4gKyAoLTEgPDwgbGVuZ3RoKSArIDE7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoY29tcG9uZW50LCB6eikge1xuICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTtcbiAgICBjb21wb25lbnQucHJlZCArPSBkaWZmO1xuICAgIHp6WzBdID0gY29tcG9uZW50LnByZWQ7XG4gICAgbGV0IGsgPSAxO1xuICAgIHdoaWxlIChrIDwgNjQpIHtcbiAgICAgIGNvbnN0IHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgY29uc3QgcyA9IHJzICYgMTU7XG4gICAgICBjb25zdCByID0gcnMgPj4gNDtcbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrICs9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayArPSByO1xuICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICB6elt6XSA9IHJlY2VpdmVBbmRFeHRlbmQocyk7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIHp6KSB7XG4gICAgY29uc3QgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTtcbiAgICBjb25zdCBkaWZmID0gdCA9PT0gMCA/IDAgOiAocmVjZWl2ZUFuZEV4dGVuZCh0KSA8PCBzdWNjZXNzaXZlKTtcbiAgICBjb21wb25lbnQucHJlZCArPSBkaWZmO1xuICAgIHp6WzBdID0gY29tcG9uZW50LnByZWQ7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGNvbXBvbmVudCwgenopIHtcbiAgICB6elswXSB8PSByZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZTtcbiAgfVxuICBsZXQgZW9icnVuID0gMDtcbiAgZnVuY3Rpb24gZGVjb2RlQUNGaXJzdChjb21wb25lbnQsIHp6KSB7XG4gICAgaWYgKGVvYnJ1biA+IDApIHtcbiAgICAgIGVvYnJ1bi0tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7XG4gICAgY29uc3QgZSA9IHNwZWN0cmFsRW5kO1xuICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgIGNvbnN0IHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpO1xuICAgICAgY29uc3QgcyA9IHJzICYgMTU7XG4gICAgICBjb25zdCByID0gcnMgPj4gNDtcbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcikgLSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGsgKz0gMTY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrICs9IHI7XG4gICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdba107XG4gICAgICAgIHp6W3pdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gIGxldCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7XG4gIGZ1bmN0aW9uIGRlY29kZUFDU3VjY2Vzc2l2ZShjb21wb25lbnQsIHp6KSB7XG4gICAgbGV0IGsgPSBzcGVjdHJhbFN0YXJ0O1xuICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDtcbiAgICBsZXQgciA9IDA7XG4gICAgd2hpbGUgKGsgPD0gZSkge1xuICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHp6W3pdIDwgMCA/IC0xIDogMTtcbiAgICAgIHN3aXRjaCAoc3VjY2Vzc2l2ZUFDU3RhdGUpIHtcbiAgICAgICAgY2FzZSAwOiB7IC8vIGluaXRpYWwgc3RhdGVcbiAgICAgICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgICAgICBjb25zdCBzID0gcnMgJiAxNTtcbiAgICAgICAgICByID0gcnMgPj4gNDtcbiAgICAgICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCAxNSkge1xuICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHIgPSAxNjtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocyAhPT0gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQUNuIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSByID8gMiA6IDM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOiAvLyBza2lwcGluZyByIHplcm8gaXRlbXNcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGlmICh6elt6XSkge1xuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgci0tO1xuICAgICAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSBzdWNjZXNzaXZlQUNTdGF0ZSA9PT0gMiA/IDMgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAvLyBzZXQgdmFsdWUgZm9yIGEgemVybyBpdGVtXG4gICAgICAgICAgaWYgKHp6W3pdKSB7XG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB6elt6XSA9IHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA8PCBzdWNjZXNzaXZlO1xuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OiAvLyBlb2JcbiAgICAgICAgICBpZiAoenpbel0pIHtcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaysrO1xuICAgIH1cbiAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHtcbiAgICAgIGVvYnJ1bi0tO1xuICAgICAgaWYgKGVvYnJ1biA9PT0gMCkge1xuICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZ1bmN0aW9uLCBtY3UsIHJvdywgY29sKSB7XG4gICAgY29uc3QgbWN1Um93ID0gKG1jdSAvIG1jdXNQZXJMaW5lKSB8IDA7XG4gICAgY29uc3QgbWN1Q29sID0gbWN1ICUgbWN1c1BlckxpbmU7XG4gICAgY29uc3QgYmxvY2tSb3cgPSAobWN1Um93ICogY29tcG9uZW50LnYpICsgcm93O1xuICAgIGNvbnN0IGJsb2NrQ29sID0gKG1jdUNvbCAqIGNvbXBvbmVudC5oKSArIGNvbDtcbiAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQmxvY2soY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1KSB7XG4gICAgY29uc3QgYmxvY2tSb3cgPSAobWN1IC8gY29tcG9uZW50LmJsb2Nrc1BlckxpbmUpIHwgMDtcbiAgICBjb25zdCBibG9ja0NvbCA9IG1jdSAlIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lO1xuICAgIGRlY29kZUZ1bmN0aW9uKGNvbXBvbmVudCwgY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdKTtcbiAgfVxuXG4gIGNvbnN0IGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgbGV0IGNvbXBvbmVudDtcbiAgbGV0IGk7XG4gIGxldCBqO1xuICBsZXQgaztcbiAgbGV0IG47XG4gIGxldCBkZWNvZGVGbjtcbiAgaWYgKHByb2dyZXNzaXZlKSB7XG4gICAgaWYgKHNwZWN0cmFsU3RhcnQgPT09IDApIHtcbiAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlQUNGaXJzdCA6IGRlY29kZUFDU3VjY2Vzc2l2ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVjb2RlRm4gPSBkZWNvZGVCYXNlbGluZTtcbiAgfVxuXG4gIGxldCBtY3UgPSAwO1xuICBsZXQgbWFya2VyO1xuICBsZXQgbWN1RXhwZWN0ZWQ7XG4gIGlmIChjb21wb25lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgbWN1RXhwZWN0ZWQgPSBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckxpbmUgKiBjb21wb25lbnRzWzBdLmJsb2Nrc1BlckNvbHVtbjtcbiAgfSBlbHNlIHtcbiAgICBtY3VFeHBlY3RlZCA9IG1jdXNQZXJMaW5lICogZnJhbWUubWN1c1BlckNvbHVtbjtcbiAgfVxuXG4gIGNvbnN0IHVzZWRSZXNldEludGVydmFsID0gcmVzZXRJbnRlcnZhbCB8fCBtY3VFeHBlY3RlZDtcblxuICB3aGlsZSAobWN1IDwgbWN1RXhwZWN0ZWQpIHtcbiAgICAvLyByZXNldCBpbnRlcnZhbCBzdHVmZlxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbXBvbmVudHNbaV0ucHJlZCA9IDA7XG4gICAgfVxuICAgIGVvYnJ1biA9IDA7XG5cbiAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkge1xuICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1swXTtcbiAgICAgIGZvciAobiA9IDA7IG4gPCB1c2VkUmVzZXRJbnRlcnZhbDsgbisrKSB7XG4gICAgICAgIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSk7XG4gICAgICAgIG1jdSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgdXNlZFJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICBjb25zdCB7IGgsIHYgfSA9IGNvbXBvbmVudDtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdjsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7XG4gICAgICAgICAgICAgIGRlY29kZU1jdShjb21wb25lbnQsIGRlY29kZUZuLCBtY3UsIGosIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtY3UrKztcblxuICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIG91ciBleHBlY3RlZCBNQ1Uncywgc3RvcCBkZWNvZGluZ1xuICAgICAgICBpZiAobWN1ID09PSBtY3VFeHBlY3RlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBtYXJrZXJcbiAgICBiaXRzQ291bnQgPSAwO1xuICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgIGlmIChtYXJrZXIgPCAweEZGMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VyIHdhcyBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7IC8vIFJTVHhcbiAgICAgIG9mZnNldCArPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSB7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGNvbnN0IHsgYmxvY2tzUGVyTGluZSwgYmxvY2tzUGVyQ29sdW1uIH0gPSBjb21wb25lbnQ7XG4gIGNvbnN0IHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzO1xuICBjb25zdCBSID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuXG4gIC8vIEEgcG9ydCBvZiBwb3BwbGVyJ3MgSURDVCBtZXRob2Qgd2hpY2ggaW4gdHVybiBpcyB0YWtlbiBmcm9tOlxuICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosXG4gIC8vICAgXCJQcmFjdGljYWwgRmFzdCAxLUQgRENUIEFsZ29yaXRobXMgd2l0aCAxMSBNdWx0aXBsaWNhdGlvbnNcIixcbiAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksXG4gIC8vICAgOTg4LTk5MS5cbiAgZnVuY3Rpb24gcXVhbnRpemVBbmRJbnZlcnNlKHp6LCBkYXRhT3V0LCBkYXRhSW4pIHtcbiAgICBjb25zdCBxdCA9IGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZTtcbiAgICBsZXQgdjA7XG4gICAgbGV0IHYxO1xuICAgIGxldCB2MjtcbiAgICBsZXQgdjM7XG4gICAgbGV0IHY0O1xuICAgIGxldCB2NTtcbiAgICBsZXQgdjY7XG4gICAgbGV0IHY3O1xuICAgIGxldCB0O1xuICAgIGNvbnN0IHAgPSBkYXRhSW47XG4gICAgbGV0IGk7XG5cbiAgICAvLyBkZXF1YW50XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgIHBbaV0gPSB6eltpXSAqIHF0W2ldO1xuICAgIH1cblxuICAgIC8vIGludmVyc2UgRENUIG9uIHJvd3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICBjb25zdCByb3cgPSA4ICogaTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGFsbC16ZXJvIEFDIGNvZWZmaWNpZW50c1xuICAgICAgaWYgKHBbMSArIHJvd10gPT09IDAgJiYgcFsyICsgcm93XSA9PT0gMCAmJiBwWzMgKyByb3ddID09PSAwXG4gICAgICAgICYmIHBbNCArIHJvd10gPT09IDAgJiYgcFs1ICsgcm93XSA9PT0gMCAmJiBwWzYgKyByb3ddID09PSAwXG4gICAgICAgICYmIHBbNyArIHJvd10gPT09IDApIHtcbiAgICAgICAgdCA9ICgoZGN0U3FydDIgKiBwWzAgKyByb3ddKSArIDUxMikgPj4gMTA7XG4gICAgICAgIHBbMCArIHJvd10gPSB0O1xuICAgICAgICBwWzEgKyByb3ddID0gdDtcbiAgICAgICAgcFsyICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMyArIHJvd10gPSB0O1xuICAgICAgICBwWzQgKyByb3ddID0gdDtcbiAgICAgICAgcFs1ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNiArIHJvd10gPSB0O1xuICAgICAgICBwWzcgKyByb3ddID0gdDtcbiAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gc3RhZ2UgNFxuICAgICAgdjAgPSAoKGRjdFNxcnQyICogcFswICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2MSA9ICgoZGN0U3FydDIgKiBwWzQgKyByb3ddKSArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gcFsyICsgcm93XTtcbiAgICAgIHYzID0gcFs2ICsgcm93XTtcbiAgICAgIHY0ID0gKChkY3RTcXJ0MWQyICogKHBbMSArIHJvd10gLSBwWzcgKyByb3ddKSkgKyAxMjgpID4+IDg7XG4gICAgICB2NyA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4O1xuICAgICAgdjUgPSBwWzMgKyByb3ddIDw8IDQ7XG4gICAgICB2NiA9IHBbNSArIHJvd10gPDwgNDtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xuICAgICAgdjEgPSB0O1xuICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMTI4KSA+PiA4O1xuICAgICAgdjIgPSAoKHYyICogZGN0Q29zNikgLSAodjMgKiBkY3RTaW42KSArIDEyOCkgPj4gODtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY2ID0gdDtcbiAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY3ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMlxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgdjIgPSB0O1xuICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NCA9ICgodjQgKiBkY3RDb3MzKSAtICh2NyAqIGRjdFNpbjMpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IHQ7XG4gICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gKCh2NSAqIGRjdENvczEpIC0gKHY2ICogZGN0U2luMSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY2ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMVxuICAgICAgcFswICsgcm93XSA9IHYwICsgdjc7XG4gICAgICBwWzcgKyByb3ddID0gdjAgLSB2NztcbiAgICAgIHBbMSArIHJvd10gPSB2MSArIHY2O1xuICAgICAgcFs2ICsgcm93XSA9IHYxIC0gdjY7XG4gICAgICBwWzIgKyByb3ddID0gdjIgKyB2NTtcbiAgICAgIHBbNSArIHJvd10gPSB2MiAtIHY1O1xuICAgICAgcFszICsgcm93XSA9IHYzICsgdjQ7XG4gICAgICBwWzQgKyByb3ddID0gdjMgLSB2NDtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiBjb2x1bW5zXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgY29uc3QgY29sID0gaTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGFsbC16ZXJvIEFDIGNvZWZmaWNpZW50c1xuICAgICAgaWYgKHBbKDEgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoMiAqIDgpICsgY29sXSA9PT0gMCAmJiBwWygzICogOCkgKyBjb2xdID09PSAwXG4gICAgICAgICYmIHBbKDQgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWyg2ICogOCkgKyBjb2xdID09PSAwXG4gICAgICAgICYmIHBbKDcgKiA4KSArIGNvbF0gPT09IDApIHtcbiAgICAgICAgdCA9ICgoZGN0U3FydDIgKiBkYXRhSW5baSArIDBdKSArIDgxOTIpID4+IDE0O1xuICAgICAgICBwWygwICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoMSAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDIgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWygzICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDUgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg2ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbKDAgKiA4KSArIGNvbF0pICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MSA9ICgoZGN0U3FydDIgKiBwWyg0ICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjIgPSBwWygyICogOCkgKyBjb2xdO1xuICAgICAgdjMgPSBwWyg2ICogOCkgKyBjb2xdO1xuICAgICAgdjQgPSAoKGRjdFNxcnQxZDIgKiAocFsoMSAqIDgpICsgY29sXSAtIHBbKDcgKiA4KSArIGNvbF0pKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsoMSAqIDgpICsgY29sXSArIHBbKDcgKiA4KSArIGNvbF0pKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjUgPSBwWygzICogOCkgKyBjb2xdO1xuICAgICAgdjYgPSBwWyg1ICogOCkgKyBjb2xdO1xuXG4gICAgICAvLyBzdGFnZSAzXG4gICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxO1xuICAgICAgdjAgPSAodjAgKyB2MSArIDEpID4+IDE7XG4gICAgICB2MSA9IHQ7XG4gICAgICB0ID0gKCh2MiAqIGRjdFNpbjYpICsgKHYzICogZGN0Q29zNikgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7XG4gICAgICB2NCA9ICh2NCArIHY2ICsgMSkgPj4gMTtcbiAgICAgIHY2ID0gdDtcbiAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7XG4gICAgICB2NSA9ICh2NyAtIHY1ICsgMSkgPj4gMTtcbiAgICAgIHY3ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMlxuICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjMgKyAxKSA+PiAxO1xuICAgICAgdjMgPSB0O1xuICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTtcbiAgICAgIHYxID0gKHYxICsgdjIgKyAxKSA+PiAxO1xuICAgICAgdjIgPSB0O1xuICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NCA9ICgodjQgKiBkY3RDb3MzKSAtICh2NyAqIGRjdFNpbjMpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NyA9IHQ7XG4gICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gKCh2NSAqIGRjdENvczEpIC0gKHY2ICogZGN0U2luMSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY2ID0gdDtcblxuICAgICAgLy8gc3RhZ2UgMVxuICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHYwICsgdjc7XG4gICAgICBwWyg3ICogOCkgKyBjb2xdID0gdjAgLSB2NztcbiAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB2MSArIHY2O1xuICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHYxIC0gdjY7XG4gICAgICBwWygyICogOCkgKyBjb2xdID0gdjIgKyB2NTtcbiAgICAgIHBbKDUgKiA4KSArIGNvbF0gPSB2MiAtIHY1O1xuICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHYzICsgdjQ7XG4gICAgICBwWyg0ICogOCkgKyBjb2xdID0gdjMgLSB2NDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIDgtYml0IGludGVnZXJzXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IDEyOCArICgocFtpXSArIDgpID4+IDQpO1xuICAgICAgaWYgKHNhbXBsZSA8IDApIHtcbiAgICAgICAgZGF0YU91dFtpXSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNhbXBsZSA+IDBYRkYpIHtcbiAgICAgICAgZGF0YU91dFtpXSA9IDB4RkY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhT3V0W2ldID0gc2FtcGxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGJsb2NrUm93ID0gMDsgYmxvY2tSb3cgPCBibG9ja3NQZXJDb2x1bW47IGJsb2NrUm93KyspIHtcbiAgICBjb25zdCBzY2FuTGluZSA9IGJsb2NrUm93IDw8IDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoc2FtcGxlc1BlckxpbmUpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHtcbiAgICAgIHF1YW50aXplQW5kSW52ZXJzZShjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0sIHIsIFIpO1xuXG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGJsb2NrQ29sIDw8IDM7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbc2NhbkxpbmUgKyBqXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICBsaW5lW3NhbXBsZSArIGldID0gcltvZmZzZXQrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuXG5jbGFzcyBKcGVnU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5qZmlmID0gbnVsbDtcbiAgICB0aGlzLmFkb2JlID0gbnVsbDtcblxuICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzID0gW107XG4gICAgdGhpcy5odWZmbWFuVGFibGVzQUMgPSBbXTtcbiAgICB0aGlzLmh1ZmZtYW5UYWJsZXNEQyA9IFtdO1xuICAgIHRoaXMucmVzZXRGcmFtZXMoKTtcbiAgfVxuXG4gIHJlc2V0RnJhbWVzKCkge1xuICAgIHRoaXMuZnJhbWVzID0gW107XG4gIH1cblxuICBwYXJzZShkYXRhKSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgLy8gY29uc3QgeyBsZW5ndGggfSA9IGRhdGE7XG4gICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gKGRhdGFbb2Zmc2V0XSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZERhdGFCbG9jaygpIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgIGNvbnN0IGFycmF5ID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCAtIDIpO1xuICAgICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpIHtcbiAgICAgIGxldCBtYXhIID0gMDtcbiAgICAgIGxldCBtYXhWID0gMDtcbiAgICAgIGxldCBjb21wb25lbnQ7XG4gICAgICBsZXQgY29tcG9uZW50SWQ7XG4gICAgICBmb3IgKGNvbXBvbmVudElkIGluIGZyYW1lLmNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGZyYW1lLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkoY29tcG9uZW50SWQpKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF07XG4gICAgICAgICAgaWYgKG1heEggPCBjb21wb25lbnQuaCkge1xuICAgICAgICAgICAgbWF4SCA9IGNvbXBvbmVudC5oO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4ViA8IGNvbXBvbmVudC52KSB7XG4gICAgICAgICAgICBtYXhWID0gY29tcG9uZW50LnY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtY3VzUGVyTGluZSA9IE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDggLyBtYXhIKTtcbiAgICAgIGNvbnN0IG1jdXNQZXJDb2x1bW4gPSBNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCAvIG1heFYpO1xuICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckxpbmUgPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNhbXBsZXNQZXJMaW5lIC8gOCkgKiBjb21wb25lbnQuaCAvIG1heEgpO1xuICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckNvbHVtbiA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCkgKiBjb21wb25lbnQudiAvIG1heFYpO1xuICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckxpbmVGb3JNY3UgPSBtY3VzUGVyTGluZSAqIGNvbXBvbmVudC5oO1xuICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckNvbHVtbkZvck1jdSA9IG1jdXNQZXJDb2x1bW4gKiBjb21wb25lbnQudjtcbiAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrc1BlckNvbHVtbkZvck1jdTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2tzUGVyTGluZUZvck1jdTsgaisrKSB7XG4gICAgICAgICAgICAgIHJvdy5wdXNoKG5ldyBJbnQzMkFycmF5KDY0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9ja3MucHVzaChyb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmU7XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjtcbiAgICAgICAgICBjb21wb25lbnQuYmxvY2tzID0gYmxvY2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFtZS5tYXhIID0gbWF4SDtcbiAgICAgIGZyYW1lLm1heFYgPSBtYXhWO1xuICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTtcbiAgICAgIGZyYW1lLm1jdXNQZXJDb2x1bW4gPSBtY3VzUGVyQ29sdW1uO1xuICAgIH1cblxuICAgIGxldCBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIGlmIChmaWxlTWFya2VyICE9PSAweEZGRDgpIHsgLy8gU09JIChTdGFydCBvZiBJbWFnZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignU09JIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgd2hpbGUgKGZpbGVNYXJrZXIgIT09IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSlcbiAgICAgIHN3aXRjaCAoZmlsZU1hcmtlcikge1xuICAgICAgICBjYXNlIDB4RkYwMDogYnJlYWs7XG4gICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYylcbiAgICAgICAgY2FzZSAweEZGRTE6IC8vIEFQUDFcbiAgICAgICAgY2FzZSAweEZGRTI6IC8vIEFQUDJcbiAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDNcbiAgICAgICAgY2FzZSAweEZGRTQ6IC8vIEFQUDRcbiAgICAgICAgY2FzZSAweEZGRTU6IC8vIEFQUDVcbiAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDZcbiAgICAgICAgY2FzZSAweEZGRTc6IC8vIEFQUDdcbiAgICAgICAgY2FzZSAweEZGRTg6IC8vIEFQUDhcbiAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDlcbiAgICAgICAgY2FzZSAweEZGRUE6IC8vIEFQUDEwXG4gICAgICAgIGNhc2UgMHhGRkVCOiAvLyBBUFAxMVxuICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTJcbiAgICAgICAgY2FzZSAweEZGRUQ6IC8vIEFQUDEzXG4gICAgICAgIGNhc2UgMHhGRkVFOiAvLyBBUFAxNFxuICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTVcbiAgICAgICAgY2FzZSAweEZGRkU6IHsgLy8gQ09NIChDb21tZW50KVxuICAgICAgICAgIGNvbnN0IGFwcERhdGEgPSByZWFkRGF0YUJsb2NrKCk7XG5cbiAgICAgICAgICBpZiAoZmlsZU1hcmtlciA9PT0gMHhGRkUwKSB7XG4gICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDlcbiAgICAgICAgICAgICAgJiYgYXBwRGF0YVszXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzRdID09PSAwKSB7IC8vICdKRklGXFx4MDAnXG4gICAgICAgICAgICAgIHRoaXMuamZpZiA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB7IG1ham9yOiBhcHBEYXRhWzVdLCBtaW5vcjogYXBwRGF0YVs2XSB9LFxuICAgICAgICAgICAgICAgIGRlbnNpdHlVbml0czogYXBwRGF0YVs3XSxcbiAgICAgICAgICAgICAgICB4RGVuc2l0eTogKGFwcERhdGFbOF0gPDwgOCkgfCBhcHBEYXRhWzldLFxuICAgICAgICAgICAgICAgIHlEZW5zaXR5OiAoYXBwRGF0YVsxMF0gPDwgOCkgfCBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgICB0aHVtYldpZHRoOiBhcHBEYXRhWzEyXSxcbiAgICAgICAgICAgICAgICB0aHVtYkhlaWdodDogYXBwRGF0YVsxM10sXG4gICAgICAgICAgICAgICAgdGh1bWJEYXRhOiBhcHBEYXRhLnN1YmFycmF5KDE0LCAxNCArICgzICogYXBwRGF0YVsxMl0gKiBhcHBEYXRhWzEzXSkpLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPIEFQUDEgLSBFeGlmXG4gICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFRSkge1xuICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NDEgJiYgYXBwRGF0YVsxXSA9PT0gMHg2NCAmJiBhcHBEYXRhWzJdID09PSAweDZGXG4gICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NjIgJiYgYXBwRGF0YVs0XSA9PT0gMHg2NSAmJiBhcHBEYXRhWzVdID09PSAwKSB7IC8vICdBZG9iZVxceDAwJ1xuICAgICAgICAgICAgICB0aGlzLmFkb2JlID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IGFwcERhdGFbNl0sXG4gICAgICAgICAgICAgICAgZmxhZ3MwOiAoYXBwRGF0YVs3XSA8PCA4KSB8IGFwcERhdGFbOF0sXG4gICAgICAgICAgICAgICAgZmxhZ3MxOiAoYXBwRGF0YVs5XSA8PCA4KSB8IGFwcERhdGFbMTBdLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUNvZGU6IGFwcERhdGFbMTFdLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkRCOiB7IC8vIERRVCAoRGVmaW5lIFF1YW50aXphdGlvbiBUYWJsZXMpXG4gICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0VuZCA9IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCArIG9mZnNldCAtIDI7XG4gICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkge1xuICAgICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBjb25zdCB0YWJsZURhdGEgPSBuZXcgSW50MzJBcnJheSg2NCk7XG4gICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXNcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgocXVhbnRpemF0aW9uVGFibGVTcGVjID4+IDQpID09PSAxKSB7IC8vIDE2IGJpdFxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2pdO1xuICAgICAgICAgICAgICAgIHRhYmxlRGF0YVt6XSA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEUVQ6IGludmFsaWQgdGFibGUgc3BlYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5xdWFudGl6YXRpb25UYWJsZXNbcXVhbnRpemF0aW9uVGFibGVTcGVjICYgMTVdID0gdGFibGVEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkMwOiAvLyBTT0YwIChTdGFydCBvZiBGcmFtZSwgQmFzZWxpbmUgRENUKVxuICAgICAgICBjYXNlIDB4RkZDMTogLy8gU09GMSAoU3RhcnQgb2YgRnJhbWUsIEV4dGVuZGVkIERDVClcbiAgICAgICAgY2FzZSAweEZGQzI6IHsgLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVClcbiAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGhcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IHtcbiAgICAgICAgICAgIGV4dGVuZGVkOiAoZmlsZU1hcmtlciA9PT0gMHhGRkMxKSxcbiAgICAgICAgICAgIHByb2dyZXNzaXZlOiAoZmlsZU1hcmtlciA9PT0gMHhGRkMyKSxcbiAgICAgICAgICAgIHByZWNpc2lvbjogZGF0YVtvZmZzZXQrK10sXG4gICAgICAgICAgICBzY2FuTGluZXM6IHJlYWRVaW50MTYoKSxcbiAgICAgICAgICAgIHNhbXBsZXNQZXJMaW5lOiByZWFkVWludDE2KCksXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgICAgIGNvbXBvbmVudHNPcmRlcjogW10sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHNDb3VudCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGxldCBjb21wb25lbnRJZDtcbiAgICAgICAgICAvLyBsZXQgbWF4SCA9IDA7XG4gICAgICAgICAgLy8gbGV0IG1heFYgPSAwO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50c0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudElkID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgY29uc3QgaCA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gNDtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhW29mZnNldCArIDFdICYgMTU7XG4gICAgICAgICAgICBjb25zdCBxSWQgPSBkYXRhW29mZnNldCArIDJdO1xuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50c09yZGVyLnB1c2goY29tcG9uZW50SWQpO1xuICAgICAgICAgICAgZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF0gPSB7XG4gICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgIHF1YW50aXphdGlvbklkeDogcUlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSk7XG4gICAgICAgICAgdGhpcy5mcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZDNDogeyAvLyBESFQgKERlZmluZSBIdWZmbWFuIFRhYmxlcylcbiAgICAgICAgICBjb25zdCBodWZmbWFuTGVuZ3RoID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgaHVmZm1hbkxlbmd0aDspIHtcbiAgICAgICAgICAgIGNvbnN0IGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVMZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICAgICAgbGV0IGNvZGVMZW5ndGhTdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKykge1xuICAgICAgICAgICAgICBjb2RlTGVuZ3Roc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgY29kZUxlbmd0aFN1bSArPSBjb2RlTGVuZ3Roc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGh1ZmZtYW5WYWx1ZXMgPSBuZXcgVWludDhBcnJheShjb2RlTGVuZ3RoU3VtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29kZUxlbmd0aFN1bTsgaisrLCBvZmZzZXQrKykge1xuICAgICAgICAgICAgICBodWZmbWFuVmFsdWVzW2pdID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxNyArIGNvZGVMZW5ndGhTdW07XG5cbiAgICAgICAgICAgIGlmICgoaHVmZm1hblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1todWZmbWFuVGFibGVTcGVjICYgMTVdID0gYnVpbGRIdWZmbWFuVGFibGUoXG4gICAgICAgICAgICAgICAgY29kZUxlbmd0aHMsIGh1ZmZtYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmh1ZmZtYW5UYWJsZXNBQ1todWZmbWFuVGFibGVTcGVjICYgMTVdID0gYnVpbGRIdWZmbWFuVGFibGUoXG4gICAgICAgICAgICAgICAgY29kZUxlbmd0aHMsIGh1ZmZtYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGREQ6IC8vIERSSSAoRGVmaW5lIFJlc3RhcnQgSW50ZXJ2YWwpXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgdGhpcy5yZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMHhGRkRBOiB7IC8vIFNPUyAoU3RhcnQgb2YgU2NhbilcbiAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgbGVuZ3RoXG4gICAgICAgICAgY29uc3Qgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmZyYW1lc1swXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbZGF0YVtvZmZzZXQrK11dO1xuICAgICAgICAgICAgY29uc3QgdGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1t0YWJsZVNwZWMgPj4gNF07XG4gICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlQUMgPSB0aGlzLmh1ZmZtYW5UYWJsZXNBQ1t0YWJsZVNwZWMgJiAxNV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3BlY3RyYWxTdGFydCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IHNwZWN0cmFsRW5kID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3Qgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBkZWNvZGVTY2FuKGRhdGEsIG9mZnNldCxcbiAgICAgICAgICAgIGZyYW1lLCBjb21wb25lbnRzLCB0aGlzLnJlc2V0SW50ZXJ2YWwsXG4gICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCxcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID4+IDQsIHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uICYgMTUpO1xuICAgICAgICAgIG9mZnNldCArPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZGRjogLy8gRmlsbCBieXRlc1xuICAgICAgICAgIGlmIChkYXRhW29mZnNldF0gIT09IDB4RkYpIHsgLy8gQXZvaWQgc2tpcHBpbmcgYSB2YWxpZCBtYXJrZXIuXG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAzXSA9PT0gMHhGRlxuICAgICAgICAgICAgJiYgZGF0YVtvZmZzZXQgLSAyXSA+PSAweEMwICYmIGRhdGFbb2Zmc2V0IC0gMl0gPD0gMHhGRSkge1xuICAgICAgICAgICAgLy8gY291bGQgYmUgaW5jb3JyZWN0IGVuY29kaW5nIC0tIGxhc3QgMHhGRiBieXRlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgLy8gYmxvY2sgd2FzIGVhdGVuIGJ5IHRoZSBlbmNvZGVyXG4gICAgICAgICAgICBvZmZzZXQgLT0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gSlBFRyBtYXJrZXIgJHtmaWxlTWFya2VyLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgIH1cbiAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVzdWx0KCkge1xuICAgIGNvbnN0IHsgZnJhbWVzIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZnJhbWVzIHdlcmUgZGVjb2RlZCcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKCdtb3JlIHRoYW4gb25lIGZyYW1lIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgZWFjaCBmcmFtZSdzIGNvbXBvbmVudHMgcXVhbnRpemF0aW9uIHRhYmxlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3AgPSB0aGlzLmZyYW1lc1tpXS5jb21wb25lbnRzO1xuICAgICAgZm9yIChjb25zdCBqIG9mIE9iamVjdC5rZXlzKGNwKSkge1xuICAgICAgICBjcFtqXS5xdWFudGl6YXRpb25UYWJsZSA9IHRoaXMucXVhbnRpemF0aW9uVGFibGVzW2NwW2pdLnF1YW50aXphdGlvbklkeF07XG4gICAgICAgIGRlbGV0ZSBjcFtqXS5xdWFudGl6YXRpb25JZHg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbMF07XG4gICAgY29uc3QgeyBjb21wb25lbnRzLCBjb21wb25lbnRzT3JkZXIgfSA9IGZyYW1lO1xuICAgIGNvbnN0IG91dENvbXBvbmVudHMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lO1xuICAgIGNvbnN0IGhlaWdodCA9IGZyYW1lLnNjYW5MaW5lcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50c09yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudHNPcmRlcltpXV07XG4gICAgICBvdXRDb21wb25lbnRzLnB1c2goe1xuICAgICAgICBsaW5lczogYnVpbGRDb21wb25lbnREYXRhKGZyYW1lLCBjb21wb25lbnQpLFxuICAgICAgICBzY2FsZVg6IGNvbXBvbmVudC5oIC8gZnJhbWUubWF4SCxcbiAgICAgICAgc2NhbGVZOiBjb21wb25lbnQudiAvIGZyYW1lLm1heFYsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIG91dENvbXBvbmVudHMubGVuZ3RoKTtcbiAgICBsZXQgb2kgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dENvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBvdXRDb21wb25lbnRzW2ldO1xuICAgICAgICAgIG91dFtvaV0gPSBjb21wb25lbnQubGluZXNbMCB8IHkgKiBjb21wb25lbnQuc2NhbGVZXVswIHwgeCAqIGNvbXBvbmVudC5zY2FsZVhdO1xuICAgICAgICAgICsrb2k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKcGVnRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoZmlsZURpcmVjdG9yeSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZWFkZXIgPSBuZXcgSnBlZ1N0cmVhbVJlYWRlcigpO1xuICAgIGlmIChmaWxlRGlyZWN0b3J5LkpQRUdUYWJsZXMpIHtcbiAgICAgIHRoaXMucmVhZGVyLnBhcnNlKGZpbGVEaXJlY3RvcnkuSlBFR1RhYmxlcyk7XG4gICAgfVxuICB9XG5cbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgdGhpcy5yZWFkZXIucmVzZXRGcmFtZXMoKTtcbiAgICB0aGlzLnJlYWRlci5wYXJzZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICByZXR1cm4gdGhpcy5yZWFkZXIuZ2V0UmVzdWx0KCkuYnVmZmVyO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/jpeg.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lerc.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LercDecoder),\n/* harmony export */   zstd: () => (/* binding */ zstd)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var lerc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lerc */ \"(ssr)/./node_modules/lerc/LercDecode.js\");\n/* harmony import */ var zstddec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zstddec */ \"(ssr)/./node_modules/zstddec/dist/zstddec.modern.js\");\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n\n\n\n\n\n\nconst zstd = new zstddec__WEBPACK_IMPORTED_MODULE_2__.ZSTDDecoder();\n\nclass LercDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(fileDirectory) {\n    super();\n\n    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;\n    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;\n\n    this.addCompression = fileDirectory.LercParameters[_globals_js__WEBPACK_IMPORTED_MODULE_4__.LercParameters.AddCompression];\n  }\n\n  decodeBlock(buffer) {\n    switch (this.addCompression) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.None:\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Deflate:\n        buffer = (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_4__.LercAddCompression.Zstandard:\n        buffer = zstd.decode(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      default:\n        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);\n    }\n\n    const lercResult = lerc__WEBPACK_IMPORTED_MODULE_1__.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });\n    const lercData = lercResult.pixels[0];\n    return lercData.buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sZXJjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0I7QUFDUDtBQUNjO0FBQ0s7QUFDd0I7O0FBRTVELGlCQUFpQixnREFBVzs7QUFFcEIsMEJBQTBCLHVEQUFXO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1REFBdUQsdURBQWM7QUFDckU7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMkRBQWtCO0FBQzdCO0FBQ0EsV0FBVywyREFBa0I7QUFDN0IsaUJBQWlCLDZDQUFPLGlDQUFpQztBQUN6RDtBQUNBLFdBQVcsMkRBQWtCO0FBQzdCLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0Esc0ZBQXNGLG9CQUFvQjtBQUMxRzs7QUFFQSx1QkFBdUIsd0NBQVcsV0FBVyw0REFBNEQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGNvbXByZXNzaW9uXFxsZXJjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZmxhdGUgfSBmcm9tICdwYWtvJztcbmltcG9ydCBMZXJjIGZyb20gJ2xlcmMnO1xuaW1wb3J0IHsgWlNURERlY29kZXIgfSBmcm9tICd6c3RkZGVjJztcbmltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyLmpzJztcbmltcG9ydCB7IExlcmNQYXJhbWV0ZXJzLCBMZXJjQWRkQ29tcHJlc3Npb24gfSBmcm9tICcuLi9nbG9iYWxzLmpzJztcblxuZXhwb3J0IGNvbnN0IHpzdGQgPSBuZXcgWlNURERlY29kZXIoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGVyY0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID0gdHlwZW9mIGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24gOiAxO1xuICAgIHRoaXMuc2FtcGxlc1BlclBpeGVsID0gdHlwZW9mIGZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsICE9PSAndW5kZWZpbmVkJyA/IGZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsIDogMTtcblxuICAgIHRoaXMuYWRkQ29tcHJlc3Npb24gPSBmaWxlRGlyZWN0b3J5LkxlcmNQYXJhbWV0ZXJzW0xlcmNQYXJhbWV0ZXJzLkFkZENvbXByZXNzaW9uXTtcbiAgfVxuXG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHN3aXRjaCAodGhpcy5hZGRDb21wcmVzc2lvbikge1xuICAgICAgY2FzZSBMZXJjQWRkQ29tcHJlc3Npb24uTm9uZTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlcmNBZGRDb21wcmVzc2lvbi5EZWZsYXRlOlxuICAgICAgICBidWZmZXIgPSBpbmZsYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpLmJ1ZmZlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlcmNBZGRDb21wcmVzc2lvbi5ac3RhbmRhcmQ6XG4gICAgICAgIGJ1ZmZlciA9IHpzdGQuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpLmJ1ZmZlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIExFUkMgYWRkaXRpb25hbCBjb21wcmVzc2lvbiBtZXRob2QgaWRlbnRpZmllcjogJHt0aGlzLmFkZENvbXByZXNzaW9ufWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxlcmNSZXN1bHQgPSBMZXJjLmRlY29kZShidWZmZXIsIHsgcmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM6IHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSB9KTtcbiAgICBjb25zdCBsZXJjRGF0YSA9IGxlcmNSZXN1bHQucGl4ZWxzWzBdO1xuICAgIHJldHVybiBsZXJjRGF0YS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/lerc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/lzw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LZWDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nclass LZWDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9sencuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRTNDO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRCxLQUFLO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkRBQTJELFNBQVMsSUFBSSxpQkFBaUIsY0FBYyxTQUFTO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUseUJBQXlCLHVEQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxjb21wcmVzc2lvblxcbHp3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyLmpzJztcblxuY29uc3QgTUlOX0JJVFMgPSA5O1xuY29uc3QgQ0xFQVJfQ09ERSA9IDI1NjsgLy8gY2xlYXIgY29kZVxuY29uc3QgRU9JX0NPREUgPSAyNTc7IC8vIGVuZCBvZiBpbmZvcm1hdGlvblxuY29uc3QgTUFYX0JZVEVMRU5HVEggPSAxMjtcblxuZnVuY3Rpb24gZ2V0Qnl0ZShhcnJheSwgcG9zaXRpb24sIGxlbmd0aCkge1xuICBjb25zdCBkID0gcG9zaXRpb24gJSA4O1xuICBjb25zdCBhID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIDgpO1xuICBjb25zdCBkZSA9IDggLSBkO1xuICBjb25zdCBlZiA9IChwb3NpdGlvbiArIGxlbmd0aCkgLSAoKGEgKyAxKSAqIDgpO1xuICBsZXQgZmcgPSAoOCAqIChhICsgMikpIC0gKHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgY29uc3QgZGcgPSAoKGEgKyAyKSAqIDgpIC0gcG9zaXRpb247XG4gIGZnID0gTWF0aC5tYXgoMCwgZmcpO1xuICBpZiAoYSA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICBjb25zb2xlLndhcm4oJ3JhbiBvZmYgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGJlZm9yZSBmaW5kaW5nIEVPSV9DT0RFIChlbmQgb24gaW5wdXQgY29kZSknKTtcbiAgICByZXR1cm4gRU9JX0NPREU7XG4gIH1cbiAgbGV0IGNodW5rMSA9IGFycmF5W2FdICYgKCgyICoqICg4IC0gZCkpIC0gMSk7XG4gIGNodW5rMSA8PD0gKGxlbmd0aCAtIGRlKTtcbiAgbGV0IGNodW5rcyA9IGNodW5rMTtcbiAgaWYgKGEgKyAxIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgbGV0IGNodW5rMiA9IGFycmF5W2EgKyAxXSA+Pj4gZmc7XG4gICAgY2h1bmsyIDw8PSBNYXRoLm1heCgwLCAobGVuZ3RoIC0gZGcpKTtcbiAgICBjaHVua3MgKz0gY2h1bmsyO1xuICB9XG4gIGlmIChlZiA+IDggJiYgYSArIDIgPCBhcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCBoaSA9ICgoYSArIDMpICogOCkgLSAocG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rMyA9IGFycmF5W2EgKyAyXSA+Pj4gaGk7XG4gICAgY2h1bmtzICs9IGNodW5rMztcbiAgfVxuICByZXR1cm4gY2h1bmtzO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRSZXZlcnNlZChkZXN0LCBzb3VyY2UpIHtcbiAgZm9yIChsZXQgaSA9IHNvdXJjZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGRlc3QucHVzaChzb3VyY2VbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG5mdW5jdGlvbiBkZWNvbXByZXNzKGlucHV0KSB7XG4gIGNvbnN0IGRpY3Rpb25hcnlJbmRleCA9IG5ldyBVaW50MTZBcnJheSg0MDkzKTtcbiAgY29uc3QgZGljdGlvbmFyeUNoYXIgPSBuZXcgVWludDhBcnJheSg0MDkzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU3OyBpKyspIHtcbiAgICBkaWN0aW9uYXJ5SW5kZXhbaV0gPSA0MDk2O1xuICAgIGRpY3Rpb25hcnlDaGFyW2ldID0gaTtcbiAgfVxuICBsZXQgZGljdGlvbmFyeUxlbmd0aCA9IDI1ODtcbiAgbGV0IGJ5dGVMZW5ndGggPSBNSU5fQklUUztcbiAgbGV0IHBvc2l0aW9uID0gMDtcblxuICBmdW5jdGlvbiBpbml0RGljdGlvbmFyeSgpIHtcbiAgICBkaWN0aW9uYXJ5TGVuZ3RoID0gMjU4O1xuICAgIGJ5dGVMZW5ndGggPSBNSU5fQklUUztcbiAgfVxuICBmdW5jdGlvbiBnZXROZXh0KGFycmF5KSB7XG4gICAgY29uc3QgYnl0ZSA9IGdldEJ5dGUoYXJyYXksIHBvc2l0aW9uLCBieXRlTGVuZ3RoKTtcbiAgICBwb3NpdGlvbiArPSBieXRlTGVuZ3RoO1xuICAgIHJldHVybiBieXRlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRvRGljdGlvbmFyeShpLCBjKSB7XG4gICAgZGljdGlvbmFyeUNoYXJbZGljdGlvbmFyeUxlbmd0aF0gPSBjO1xuICAgIGRpY3Rpb25hcnlJbmRleFtkaWN0aW9uYXJ5TGVuZ3RoXSA9IGk7XG4gICAgZGljdGlvbmFyeUxlbmd0aCsrO1xuICAgIHJldHVybiBkaWN0aW9uYXJ5TGVuZ3RoIC0gMTtcbiAgfVxuICBmdW5jdGlvbiBnZXREaWN0aW9uYXJ5UmV2ZXJzZWQobikge1xuICAgIGNvbnN0IHJldiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBuOyBpICE9PSA0MDk2OyBpID0gZGljdGlvbmFyeUluZGV4W2ldKSB7XG4gICAgICByZXYucHVzaChkaWN0aW9uYXJ5Q2hhcltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXY7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaW5pdERpY3Rpb25hcnkoKTtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gIGxldCBjb2RlID0gZ2V0TmV4dChhcnJheSk7XG4gIGxldCBvbGRDb2RlO1xuICB3aGlsZSAoY29kZSAhPT0gRU9JX0NPREUpIHtcbiAgICBpZiAoY29kZSA9PT0gQ0xFQVJfQ09ERSkge1xuICAgICAgaW5pdERpY3Rpb25hcnkoKTtcbiAgICAgIGNvZGUgPSBnZXROZXh0KGFycmF5KTtcbiAgICAgIHdoaWxlIChjb2RlID09PSBDTEVBUl9DT0RFKSB7XG4gICAgICAgIGNvZGUgPSBnZXROZXh0KGFycmF5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPT09IEVPSV9DT0RFKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID4gQ0xFQVJfQ09ERSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvcnJ1cHRlZCBjb2RlIGF0IHNjYW5saW5lICR7Y29kZX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGdldERpY3Rpb25hcnlSZXZlcnNlZChjb2RlKTtcbiAgICAgICAgYXBwZW5kUmV2ZXJzZWQocmVzdWx0LCB2YWwpO1xuICAgICAgICBvbGRDb2RlID0gY29kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGUgPCBkaWN0aW9uYXJ5TGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWwgPSBnZXREaWN0aW9uYXJ5UmV2ZXJzZWQoY29kZSk7XG4gICAgICBhcHBlbmRSZXZlcnNlZChyZXN1bHQsIHZhbCk7XG4gICAgICBhZGRUb0RpY3Rpb25hcnkob2xkQ29kZSwgdmFsW3ZhbC5sZW5ndGggLSAxXSk7XG4gICAgICBvbGRDb2RlID0gY29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2xkVmFsID0gZ2V0RGljdGlvbmFyeVJldmVyc2VkKG9sZENvZGUpO1xuICAgICAgaWYgKCFvbGRWYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCb2d1cyBlbnRyeS4gTm90IGluIGRpY3Rpb25hcnksICR7b2xkQ29kZX0gLyAke2RpY3Rpb25hcnlMZW5ndGh9LCBwb3NpdGlvbjogJHtwb3NpdGlvbn1gKTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZFJldmVyc2VkKHJlc3VsdCwgb2xkVmFsKTtcbiAgICAgIHJlc3VsdC5wdXNoKG9sZFZhbFtvbGRWYWwubGVuZ3RoIC0gMV0pO1xuICAgICAgYWRkVG9EaWN0aW9uYXJ5KG9sZENvZGUsIG9sZFZhbFtvbGRWYWwubGVuZ3RoIC0gMV0pO1xuICAgICAgb2xkQ29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKGRpY3Rpb25hcnlMZW5ndGggKyAxID49ICgyICoqIGJ5dGVMZW5ndGgpKSB7XG4gICAgICBpZiAoYnl0ZUxlbmd0aCA9PT0gTUFYX0JZVEVMRU5HVEgpIHtcbiAgICAgICAgb2xkQ29kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5dGVMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZSA9IGdldE5leHQoYXJyYXkpO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMWldEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICByZXR1cm4gZGVjb21wcmVzcyhidWZmZXIsIGZhbHNlKS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/lzw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/packbits.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PackbitsDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nclass PackbitsDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    const dataView = new DataView(buffer);\n    const out = [];\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      let header = dataView.getInt8(i);\n      if (header < 0) {\n        const next = dataView.getUint8(i + 1);\n        header = -header;\n        for (let j = 0; j <= header; ++j) {\n          out.push(next);\n        }\n        i += 1;\n      } else {\n        for (let j = 0; j <= header; ++j) {\n          out.push(dataView.getUint8(i + j + 1));\n        }\n        i += header + 1;\n      }\n    }\n    return new Uint8Array(out).buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9wYWNrYml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFNUIsOEJBQThCLHVEQUFXO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGNvbXByZXNzaW9uXFxwYWNrYml0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhY2tiaXRzRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBjb25zdCBvdXQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmJ5dGVMZW5ndGg7ICsraSkge1xuICAgICAgbGV0IGhlYWRlciA9IGRhdGFWaWV3LmdldEludDgoaSk7XG4gICAgICBpZiAoaGVhZGVyIDwgMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gZGF0YVZpZXcuZ2V0VWludDgoaSArIDEpO1xuICAgICAgICBoZWFkZXIgPSAtaGVhZGVyO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBoZWFkZXI7ICsraikge1xuICAgICAgICAgIG91dC5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGhlYWRlcjsgKytqKSB7XG4gICAgICAgICAgb3V0LnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSArIGogKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSBoZWFkZXIgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0KS5idWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/packbits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/raw.js":
/*!*************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/raw.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RawDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\nclass RawDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  decodeBlock(buffer) {\n    return buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9yYXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRTVCLHlCQUF5Qix1REFBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcY29tcHJlc3Npb25cXHJhdy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhd0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/raw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/webimage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebImageDecoder)\n/* harmony export */ });\n/* harmony import */ var _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n\n\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nclass WebImageDecoder extends _basedecoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor() {\n    super();\n    if (typeof createImageBitmap === 'undefined') {\n      throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n    } else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n      throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n    }\n  }\n\n  async decode(fileDirectory, buffer) {\n    const blob = new Blob([buffer]);\n    const imageBitmap = await createImageBitmap(blob);\n\n    let canvas;\n    if (typeof document !== 'undefined') {\n      canvas = document.createElement('canvas');\n      canvas.width = imageBitmap.width;\n      canvas.height = imageBitmap.height;\n    } else {\n      canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    }\n\n    const ctx = canvas.getContext('2d');\n    ctx.drawImage(imageBitmap, 0, 0);\n\n    // TODO: check how many samples per pixel we have, and return RGB/RGBA accordingly\n    // it seems like GDAL always encodes via RGBA which does not require a translation\n\n    return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi93ZWJpbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLHVEQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGNvbXByZXNzaW9uXFx3ZWJpbWFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZURlY29kZXIgZnJvbSAnLi9iYXNlZGVjb2Rlci5qcyc7XG5cbi8qKlxuICogY2xhc3MgV2ViSW1hZ2VEZWNvZGVyXG4gKlxuICogVGhpcyBkZWNvZGVyIHVzZXMgdGhlIGJyb3dzZXJzIGltYWdlIGRlY29kaW5nIGZhY2lsaXRpZXMgdG8gcmVhZCBpbWFnZVxuICogZm9ybWF0cyBsaWtlIFdlYlAgd2hlbiBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkltYWdlRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIFdlYkltYWdlIGFzIGBjcmVhdGVJbWFnZUJpdG1hcGAgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVjb2RlIFdlYkltYWdlIGFzIG5laXRoZXIgYGRvY3VtZW50YCBub3IgYE9mZnNjcmVlbkNhbnZhc2AgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG5cbiAgICBsZXQgY2FudmFzO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlQml0bWFwLndpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlQml0bWFwLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcblxuICAgIC8vIFRPRE86IGNoZWNrIGhvdyBtYW55IHNhbXBsZXMgcGVyIHBpeGVsIHdlIGhhdmUsIGFuZCByZXR1cm4gUkdCL1JHQkEgYWNjb3JkaW5nbHlcbiAgICAvLyBpdCBzZWVtcyBsaWtlIEdEQUwgYWx3YXlzIGVuY29kZXMgdmlhIFJHQkEgd2hpY2ggZG9lcyBub3QgcmVxdWlyZSBhIHRyYW5zbGF0aW9uXG5cbiAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0KS5kYXRhLmJ1ZmZlcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/compression/webimage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataSlice)\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxkYXRhc2xpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVNsaWNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIsIHNsaWNlT2Zmc2V0LCBsaXR0bGVFbmRpYW4sIGJpZ1RpZmYpIHtcbiAgICB0aGlzLl9kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgdGhpcy5fc2xpY2VPZmZzZXQgPSBzbGljZU9mZnNldDtcbiAgICB0aGlzLl9saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5fYmlnVGlmZiA9IGJpZ1RpZmY7XG4gIH1cblxuICBnZXQgc2xpY2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0O1xuICB9XG5cbiAgZ2V0IHNsaWNlVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGljZU9mZnNldCArIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBnZXQgbGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiB0aGlzLl9saXR0bGVFbmRpYW47XG4gIH1cblxuICBnZXQgYmlnVGlmZigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGNvdmVycyhvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlT2Zmc2V0IDw9IG9mZnNldCAmJiB0aGlzLnNsaWNlVG9wID49IG9mZnNldCArIGxlbmd0aDtcbiAgfVxuXG4gIHJlYWRVaW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50OChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MTYob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkVWludDMyKG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkSW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDMyKFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEZsb2F0MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQ2NChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQ2NChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50NjQob2Zmc2V0KSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCArIDQpO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAodGhpcy5fbGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICByZWFkSW50NjQob2Zmc2V0KSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gKHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyA3IDogMCkpICYgMHg4MClcbiAgICAgID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KFxuICAgICAgICBvZmZzZXQgKyAodGhpcy5fbGl0dGxlRW5kaWFuID8gaSA6IDcgLSBpKSxcbiAgICAgICk7XG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICBpZiAoY2FycnlpbmcpIHtcbiAgICAgICAgICBpZiAoYnl0ZSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgYnl0ZSA9IH4oYnl0ZSAtIDEpICYgMHhmZjtcbiAgICAgICAgICAgIGNhcnJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGUgPSB+Ynl0ZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IGJ5dGUgKiAoMjU2ICoqIGkpO1xuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJlYWRPZmZzZXQob2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuX2JpZ1RpZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50NjQob2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVhZFVpbnQzMihvZmZzZXQpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/dataslice.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataView64)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"(ssr)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWtEOztBQUVuQztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0VBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxkYXRhdmlldzY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFWaWV3NjQge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGdldFVpbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICBnZXRJbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAobGl0dGxlRW5kaWFuID8gNyA6IDApKSAmIDB4ODApID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcy5fZGF0YVZpZXcsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/dataview64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseClient),\n/* harmony export */   BaseDecoder: () => (/* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   BaseResponse: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseResponse),\n/* harmony export */   GeoTIFF: () => (/* binding */ GeoTIFF),\n/* harmony export */   GeoTIFFImage: () => (/* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   MultiGeoTIFF: () => (/* binding */ MultiGeoTIFF),\n/* harmony export */   Pool: () => (/* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   addDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromArrayBuffer: () => (/* binding */ fromArrayBuffer),\n/* harmony export */   fromBlob: () => (/* binding */ fromBlob),\n/* harmony export */   fromCustomClient: () => (/* binding */ fromCustomClient),\n/* harmony export */   fromFile: () => (/* binding */ fromFile),\n/* harmony export */   fromUrl: () => (/* binding */ fromUrl),\n/* harmony export */   fromUrls: () => (/* binding */ fromUrls),\n/* harmony export */   getDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder),\n/* harmony export */   globals: () => (/* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   rgb: () => (/* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   setLogger: () => (/* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger),\n/* harmony export */   writeArrayBuffer: () => (/* binding */ writeArrayBuffer)\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"(ssr)/./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"(ssr)/./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"(ssr)/./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/client/base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"(ssr)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"(ssr)/./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeCustomSource)(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDNkM7QUFDSjtBQUNGO0FBQ1Y7O0FBRTJDO0FBQ2I7QUFDRztBQUNaO0FBQ2lCOztBQUVnQjtBQUNqQztBQUNWO0FBQ1I7QUFDZ0M7QUFDdkI7O0FBRXRCO0FBQ0o7QUFDdUQ7QUFDcEM7QUFDYjs7QUFFckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLGVBQWUsZ0NBQWdDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsY0FBYztBQUNqRCxhQUFhLHlCQUF5QjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCLGNBQWM7QUFDbkQsYUFBYSwyQkFBMkI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQixjQUFjO0FBQ2xFLGFBQWEsMERBQTBEO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1EQUFVLFlBQVksbURBQVUsYUFBYSxtREFBVSxhQUFhLG1EQUFVO0FBQ3ZGO0FBQ0EsU0FBUyxtREFBVSxhQUFhLG1EQUFVO0FBQzFDO0FBQ0EsU0FBUyxtREFBVSxZQUFZLG1EQUFVLGFBQWEsbURBQVUsYUFBYSxtREFBVTtBQUN2RjtBQUNBLFNBQVMsbURBQVUsZ0JBQWdCLG1EQUFVLGlCQUFpQixtREFBVTtBQUN4RSxTQUFTLG1EQUFVLGFBQWEsbURBQVUsY0FBYyxtREFBVTtBQUNsRTtBQUNBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRCxnQkFBZ0Isb0RBQVc7QUFDM0I7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FB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Q1AsNEJBQTRCLDRFQUFvQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsb0RBQW9EO0FBQ3BEO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDTyxnRUFBZ0U7QUFDdkUsNENBQTRDLG1FQUFnQjtBQUM1RDtBQUNBLGlEQUFpRCxtRUFBZ0I7QUFDakU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1AsU0FBUyxnRUFBWTtBQUNyQjs7QUFFZ0I7QUFDUTtBQUNZIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxnZW90aWZmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIGdlb3RpZmYgKi9cbmltcG9ydCBHZW9USUZGSW1hZ2UgZnJvbSAnLi9nZW90aWZmaW1hZ2UuanMnO1xuaW1wb3J0IERhdGFWaWV3NjQgZnJvbSAnLi9kYXRhdmlldzY0LmpzJztcbmltcG9ydCBEYXRhU2xpY2UgZnJvbSAnLi9kYXRhc2xpY2UuanMnO1xuaW1wb3J0IFBvb2wgZnJvbSAnLi9wb29sLmpzJztcblxuaW1wb3J0IHsgbWFrZVJlbW90ZVNvdXJjZSwgbWFrZUN1c3RvbVNvdXJjZSB9IGZyb20gJy4vc291cmNlL3JlbW90ZS5qcyc7XG5pbXBvcnQgeyBtYWtlQnVmZmVyU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvYXJyYXlidWZmZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVSZWFkZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlcmVhZGVyLmpzJztcbmltcG9ydCB7IG1ha2VGaWxlU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvZmlsZS5qcyc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL3NvdXJjZS9jbGllbnQvYmFzZS5qcyc7XG5cbmltcG9ydCB7IGZpZWxkVHlwZXMsIGZpZWxkVGFnTmFtZXMsIGFycmF5RmllbGRzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyB3cml0ZUdlb3RpZmYgfSBmcm9tICcuL2dlb3RpZmZ3cml0ZXIuanMnO1xuaW1wb3J0ICogYXMgZ2xvYmFscyBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0ICogYXMgcmdiIGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIsIGFkZERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHNldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG5cbmV4cG9ydCB7IGdsb2JhbHMgfTtcbmV4cG9ydCB7IHJnYiB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNlRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMnO1xuZXhwb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9O1xuZXhwb3J0IHsgc2V0TG9nZ2VyIH07XG5cbi8qKlxuICogQHR5cGVkZWYge1VpbnQ4QXJyYXkgfCBJbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBGbG9hdDY0QXJyYXl9XG4gKiBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBoZWlnaHQ6bnVtYmVyLCB3aWR0aDogbnVtYmVyIH19IERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXkgJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5ICYgRGltZW5zaW9uc30gVHlwZWRBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiBUaGUgYXV0b2dlbmVyYXRlZCBkb2NzIGFyZSBhIGxpdHRsZSBjb25mdXNpbmcgaGVyZS4gVGhlIGVmZmVjdGl2ZSB0eXBlIGlzOlxuICpcbiAqIGBUeXBlZEFycmF5W10gJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5W10gJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5QXJyYXlXaXRoRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYChUeXBlZEFycmF5IHwgVHlwZWRBcnJheVtdKSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlXaXRoRGltZW5zaW9ucyB8IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zfSBSZWFkUmFzdGVyUmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkge1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgZmllbGRUeXBlcy5CWVRFOiBjYXNlIGZpZWxkVHlwZXMuQVNDSUk6IGNhc2UgZmllbGRUeXBlcy5TQllURTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDogY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HOiBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6IGNhc2UgZmllbGRUeXBlcy5GTE9BVDogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLlNSQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgcmF3R2VvS2V5RGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeS5HZW9LZXlEaXJlY3Rvcnk7XG4gIGlmICghcmF3R2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBnZW9LZXlEaXJlY3RvcnkgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPD0gcmF3R2VvS2V5RGlyZWN0b3J5WzNdICogNDsgaSArPSA0KSB7XG4gICAgY29uc3Qga2V5ID0gZ2VvS2V5TmFtZXNbcmF3R2VvS2V5RGlyZWN0b3J5W2ldXTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IChyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdKVxuICAgICAgPyAoZmllbGRUYWdOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdXSkgOiBudWxsO1xuICAgIGNvbnN0IGNvdW50ID0gcmF3R2VvS2V5RGlyZWN0b3J5W2kgKyAyXTtcbiAgICBjb25zdCBvZmZzZXQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDNdO1xuXG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB2YWx1ZSA9IG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBmaWxlRGlyZWN0b3J5W2xvY2F0aW9uXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCB2YWx1ZSBvZiBnZW9LZXkgJyR7a2V5fScuYCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCAtIDEpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5zdWJhcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdlb0tleURpcmVjdG9yeVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdlb0tleURpcmVjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIGxldCB2YWx1ZXMgPSBudWxsO1xuICBsZXQgcmVhZE1ldGhvZCA9IG51bGw7XG4gIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0JZVEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQxNjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TU0hPUlQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5JRkQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc4OiBjYXNlIGZpZWxkVHlwZXMuSUZEODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6XG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkoY291bnQgKiAyKTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuRkxPQVQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5ET1VCTEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBmaWVsZCB0eXBlOiAke2ZpZWxkVHlwZX1gKTtcbiAgfVxuXG4gIC8vIG5vcm1hbCBmaWVsZHNcbiAgaWYgKCEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIFJBVElPTkFMIG9yIFNSQVRJT05BTFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgdmFsdWVzW2ldID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArIChpICogZmllbGRUeXBlTGVuZ3RoKSxcbiAgICAgICk7XG4gICAgICB2YWx1ZXNbaSArIDFdID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArICgoaSAqIGZpZWxkVHlwZUxlbmd0aCkgKyA0KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5BU0NJSSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JykuZGVjb2RlKHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBEYXRhIGNsYXNzIHRvIHN0b3JlIHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnksIGdlbyBrZXkgZGlyZWN0b3J5IGFuZFxuICogb2Zmc2V0IHRvIHRoZSBuZXh0IElGRFxuICovXG5jbGFzcyBJbWFnZUZpbGVEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlEaXJlY3RvcnksIG5leHRJRkRCeXRlT2Zmc2V0KSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleURpcmVjdG9yeSA9IGdlb0tleURpcmVjdG9yeTtcbiAgICB0aGlzLm5leHRJRkRCeXRlT2Zmc2V0ID0gbmV4dElGREJ5dGVPZmZzZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgY2FzZXMgd2hlbiBhbiBJRkQgaW5kZXggd2FzIHJlcXVlc3RlZCwgdGhhdCBkb2VzIG5vdCBleGlzdFxuICogaW4gdGhlIGZpbGUuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoYE5vIGltYWdlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbmNsYXNzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIChleHBlcmltZW50YWwpIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGJlc3QgZml0dGluZyBpbWFnZS4gVGhpcyBmdW5jdGlvbiB1c2VzXG4gICAqIHRoZSBpbWFnZSB3aXRoIHRoZSBsb3dlc3QgcmVzb2x1dGlvbiB0aGF0IGlzIHN0aWxsIGEgaGlnaGVyIHJlc29sdXRpb24gdGhhbiB0aGVcbiAgICogcmVxdWVzdGVkIHJlc29sdXRpb24uXG4gICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgYGJib3hgIG9wdGlvbiBpcyB0cmFuc2xhdGVkIHRvIHRoZSBgd2luZG93YCBvcHRpb24gYW5kIHRoZVxuICAgKiBgcmVzWGAgYW5kIGByZXNZYCB0byBgd2lkdGhgIGFuZCBgaGVpZ2h0YCByZXNwZWN0aXZlbHkuXG4gICAqIFRoZW4sIHRoZSBbcmVhZFJhc3RlcnNde0BsaW5rIEdlb1RJRkZJbWFnZSNyZWFkUmFzdGVyc30gbWV0aG9kIG9mIHRoZSBzZWxlY3RlZFxuICAgKiBpbWFnZSBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAqIEBzZWUgR2VvVElGRkltYWdlLnJlYWRSYXN0ZXJzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dlb3RpZmZpbWFnZScpLlJlYWRSYXN0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIGRlY29kZWQgYXJyYXkocyksIHdpdGggYGhlaWdodGAgYW5kIGB3aWR0aGAsIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB3aW5kb3c6IGltYWdlV2luZG93LCB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHJlc1gsIHJlc1ksIGJib3ggfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBmaXJzdEltYWdlID0gYXdhaXQgdGhpcy5nZXRJbWFnZSgpO1xuICAgIGxldCB1c2VkSW1hZ2UgPSBmaXJzdEltYWdlO1xuICAgIGNvbnN0IGltYWdlQ291bnQgPSBhd2FpdCB0aGlzLmdldEltYWdlQ291bnQoKTtcbiAgICBjb25zdCBpbWdCQm94ID0gZmlyc3RJbWFnZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKGltYWdlV2luZG93ICYmIGJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBcImJib3hcIiBhbmQgXCJ3aW5kb3dcIiBwYXNzZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2lkdGgvaGVpZ2h0IGlzIHBhc3NlZCwgdHJhbnNmb3JtIGl0IHRvIHJlc29sdXRpb25cbiAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIGltYWdlIHdpbmRvdyAocGl4ZWwgY29vcmRpbmF0ZXMpLCB0cmFuc2Zvcm0gaXQgdG8gYSBCQm94XG4gICAgICAvLyB1c2luZyB0aGUgb3JpZ2luL3Jlc29sdXRpb24gb2YgdGhlIGZpcnN0IGltYWdlLlxuICAgICAgaWYgKGltYWdlV2luZG93KSB7XG4gICAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgICAgY29uc3QgW3JYLCByWV0gPSBmaXJzdEltYWdlLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgICBiYm94ID0gW1xuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzBdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzFdICogclkpLFxuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzJdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzNdICogclkpLFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgYmJveCAob3IgY2FsY3VsYXRlZCBvbmUpXG5cbiAgICAgIGNvbnN0IHVzZWRCQm94ID0gYmJveCB8fCBpbWdCQm94O1xuXG4gICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgaWYgKHJlc1gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggd2lkdGggYW5kIHJlc1ggcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzWCA9ICh1c2VkQkJveFsyXSAtIHVzZWRCQm94WzBdKSAvIHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICBpZiAocmVzWSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNZID0gKHVzZWRCQm94WzNdIC0gdXNlZEJCb3hbMV0pIC8gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHJlc29sdXRpb24gaXMgc2V0IG9yIGNhbGN1bGF0ZWQsIHRyeSB0byBnZXQgdGhlIGltYWdlIHdpdGggdGhlIHdvcnN0IGFjY2VwdGFibGUgcmVzb2x1dGlvblxuICAgIGlmIChyZXNYIHx8IHJlc1kpIHtcbiAgICAgIGNvbnN0IGFsbEltYWdlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZUNvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKGkpO1xuICAgICAgICBjb25zdCB7IFN1YmZpbGVUeXBlOiBzdWJmaWxlVHlwZSwgTmV3U3ViZmlsZVR5cGU6IG5ld1N1YmZpbGVUeXBlIH0gPSBpbWFnZS5maWxlRGlyZWN0b3J5O1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBzdWJmaWxlVHlwZSA9PT0gMiB8fCBuZXdTdWJmaWxlVHlwZSAmIDEpIHtcbiAgICAgICAgICBhbGxJbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxsSW1hZ2VzLnNvcnQoKGEsIGIpID0+IGEuZ2V0V2lkdGgoKSAtIGIuZ2V0V2lkdGgoKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGFsbEltYWdlc1tpXTtcbiAgICAgICAgY29uc3QgaW1nUmVzWCA9IChpbWdCQm94WzJdIC0gaW1nQkJveFswXSkgLyBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCBpbWdSZXNZID0gKGltZ0JCb3hbM10gLSBpbWdCQm94WzFdKSAvIGltYWdlLmdldEhlaWdodCgpO1xuXG4gICAgICAgIHVzZWRJbWFnZSA9IGltYWdlO1xuICAgICAgICBpZiAoKHJlc1ggJiYgcmVzWCA+IGltZ1Jlc1gpIHx8IChyZXNZICYmIHJlc1kgPiBpbWdSZXNZKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHduZCA9IGltYWdlV2luZG93O1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCBbb1gsIG9ZXSA9IGZpcnN0SW1hZ2UuZ2V0T3JpZ2luKCk7XG4gICAgICBjb25zdCBbaW1hZ2VSZXNYLCBpbWFnZVJlc1ldID0gdXNlZEltYWdlLmdldFJlc29sdXRpb24oZmlyc3RJbWFnZSk7XG5cbiAgICAgIHduZCA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFswXSAtIG9YKSAvIGltYWdlUmVzWCksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMV0gLSBvWSkgLyBpbWFnZVJlc1kpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzJdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFszXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICBdO1xuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLm1pbih3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWluKHduZFsxXSwgd25kWzNdKSxcbiAgICAgICAgTWF0aC5tYXgod25kWzBdLCB3bmRbMl0pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMV0sIHduZFszXSksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VkSW1hZ2UucmVhZFJhc3RlcnMoeyAuLi5vcHRpb25zLCB3aW5kb3c6IHduZCB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdlb1RJRkZPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYWNoZT1mYWxzZV0gd2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Rpb24gZm9yIGEgd2hvbGUgR2VvVElGRiBmaWxlLlxuICogQGF1Z21lbnRzIEdlb1RJRkZCYXNlXG4gKi9cbmNsYXNzIEdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGxpdHRsZSBlbmRpYW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmlnVGlmZiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGJpZ1RJRkYgY29udmVudGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdElGRE9mZnNldCBUaGUgbnVtZXJpYyBieXRlLW9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW1hZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBmaXJzdCBJRkQuXG4gICAqIEBwYXJhbSB7R2VvVElGRk9wdGlvbnN9IFtvcHRpb25zXSBmdXJ0aGVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5iaWdUaWZmID0gYmlnVGlmZjtcbiAgICB0aGlzLmZpcnN0SUZET2Zmc2V0ID0gZmlyc3RJRkRPZmZzZXQ7XG4gICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2U7XG4gICAgdGhpcy5pZmRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2xpY2Uob2Zmc2V0LCBzaXplKSB7XG4gICAgY29uc3QgZmFsbGJhY2tTaXplID0gdGhpcy5iaWdUaWZmID8gNDA0OCA6IDEwMjQ7XG4gICAgcmV0dXJuIG5ldyBEYXRhU2xpY2UoXG4gICAgICAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3tcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGg6IHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJyA/IHNpemUgOiBmYWxsYmFja1NpemUsXG4gICAgICB9XSkpWzBdLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5saXR0bGVFbmRpYW4sXG4gICAgICB0aGlzLmJpZ1RpZmYsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdHMgdG8gcGFyc2UgYW4gaW1hZ2UgZmlsZSBkaXJlY3RvcnkgYXQgdGhlIGdpdmVuIGZpbGUgb2Zmc2V0LlxuICAgKiBBcyB0aGVyZSBpcyBubyB3YXkgdG8gZW5zdXJlIHRoYXQgYSBsb2NhdGlvbiBpcyBpbmRlZWQgdGhlIHN0YXJ0IG9mIGFuIElGRCxcbiAgICogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGNhdXRpb24gKGUuZyBvbmx5IHVzaW5nIHRoZSBJRkQgb2Zmc2V0cyBmcm9tXG4gICAqIHRoZSBoZWFkZXJzIG9yIG90aGVyIElGRHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgdG8gcGFyc2UgdGhlIElGRCBhdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbWFnZUZpbGVEaXJlY3Rvcnk+fSB0aGUgcGFyc2VkIElGRFxuICAgKi9cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3J5QXQob2Zmc2V0KSB7XG4gICAgY29uc3QgZW50cnlTaXplID0gdGhpcy5iaWdUaWZmID8gMjAgOiAxMjtcbiAgICBjb25zdCBvZmZzZXRTaXplID0gdGhpcy5iaWdUaWZmID8gOCA6IDI7XG5cbiAgICBsZXQgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IG51bURpckVudHJpZXMgPSB0aGlzLmJpZ1RpZmZcbiAgICAgID8gZGF0YVNsaWNlLnJlYWRVaW50NjQob2Zmc2V0KVxuICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQxNihvZmZzZXQpO1xuXG4gICAgLy8gaWYgdGhlIHNsaWNlIGRvZXMgbm90IGNvdmVyIHRoZSB3aG9sZSBJRkQsIHJlcXVlc3QgYSBiaWdnZXIgc2xpY2UsIHdoZXJlIHRoZVxuICAgIC8vIHdob2xlIElGRCBmaXRzOiBudW0gb2YgZW50cmllcyArIG4geCB0YWcgbGVuZ3RoICsgb2Zmc2V0IHRvIG5leHQgSUZEXG4gICAgY29uc3QgYnl0ZVNpemUgPSAobnVtRGlyRW50cmllcyAqIGVudHJ5U2l6ZSkgKyAodGhpcy5iaWdUaWZmID8gMTYgOiA2KTtcbiAgICBpZiAoIWRhdGFTbGljZS5jb3ZlcnMob2Zmc2V0LCBieXRlU2l6ZSkpIHtcbiAgICAgIGRhdGFTbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBieXRlU2l6ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZURpcmVjdG9yeSA9IHt9O1xuXG4gICAgLy8gbG9vcCBvdmVyIHRoZSBJRkQgYW5kIGNyZWF0ZSBhIGZpbGUgZGlyZWN0b3J5IG9iamVjdFxuICAgIGxldCBpID0gb2Zmc2V0ICsgKHRoaXMuYmlnVGlmZiA/IDggOiAyKTtcbiAgICBmb3IgKGxldCBlbnRyeUNvdW50ID0gMDsgZW50cnlDb3VudCA8IG51bURpckVudHJpZXM7IGkgKz0gZW50cnlTaXplLCArK2VudHJ5Q291bnQpIHtcbiAgICAgIGNvbnN0IGZpZWxkVGFnID0gZGF0YVNsaWNlLnJlYWRVaW50MTYoaSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpICsgMik7XG4gICAgICBjb25zdCB0eXBlQ291bnQgPSB0aGlzLmJpZ1RpZmZcbiAgICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChpICsgNClcbiAgICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQzMihpICsgNCk7XG5cbiAgICAgIGxldCBmaWVsZFZhbHVlcztcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBpICsgKHRoaXMuYmlnVGlmZiA/IDEyIDogOCk7XG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGRpcmVjdGx5IGVuY29kZWQgaW4gdGhlIHRhZyBvciByZWZlcnMgdG8gYVxuICAgICAgLy8gZGlmZmVyZW50IGV4dGVybmFsIGJ5dGUgcmFuZ2VcbiAgICAgIGlmIChmaWVsZFR5cGVMZW5ndGggKiB0eXBlQ291bnQgPD0gKHRoaXMuYmlnVGlmZiA/IDggOiA0KSkge1xuICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCB2YWx1ZU9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNvbHZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBieXRlIHJhbmdlXG4gICAgICAgIGNvbnN0IGFjdHVhbE9mZnNldCA9IGRhdGFTbGljZS5yZWFkT2Zmc2V0KHZhbHVlT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkgKiB0eXBlQ291bnQ7XG5cbiAgICAgICAgLy8gY2hlY2ssIHdoZXRoZXIgd2UgYWN0dWFsbHkgY292ZXIgdGhlIHJlZmVyZW5jZWQgYnl0ZSByYW5nZTsgaWYgbm90LFxuICAgICAgICAvLyByZXF1ZXN0IGEgbmV3IHNsaWNlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBpdFxuICAgICAgICBpZiAoZGF0YVNsaWNlLmNvdmVycyhhY3R1YWxPZmZzZXQsIGxlbmd0aCkpIHtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShhY3R1YWxPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgZmllbGRWYWx1ZXMgPSBnZXRWYWx1ZXMoZmllbGREYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVucGFjayBzaW5nbGUgdmFsdWVzIGZyb20gdGhlIGFycmF5XG4gICAgICBpZiAodHlwZUNvdW50ID09PSAxICYmIGFycmF5RmllbGRzLmluZGV4T2YoZmllbGRUYWcpID09PSAtMVxuICAgICAgICAmJiAhKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5SQVRJT05BTCB8fCBmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuU1JBVElPTkFMKSkge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmaWVsZFZhbHVlcztcbiAgICAgIH1cblxuICAgICAgLy8gd3JpdGUgdGhlIHRhZ3MgdmFsdWUgdG8gdGhlIGZpbGUgZGlyZWN0bHlcbiAgICAgIGZpbGVEaXJlY3RvcnlbZmllbGRUYWdOYW1lc1tmaWVsZFRhZ11dID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpO1xuICAgIGNvbnN0IG5leHRJRkRCeXRlT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQoXG4gICAgICBvZmZzZXQgKyBvZmZzZXRTaXplICsgKGVudHJ5U2l6ZSAqIG51bURpckVudHJpZXMpLFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEltYWdlRmlsZURpcmVjdG9yeShcbiAgICAgIGZpbGVEaXJlY3RvcnksXG4gICAgICBnZW9LZXlEaXJlY3RvcnksXG4gICAgICBuZXh0SUZEQnl0ZU9mZnNldCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdElGRChpbmRleCkge1xuICAgIC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhhdCBJRkQgaW5kZXggcmVxdWVzdGVkLlxuICAgIGlmICh0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSkge1xuICAgICAgLy8gYXR0YWNoIHRvIGFuIGFscmVhZHkgcmVxdWVzdGVkIElGRFxuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kZXggMFxuICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHRoaXMuZmlyc3RJRkRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWZkUmVxdWVzdHNbaW5kZXggLSAxXSkge1xuICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbm90IHlldCBsb2FkZWQsIGxvYWQgdGhhdCBvbmUgZmlyc3RcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHJlY3Vyc2l2ZSBjYWxsLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdID0gdGhpcy5yZXF1ZXN0SUZEKGluZGV4IC0gMSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBvbmUgYWxyZWFkeSB3YXMgYW4gaW5kZXggZXJyb3IsIHJldGhyb3dcbiAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2VvVElGRkltYWdlSW5kZXhFcnJvcihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBhbnl0aGluZyBlbHNlXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBJRkQgd2FzIGxvYWRlZCwgd2UgY2FuIGZpbmFsbHkgZmV0Y2ggdGhlIG9uZSB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhbiBJSUZFLCBvdGhlcndpc2UgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gd291bGQgYmUgZGVsYXllZFxuICAgIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSWZkID0gYXdhaXQgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdO1xuICAgICAgaWYgKHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG4tdGggaW50ZXJuYWwgc3ViZmlsZSBvZiBhbiBpbWFnZS4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIHRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGSW1hZ2U+fSB0aGUgaW1hZ2UgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqL1xuICBhc3luYyBnZXRJbWFnZShpbmRleCA9IDApIHtcbiAgICBjb25zdCBpZmQgPSBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgIHJldHVybiBuZXcgR2VvVElGRkltYWdlKFxuICAgICAgaWZkLmZpbGVEaXJlY3RvcnksIGlmZC5nZW9LZXlEaXJlY3RvcnksXG4gICAgICB0aGlzLmRhdGFWaWV3LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5jYWNoZSwgdGhpcy5zb3VyY2UsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgaW50ZXJuYWwgc3ViZmlsZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHRoZSBudW1iZXIgb2YgaW50ZXJuYWwgc3ViZmlsZSBpbWFnZXNcbiAgICovXG4gIGFzeW5jIGdldEltYWdlQ291bnQoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICAvLyBsb29wIHVudGlsIHdlIHJ1biBvdXQgb2YgSUZEc1xuICAgIGxldCBoYXNOZXh0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoaGFzTmV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0SUZEKGluZGV4KTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHZW9USUZGSW1hZ2VJbmRleEVycm9yKSB7XG4gICAgICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWVzIG9mIHRoZSBDT0cgZ2hvc3QgYXJlYSBhcyBhIHBhcnNlZCBtYXAuXG4gICAqIFNlZSBodHRwczovL2dkYWwub3JnL2RyaXZlcnMvcmFzdGVyL2NvZy5odG1sI2hlYWRlci1naG9zdC1hcmVhIGZvciByZWZlcmVuY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gdGhlIHBhcnNlZCBnaG9zdCBhcmVhIG9yIG51bGwsIGlmIG5vIHN1Y2ggYXJlYSB3YXMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEdob3N0VmFsdWVzKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmlnVGlmZiA/IDE2IDogODtcbiAgICBpZiAodGhpcy5naG9zdFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGRldGVjdGlvblN0cmluZyA9ICdHREFMX1NUUlVDVFVSQUxfTUVUQURBVEFfU0laRT0nO1xuICAgIGNvbnN0IGhldXJpc3RpY0FyZWFTaXplID0gZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCArIDEwMDtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgaGV1cmlzdGljQXJlYVNpemUpO1xuICAgIGlmIChkZXRlY3Rpb25TdHJpbmcgPT09IGdldFZhbHVlcyhzbGljZSwgZmllbGRUeXBlcy5BU0NJSSwgZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCwgb2Zmc2V0KSkge1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBoZXVyaXN0aWNBcmVhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHZhbHVlc1N0cmluZy5zcGxpdCgnXFxuJylbMF07XG4gICAgICBjb25zdCBtZXRhZGF0YVNpemUgPSBOdW1iZXIoZmlyc3RMaW5lLnNwbGl0KCc9JylbMV0uc3BsaXQoJyAnKVswXSkgKyBmaXJzdExpbmUubGVuZ3RoO1xuICAgICAgaWYgKG1ldGFkYXRhU2l6ZSA+IGhldXJpc3RpY0FyZWFTaXplKSB7XG4gICAgICAgIHNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIG1ldGFkYXRhU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBtZXRhZGF0YVNpemUsIG9mZnNldCk7XG4gICAgICB0aGlzLmdob3N0VmFsdWVzID0ge307XG4gICAgICBmdWxsU3RyaW5nXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS5sZW5ndGggPiAwKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnNwbGl0KCc9JykpXG4gICAgICAgIC5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB0aGlzLmdob3N0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdob3N0VmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgKEdlbylUSUZGIGZpbGUgZnJvbSB0aGUgZ2l2ZW4gc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgc291cmNlIG9mIGRhdGEgdG8gcGFyc2UgZnJvbS5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tU291cmNlKHNvdXJjZSwgb3B0aW9ucywgc2lnbmFsKSB7XG4gICAgY29uc3QgaGVhZGVyRGF0YSA9IChhd2FpdCBzb3VyY2UuZmV0Y2goW3sgb2Zmc2V0OiAwLCBsZW5ndGg6IDEwMjQgfV0sIHNpZ25hbCkpWzBdO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3NjQoaGVhZGVyRGF0YSk7XG5cbiAgICBjb25zdCBCT00gPSBkYXRhVmlldy5nZXRVaW50MTYoMCwgMCk7XG4gICAgbGV0IGxpdHRsZUVuZGlhbjtcbiAgICBpZiAoQk9NID09PSAweDQ5NDkpIHtcbiAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChCT00gPT09IDB4NEQ0RCkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYnl0ZSBvcmRlciB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWdpY051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNigyLCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBiaWdUaWZmO1xuICAgIGlmIChtYWdpY051bWJlciA9PT0gNDIpIHtcbiAgICAgIGJpZ1RpZmYgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mykge1xuICAgICAgYmlnVGlmZiA9IHRydWU7XG4gICAgICBjb25zdCBvZmZzZXRCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQxNig0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgaWYgKG9mZnNldEJ5dGVTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb2Zmc2V0IGJ5dGUtc2l6ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWdpYyBudW1iZXIuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBiaWdUaWZmXG4gICAgICA/IGRhdGFWaWV3LmdldFVpbnQ2NCg4LCBsaXR0bGVFbmRpYW4pXG4gICAgICA6IGRhdGFWaWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pO1xuICAgIHJldHVybiBuZXcgR2VvVElGRihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBmaWxlIGJ1ZmZlclxuICAgKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gICAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvVElGRiB9O1xuZXhwb3J0IGRlZmF1bHQgR2VvVElGRjtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBHZW9USUZGIGZpbGVzIHRoYXQgaGF2ZSBleHRlcm5hbCBvdmVydmlld3MuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgTXVsdGlHZW9USUZGIGV4dGVuZHMgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IE11bHRpR2VvVElGRiBmcm9tIGEgbWFpbiBhbmQgc2V2ZXJhbCBvdmVydmlldyBmaWxlcy5cbiAgICogQHBhcmFtIHtHZW9USUZGfSBtYWluRmlsZSBUaGUgbWFpbiBHZW9USUZGIGZpbGUuXG4gICAqIEBwYXJhbSB7R2VvVElGRltdfSBvdmVydmlld0ZpbGVzIEFuIGFycmF5IG9mIG92ZXJ2aWV3IGZpbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFpbkZpbGUgPSBtYWluRmlsZTtcbiAgICB0aGlzLm92ZXJ2aWV3RmlsZXMgPSBvdmVydmlld0ZpbGVzO1xuICAgIHRoaXMuaW1hZ2VGaWxlcyA9IFttYWluRmlsZV0uY29uY2F0KG92ZXJ2aWV3RmlsZXMpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGVQYXJzaW5nID0gbnVsbDtcbiAgICB0aGlzLmltYWdlQ291bnQgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5tYWluRmlsZS5maXJzdElGRE9mZnNldCldXG4gICAgICAuY29uY2F0KHRoaXMub3ZlcnZpZXdGaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQoZmlsZS5maXJzdElGRE9mZnNldCkpKTtcblxuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZSA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGF3YWl0IHRoaXMucGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCk7XG4gICAgbGV0IHZpc2l0ZWQgPSAwO1xuICAgIGxldCByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW1hZ2VGaWxlID0gdGhpcy5pbWFnZUZpbGVzW2ldO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHRoaXMuaW1hZ2VDb3VudHNbaV07IGlpKyspIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2aXNpdGVkKSB7XG4gICAgICAgICAgY29uc3QgaWZkID0gYXdhaXQgaW1hZ2VGaWxlLnJlcXVlc3RJRkQocmVsYXRpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICAgICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgICAgICAgIGltYWdlRmlsZS5kYXRhVmlldywgaW1hZ2VGaWxlLmxpdHRsZUVuZGlhbiwgaW1hZ2VGaWxlLmNhY2hlLCBpbWFnZUZpbGUuc291cmNlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCsrO1xuICAgICAgICByZWxhdGl2ZUluZGV4Kys7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBpbWFnZSBpbmRleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBpZiAodGhpcy5pbWFnZUNvdW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0cyA9IFt0aGlzLm1haW5GaWxlLmdldEltYWdlQ291bnQoKV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5nZXRJbWFnZUNvdW50KCkpKTtcbiAgICB0aGlzLmltYWdlQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IHRoaXMuaW1hZ2VDb3VudHMucmVkdWNlKChjb3VudCwgaWZkcykgPT4gY291bnQgKyBpZmRzLCAwKTtcbiAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICB9XG59XG5cbmV4cG9ydCB7IE11bHRpR2VvVElGRiB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgcmVtb3RlIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBhY2Nlc3MgdGhlIGltYWdlIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybCh1cmwsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgY3VzdG9tIHtAbGluayBCYXNlQ2xpZW50fS5cbiAqIEBwYXJhbSB7QmFzZUNsaWVudH0gY2xpZW50IFRoZSBjbGllbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgbWFrZVJlbW90ZVNvdXJjZX0gZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIEdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21DdXN0b21DbGllbnQoY2xpZW50LCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VDdXN0b21Tb3VyY2UoY2xpZW50LCBvcHRpb25zKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgR2VvVElGRiBmcm9tIGFuXG4gKiBbQXJyYXlCdWZmZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyfS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBkYXRhIHRvIHJlYWQgdGhlIGZpbGUgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYSBsb2NhbCBmaWxlIHBhdGguIFRoaXMgdXNlcyB0aGUgbm9kZVxuICogW2ZpbGVzeXN0ZW0gQVBJXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWx9IGFuZCBpc1xuICogbm90IGF2YWlsYWJsZSBvbiBicm93c2Vycy5cbiAqXG4gKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gKiB0byBiZSBjbG9zZWQgYnV0IG9ubHkgaWYgaXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgZnJvbSBhIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgZmlsZSBwYXRoIHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUZpbGUocGF0aCwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVTb3VyY2UocGF0aCksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgR2VvVElGRiBmcm9tIGFuIEhUTUxcbiAqIFtCbG9iXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYn0gb3JcbiAqIFtGaWxlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZX1cbiAqIG9iamVjdC5cbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBibG9iIFRoZSBCbG9iIG9yIEZpbGUgb2JqZWN0IHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUJsb2IoYmxvYiwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVSZWFkZXJTb3VyY2UoYmxvYiksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgTXVsdGlHZW9USUZGIGZyb20gdGhlIGdpdmVuIFVSTHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFpblVybCBUaGUgVVJMIGZvciB0aGUgbWFpbiBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3ZlcnZpZXdVcmxzIEFuIGFycmF5IG9mIFVSTHMgZm9yIHRoZSBvdmVydmlldyBpbWFnZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBbbWFrZVJlbW90ZVNvdXJjZV17QGxpbmsgbW9kdWxlOnNvdXJjZS5tYWtlUmVtb3RlU291cmNlfVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8TXVsdGlHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBNdWx0aUdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21VcmxzKG1haW5VcmwsIG92ZXJ2aWV3VXJscyA9IFtdLCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICBjb25zdCBtYWluRmlsZSA9IGF3YWl0IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKG1haW5VcmwsIG9wdGlvbnMpLCBzaWduYWwpO1xuICBjb25zdCBvdmVydmlld0ZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgb3ZlcnZpZXdVcmxzLm1hcCgodXJsKSA9PiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpKSksXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBNdWx0aUdlb1RJRkYobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpO1xufVxuXG4vKipcbiAqIE1haW4gY3JlYXRpbmcgZnVuY3Rpb24gZm9yIEdlb1RJRkYgZmlsZXMuXG4gKiBAcGFyYW0geyhBcnJheSl9IGFycmF5IG9mIHBpeGVsIHZhbHVlc1xuICogQHJldHVybnMge21ldGFkYXRhfSBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVBcnJheUJ1ZmZlcih2YWx1ZXMsIG1ldGFkYXRhKSB7XG4gIHJldHVybiB3cml0ZUdlb3RpZmYodmFsdWVzLCBtZXRhZGF0YSk7XG59XG5cbmV4cG9ydCB7IFBvb2wgfTtcbmV4cG9ydCB7IEdlb1RJRkZJbWFnZSB9O1xuZXhwb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiff.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"(ssr)/./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"(ssr)/./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"(ssr)/./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"(ssr)/./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"(ssr)/./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNrRDtBQUNJO0FBQ007O0FBRWtCO0FBQzRCO0FBQ3REO0FBQ1U7O0FBRTlEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGVBQWU7QUFDN0I7QUFDQSxjQUFjLGVBQWU7QUFDN0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWMseUNBQXlDOztBQUV2RDtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0Is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dEM7QUFDQSxlQUFlLHVEQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxnZW90aWZmaW1hZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgZ2VvdGlmZmltYWdlICovXG5pbXBvcnQgeyBnZXRGbG9hdDE2IH0gZnJvbSAnQHBldGFtb3Jpa2VuL2Zsb2F0MTYnO1xuaW1wb3J0IGdldEF0dHJpYnV0ZSBmcm9tICd4bWwtdXRpbHMvZ2V0LWF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgZmluZFRhZ3NCeU5hbWUgZnJvbSAneG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzJztcblxuaW1wb3J0IHsgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMsIEV4dHJhU2FtcGxlc1ZhbHVlcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyBmcm9tV2hpdGVJc1plcm8sIGZyb21CbGFja0lzWmVybywgZnJvbVBhbGV0dGUsIGZyb21DTVlLLCBmcm9tWUNiQ3IsIGZyb21DSUVMYWIgfSBmcm9tICcuL3JnYi5qcyc7XG5pbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXNhbXBsZSwgcmVzYW1wbGVJbnRlcmxlYXZlZCB9IGZyb20gJy4vcmVzYW1wbGUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRSYXN0ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFt3aW5kb3c9d2hvbGUgd2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2Jib3g9d2hvbGUgaW1hZ2VdIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3NhbXBsZXM9YWxsIHNhbXBsZXNdIHRoZSBzZWxlY3Rpb24gb2Ygc2FtcGxlcyB0byByZWFkIGZyb20uIERlZmF1bHQgaXMgYWxsIHNhbXBsZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnRlcmxlYXZlPWZhbHNlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb25lIHNpbmdsZSBhcnJheSBvciBzZXBhcmF0ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gKiBAcHJvcGVydHkge1Bvb2x9IFtwb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVzYW1wbGVNZXRob2Q9J25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gKiBAcHJvcGVydHkge251bWJlcnxudW1iZXJbXX0gW2ZpbGxWYWx1ZV0gVGhlIHZhbHVlIHRvIHVzZSBmb3IgcGFydHMgb2YgdGhlIGltYWdlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRzaWRlIG9mIHRoZSBpbWFnZXMgZXh0ZW50LiBXaGVuIG11bHRpcGxlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVzIGFyZSByZXF1ZXN0ZWQsIGFuIGFycmF5IG9mIGZpbGwgdmFsdWVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW4gYmUgcGFzc2VkLlxuICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXkgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi9nZW90aWZmLmpzXCIpLlJlYWRSYXN0ZXJSZXN1bHR9IFJlYWRSYXN0ZXJSZXN1bHQgKi9cblxuZnVuY3Rpb24gc3VtKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIGxldCBzID0gMDtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBzICs9IGFycmF5W2ldO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKSB7XG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgIGlmIChiaXRzUGVyU2FtcGxlID09PSA4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50OEFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlID09PSAxNikge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDMyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShzaXplKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzogLy8gZmxvYXRpbmcgcG9pbnQgZGF0YVxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoc2l6ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgZm9ybWF0L2JpdHNQZXJTYW1wbGUnKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uKGZvcm1hdCwgYml0c1BlclNhbXBsZSkge1xuICBpZiAoKGZvcm1hdCA9PT0gMSB8fCBmb3JtYXQgPT09IDIpICYmIGJpdHNQZXJTYW1wbGUgPD0gMzIgJiYgYml0c1BlclNhbXBsZSAlIDggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzICYmIChiaXRzUGVyU2FtcGxlID09PSAxNiB8fCBiaXRzUGVyU2FtcGxlID09PSAzMiB8fCBiaXRzUGVyU2FtcGxlID09PSA2NCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KGluQnVmZmVyLCBmb3JtYXQsIHBsYW5hckNvbmZpZ3VyYXRpb24sIHNhbXBsZXNQZXJQaXhlbCwgYml0c1BlclNhbXBsZSwgdGlsZVdpZHRoLCB0aWxlSGVpZ2h0KSB7XG4gIC8vIGNvbnN0IGluQnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaW5CdWZmZXIpO1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluQnVmZmVyKTtcbiAgY29uc3Qgb3V0U2l6ZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDJcbiAgICA/IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGhcbiAgICA6IHRpbGVIZWlnaHQgKiB0aWxlV2lkdGggKiBzYW1wbGVzUGVyUGl4ZWw7XG4gIGNvbnN0IHNhbXBsZXNUb1RyYW5zZmVyID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gMSA6IHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgb3V0QXJyYXkgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBvdXRTaXplKTtcbiAgLy8gbGV0IHBpeGVsID0gMDtcblxuICBjb25zdCBiaXRNYXNrID0gcGFyc2VJbnQoJzEnLnJlcGVhdChiaXRzUGVyU2FtcGxlKSwgMik7XG5cbiAgaWYgKGZvcm1hdCA9PT0gMSkgeyAvLyB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgLy8gdHJhbnNsYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi9tYXN0ZXIvZ2RhbC9mcm10cy9ndGlmZi9nZW90aWZmLmNwcCNMNzMzN1xuICAgIGxldCBwaXhlbEJpdFNraXA7XG4gICAgLy8gbGV0IHNhbXBsZUJpdE9mZnNldCA9IDA7XG4gICAgaWYgKHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IHNhbXBsZXNQZXJQaXhlbCAqIGJpdHNQZXJTYW1wbGU7XG4gICAgICAvLyBzYW1wbGVCaXRPZmZzZXQgPSAoc2FtcGxlc1BlclBpeGVsIC0gMSkgKiBiaXRzUGVyU2FtcGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaXhlbEJpdFNraXAgPSBiaXRzUGVyU2FtcGxlO1xuICAgIH1cblxuICAgIC8vIEJpdHMgcGVyIGxpbmUgcm91bmRzIHVwIHRvIG5leHQgYnl0ZSBib3VuZGFyeS5cbiAgICBsZXQgYml0c1BlckxpbmUgPSB0aWxlV2lkdGggKiBwaXhlbEJpdFNraXA7XG4gICAgaWYgKChiaXRzUGVyTGluZSAmIDcpICE9PSAwKSB7XG4gICAgICBiaXRzUGVyTGluZSA9IChiaXRzUGVyTGluZSArIDcpICYgKH43KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRpbGVIZWlnaHQ7ICsreSkge1xuICAgICAgY29uc3QgbGluZUJpdE9mZnNldCA9IHkgKiBiaXRzUGVyTGluZTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGlsZVdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgcGl4ZWxCaXRPZmZzZXQgPSBsaW5lQml0T2Zmc2V0ICsgKHggKiBzYW1wbGVzVG9UcmFuc2ZlciAqIGJpdHNQZXJTYW1wbGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNUb1RyYW5zZmVyOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBiaXRPZmZzZXQgPSBwaXhlbEJpdE9mZnNldCArIChpICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoKCh5ICogdGlsZVdpZHRoKSArIHgpICogc2FtcGxlc1RvVHJhbnNmZXIpICsgaTtcblxuICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBNYXRoLmZsb29yKGJpdE9mZnNldCAvIDgpO1xuICAgICAgICAgIGNvbnN0IGlubmVyQml0T2Zmc2V0ID0gYml0T2Zmc2V0ICUgODtcbiAgICAgICAgICBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpID4+ICg4IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPj4gKDE2IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5uZXJCaXRPZmZzZXQgKyBiaXRzUGVyU2FtcGxlIDw9IDI0KSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSAodmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCkgPDwgOCkgfCAodmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgMikpO1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHJhdyA+PiAoMjQgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0KSA+PiAoMzIgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbGV0IG91dFdvcmQgPSAwO1xuICAgICAgICAgIC8vIGZvciAobGV0IGJpdCA9IDA7IGJpdCA8IGJpdHNQZXJTYW1wbGU7ICsrYml0KSB7XG4gICAgICAgICAgLy8gICBpZiAoaW5CeXRlQXJyYXlbYml0T2Zmc2V0ID4+IDNdXG4gICAgICAgICAgLy8gICAgICYgKDB4ODAgPj4gKGJpdE9mZnNldCAmIDcpKSkge1xuICAgICAgICAgIC8vICAgICBvdXRXb3JkIHw9ICgxIDw8IChiaXRzUGVyU2FtcGxlIC0gMSAtIGJpdCkpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgKytiaXRPZmZzZXQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gb3V0QXJyYXlbb3V0SW5kZXhdID0gb3V0V29yZDtcbiAgICAgICAgICAvLyBvdXRBcnJheVtwaXhlbF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIHBpeGVsICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYml0T2Zmc2V0ID0gYml0T2Zmc2V0ICsgcGl4ZWxCaXRTa2lwIC0gYml0c1BlclNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7IC8vIGZsb2F0aW5nIHBvaW50XG4gICAgLy8gRmxvYXQxNiBpcyBoYW5kbGVkIGVsc2V3aGVyZVxuICAgIC8vIG5vcm1hbGl6ZSAxNi8yNCBiaXQgZmxvYXRzIHRvIDMyIGJpdCBmbG9hdHMgaW4gdGhlIGFycmF5XG4gICAgLy8gY29uc29sZS50aW1lKCk7XG4gICAgLy8gaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgLy8gICBmb3IgKGxldCBieXRlID0gMCwgb3V0SW5kZXggPSAwOyBieXRlIDwgaW5CdWZmZXIuYnl0ZUxlbmd0aDsgYnl0ZSArPSAyLCArK291dEluZGV4KSB7XG4gICAgLy8gICAgIG91dEFycmF5W291dEluZGV4XSA9IGdldEZsb2F0MTYodmlldywgYnl0ZSk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUudGltZUVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0QXJyYXkuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlb1RJRkYgc3ViLWZpbGUgaW1hZ2UuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbGVEaXJlY3RvcnkgVGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvS2V5cyBUaGUgcGFyc2VkIGdlby1rZXlzXG4gICAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3IFRoZSBEYXRhVmlldyBmb3IgdGhlIHVuZGVybHlpbmcgZmlsZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsaXR0bGVFbmRpYW4gV2hldGhlciB0aGUgZmlsZSBpcyBlbmNvZGVkIGluIGxpdHRsZSBvciBiaWcgZW5kaWFuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FjaGUgV2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vc291cmNlL2Jhc2Vzb3VyY2UnKS5CYXNlU291cmNlfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlzLCBkYXRhVmlldywgbGl0dGxlRW5kaWFuLCBjYWNoZSwgc291cmNlKSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleXMgPSBnZW9LZXlzO1xuICAgIHRoaXMuZGF0YVZpZXcgPSBkYXRhVmlldztcbiAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLnRpbGVzID0gY2FjaGUgPyB7fSA6IG51bGw7XG4gICAgdGhpcy5pc1RpbGVkID0gIWZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzO1xuICAgIGNvbnN0IHBsYW5hckNvbmZpZ3VyYXRpb24gPSBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID0gKHR5cGVvZiBwbGFuYXJDb25maWd1cmF0aW9uID09PSAndW5kZWZpbmVkJykgPyAxIDogcGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAxICYmIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBsYW5hciBjb25maWd1cmF0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc29jaWF0ZWQgcGFyc2VkIGZpbGUgZGlyZWN0b3J5LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGZpbGUgZGlyZWN0b3J5XG4gICAqL1xuICBnZXRGaWxlRGlyZWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3Rvcnk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZ2VvIGtleXMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZ2VvIGtleXNcbiAgICovXG4gIGdldEdlb0tleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRTYW1wbGVzUGVyUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlc1BlclBpeGVsIDogMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3aWR0aCBvZiBlYWNoIHRpbGVcbiAgICovXG4gIGdldFRpbGVXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RpbGVkID8gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IHRoaXMuZ2V0V2lkdGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaGVpZ2h0IG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZUhlaWdodCgpIHtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5maWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwLCB0aGlzLmdldEhlaWdodCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCk7XG4gIH1cblxuICBnZXRCbG9ja1dpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoeSkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQgfHwgKHkgKyAxKSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpIDw9IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCkgLSAoeSAqIHRoaXMuZ2V0VGlsZUhlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGZvciBlYWNoIHBpeGVsIGFjcm9zcyBhbGwgc2FtcGxlcy4gT25seSBmdWxsXG4gICAqIGJ5dGVzIGFyZSBzdXBwb3J0ZWQsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hlbiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGJ5dGVzIHBlciBwaXhlbFxuICAgKi9cbiAgZ2V0Qnl0ZXNQZXJQaXhlbCgpIHtcbiAgICBsZXQgYnl0ZXMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGdldFNhbXBsZUJ5dGVTaXplKGkpIHtcbiAgICBpZiAoaSA+PSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTYW1wbGUgaW5kZXggJHtpfSBpcyBvdXQgb2YgcmFuZ2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbaV0gLyA4KTtcbiAgfVxuXG4gIGdldFJlYWRlckZvclNhbXBsZShzYW1wbGVJbmRleCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtzYW1wbGVJbmRleF07XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgMTogLy8gdW5zaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQ4O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8vIHR3b3MgY29tcGxlbWVudCBzaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICAgIGlmIChiaXRzUGVyU2FtcGxlIDw9IDgpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTY7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZSkge1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRGbG9hdDE2KHRoaXMsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQzMjtcbiAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBmb3JtYXQvYml0c1BlclNhbXBsZScpO1xuICB9XG5cbiAgZ2V0U2FtcGxlRm9ybWF0KHNhbXBsZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRbc2FtcGxlSW5kZXhdIDogMTtcbiAgfVxuXG4gIGdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgfVxuXG4gIGdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZUluZGV4LCBzaXplKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXgpO1xuICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmdldEJpdHNQZXJTYW1wbGUoc2FtcGxlSW5kZXgpO1xuICAgIHJldHVybiBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNvZGVkIHN0cmlwIG9yIHRpbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSBzdHJpcCBvciB0aWxlIHgtb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB0aWxlIHktb2Zmc2V0ICgwIGZvciBzdHJpcHBlZCBpbWFnZXMpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGUgdGhlIHNhbXBsZSB0byBnZXQgZm9yIHNlcGFyYXRlZCBzYW1wbGVzXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x8aW1wb3J0KFwiLi9nZW90aWZmXCIpLkJhc2VEZWNvZGVyfSBwb29sT3JEZWNvZGVyIHRoZSBkZWNvZGVyIG9yIGRlY29kZXIgcG9vbFxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VGlsZU9yU3RyaXAoeCwgeSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpIHtcbiAgICBjb25zdCBudW1UaWxlc1BlclJvdyA9IE1hdGguY2VpbCh0aGlzLmdldFdpZHRoKCkgLyB0aGlzLmdldFRpbGVXaWR0aCgpKTtcbiAgICBjb25zdCBudW1UaWxlc1BlckNvbCA9IE1hdGguY2VpbCh0aGlzLmdldEhlaWdodCgpIC8gdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIGxldCBpbmRleDtcbiAgICBjb25zdCB7IHRpbGVzIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgIGluZGV4ID0gKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH0gZWxzZSBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAyKSB7XG4gICAgICBpbmRleCA9IChzYW1wbGUgKiBudW1UaWxlc1BlclJvdyAqIG51bVRpbGVzUGVyQ29sKSArICh5ICogbnVtVGlsZXNQZXJSb3cpICsgeDtcbiAgICB9XG5cbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBieXRlQ291bnQ7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVPZmZzZXRzW2luZGV4XTtcbiAgICAgIGJ5dGVDb3VudCA9IHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwQnl0ZUNvdW50c1tpbmRleF07XG4gICAgfVxuICAgIGNvbnN0IHNsaWNlID0gKGF3YWl0IHRoaXMuc291cmNlLmZldGNoKFt7IG9mZnNldCwgbGVuZ3RoOiBieXRlQ291bnQgfV0sIHNpZ25hbCkpWzBdO1xuXG4gICAgbGV0IHJlcXVlc3Q7XG4gICAgaWYgKHRpbGVzID09PSBudWxsIHx8ICF0aWxlc1tpbmRleF0pIHtcbiAgICAvLyByZXNvbHZlIGVhY2ggcmVxdWVzdCBieSBwb3RlbnRpYWxseSBhcHBseWluZyBhcnJheSBub3JtYWxpemF0aW9uXG4gICAgICByZXF1ZXN0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCBwb29sT3JEZWNvZGVyLmRlY29kZSh0aGlzLmZpbGVEaXJlY3RvcnksIHNsaWNlKTtcbiAgICAgICAgY29uc3Qgc2FtcGxlRm9ybWF0ID0gdGhpcy5nZXRTYW1wbGVGb3JtYXQoKTtcbiAgICAgICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZSgpO1xuICAgICAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKHNhbXBsZUZvcm1hdCwgYml0c1BlclNhbXBsZSkpIHtcbiAgICAgICAgICBkYXRhID0gbm9ybWFsaXplQXJyYXkoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2FtcGxlRm9ybWF0LFxuICAgICAgICAgICAgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgICAgICAgdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKSxcbiAgICAgICAgICAgIGJpdHNQZXJTYW1wbGUsXG4gICAgICAgICAgICB0aGlzLmdldFRpbGVXaWR0aCgpLFxuICAgICAgICAgICAgdGhpcy5nZXRCbG9ja0hlaWdodCh5KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSkoKTtcblxuICAgICAgLy8gc2V0IHRoZSBjYWNoZVxuICAgICAgaWYgKHRpbGVzICE9PSBudWxsKSB7XG4gICAgICAgIHRpbGVzW2luZGV4XSA9IHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldCBmcm9tIHRoZSBjYWNoZVxuICAgICAgcmVxdWVzdCA9IHRpbGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSB0aGUgdGlsZSByZXF1ZXN0XG4gICAgcmV0dXJuIHsgeCwgeSwgc2FtcGxlLCBkYXRhOiBhd2FpdCByZXF1ZXN0IH07XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVhZCBmdW5jdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VXaW5kb3cgVGhlIGltYWdlIHdpbmRvdyBpbiBwaXhlbCBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIFRoZSBzZWxlY3RlZCBzYW1wbGVzICgwLWJhc2VkIGluZGljZXMpXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheXxUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBhcnJheShzKSB0byB3cml0ZSBpbnRvXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW50ZXJsZWF2ZSBXaGV0aGVyIG9yIG5vdCB0byB3cml0ZSBpbiBhbiBpbnRlcmxlYXZlZCBtYW5uZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxBYnN0cmFjdERlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHQgb2Ygd2luZG93IHRvIGJlIHJlYWQgaW50b1xuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzYW1wbGVNZXRob2QgdGhlIHJlc2FtcGxpbmcgbWV0aG9kIHRvIGJlIHVzZWQgd2hlbiBpbnRlcnBvbGF0aW5nXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fVxuICAgKi9cbiAgYXN5bmMgX3JlYWRSYXN0ZXIoaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCxcbiAgICBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwpIHtcbiAgICBjb25zdCB0aWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCgpO1xuICAgIGNvbnN0IHRpbGVIZWlnaHQgPSB0aGlzLmdldFRpbGVIZWlnaHQoKTtcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgIGNvbnN0IG1pblhUaWxlID0gTWF0aC5tYXgoTWF0aC5mbG9vcihpbWFnZVdpbmRvd1swXSAvIHRpbGVXaWR0aCksIDApO1xuICAgIGNvbnN0IG1heFhUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbMl0gLyB0aWxlV2lkdGgpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2lkdGggLyB0aWxlV2lkdGgpLFxuICAgICk7XG4gICAgY29uc3QgbWluWVRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzFdIC8gdGlsZUhlaWdodCksIDApO1xuICAgIGNvbnN0IG1heFlUaWxlID0gTWF0aC5taW4oXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaW5kb3dbM10gLyB0aWxlSGVpZ2h0KSxcbiAgICAgIE1hdGguY2VpbChpbWFnZUhlaWdodCAvIHRpbGVIZWlnaHQpLFxuICAgICk7XG4gICAgY29uc3Qgd2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuXG4gICAgbGV0IGJ5dGVzUGVyUGl4ZWwgPSB0aGlzLmdldEJ5dGVzUGVyUGl4ZWwoKTtcblxuICAgIGNvbnN0IHNyY1NhbXBsZU9mZnNldHMgPSBbXTtcbiAgICBjb25zdCBzYW1wbGVSZWFkZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaChzdW0odGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUsIDAsIHNhbXBsZXNbaV0pIC8gOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmNTYW1wbGVPZmZzZXRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBzYW1wbGVSZWFkZXJzLnB1c2godGhpcy5nZXRSZWFkZXJGb3JTYW1wbGUoc2FtcGxlc1tpXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgeyBsaXR0bGVFbmRpYW4gfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCB5VGlsZSA9IG1pbllUaWxlOyB5VGlsZSA8IG1heFlUaWxlOyArK3lUaWxlKSB7XG4gICAgICBmb3IgKGxldCB4VGlsZSA9IG1pblhUaWxlOyB4VGlsZSA8IG1heFhUaWxlOyArK3hUaWxlKSB7XG4gICAgICAgIGxldCBnZXRQcm9taXNlO1xuICAgICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICAgICAgZ2V0UHJvbWlzZSA9IHRoaXMuZ2V0VGlsZU9yU3RyaXAoeFRpbGUsIHlUaWxlLCAwLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNhbXBsZUluZGV4ID0gMDsgc2FtcGxlSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgKytzYW1wbGVJbmRleCkge1xuICAgICAgICAgIGNvbnN0IHNpID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgY29uc3Qgc2FtcGxlID0gc2FtcGxlc1tzYW1wbGVJbmRleF07XG4gICAgICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMikge1xuICAgICAgICAgICAgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlQnl0ZVNpemUoc2FtcGxlKTtcbiAgICAgICAgICAgIGdldFByb21pc2UgPSB0aGlzLmdldFRpbGVPclN0cmlwKHhUaWxlLCB5VGlsZSwgc2FtcGxlLCBwb29sT3JEZWNvZGVyLCBzaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gZ2V0UHJvbWlzZS50aGVuKCh0aWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSB0aWxlLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWlnaHQgPSB0aGlzLmdldEJsb2NrSGVpZ2h0KHRpbGUueSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSB0aWxlLnkgKiB0aWxlSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDb2wgPSB0aWxlLnggKiB0aWxlV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBsYXN0TGluZSA9IGZpcnN0TGluZSArIGJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbCA9ICh0aWxlLnggKyAxKSAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHNhbXBsZVJlYWRlcnNbc2ldO1xuXG4gICAgICAgICAgICBjb25zdCB5bWF4ID0gTWF0aC5taW4oYmxvY2tIZWlnaHQsIGJsb2NrSGVpZ2h0IC0gKGxhc3RMaW5lIC0gaW1hZ2VXaW5kb3dbM10pLCBpbWFnZUhlaWdodCAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBjb25zdCB4bWF4ID0gTWF0aC5taW4odGlsZVdpZHRoLCB0aWxlV2lkdGggLSAobGFzdENvbCAtIGltYWdlV2luZG93WzJdKSwgaW1hZ2VXaWR0aCAtIGZpcnN0Q29sKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IE1hdGgubWF4KDAsIGltYWdlV2luZG93WzFdIC0gZmlyc3RMaW5lKTsgeSA8IHltYXg7ICsreSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMF0gLSBmaXJzdENvbCk7IHggPCB4bWF4OyArK3gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbE9mZnNldCA9ICgoeSAqIHRpbGVXaWR0aCkgKyB4KSAqIGJ5dGVzUGVyUGl4ZWw7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWFkZXIuY2FsbChcbiAgICAgICAgICAgICAgICAgIGRhdGFWaWV3LCBwaXhlbE9mZnNldCArIHNyY1NhbXBsZU9mZnNldHNbc2ldLCBsaXR0bGVFbmRpYW4sXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsZXQgd2luZG93Q29vcmRpbmF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9ICgoeSArIGZpcnN0TGluZSAtIGltYWdlV2luZG93WzFdKSAqIHdpbmRvd1dpZHRoICogc2FtcGxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICsgKCh4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXSkgKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyBzaTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0Nvb3JkaW5hdGUgPSAoXG4gICAgICAgICAgICAgICAgICAgICh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGhcbiAgICAgICAgICAgICAgICAgICkgKyB4ICsgZmlyc3RDb2wgLSBpbWFnZVdpbmRvd1swXTtcbiAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXlzW3NpXVt3aW5kb3dDb29yZGluYXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXG4gICAgaWYgKCh3aWR0aCAmJiAoaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSkgIT09IHdpZHRoKVxuICAgICAgICB8fCAoaGVpZ2h0ICYmIChpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdKSAhPT0gaGVpZ2h0KSkge1xuICAgICAgbGV0IHJlc2FtcGxlZDtcbiAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlSW50ZXJsZWF2ZWQoXG4gICAgICAgICAgdmFsdWVBcnJheXMsXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSxcbiAgICAgICAgICBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgc2FtcGxlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNhbXBsZWQgPSByZXNhbXBsZShcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlc2FtcGxlZC53aWR0aCA9IHdpZHRoO1xuICAgICAgcmVzYW1wbGVkLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHJldHVybiByZXNhbXBsZWQ7XG4gICAgfVxuXG4gICAgdmFsdWVBcnJheXMud2lkdGggPSB3aWR0aCB8fCBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIHZhbHVlQXJyYXlzLmhlaWdodCA9IGhlaWdodCB8fCBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuXG4gICAgcmV0dXJuIHZhbHVlQXJyYXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlLiBUaGlzIGZ1bmN0aW9uIHJlYWRzIGFsbCBzZWxlY3RlZCBzYW1wbGVzXG4gICAqIGludG8gc2VwYXJhdGUgYXJyYXlzIG9mIHRoZSBjb3JyZWN0IHR5cGUgZm9yIHRoYXQgc2FtcGxlIG9yIGludG8gYSBzaW5nbGVcbiAgICogY29tYmluZWQgYXJyYXkgd2hlbiBgaW50ZXJsZWF2ZWAgaXMgc2V0LiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0XG4gICAqIG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZFJhc3Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgZGVjb2RlZCBhcnJheXMgYXMgYSBwcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUmFzdGVycyh7XG4gICAgd2luZG93OiB3bmQsIHNhbXBsZXMgPSBbXSwgaW50ZXJsZWF2ZSwgcG9vbCA9IG51bGwsXG4gICAgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIGZpbGxWYWx1ZSwgc2lnbmFsLFxuICB9ID0ge30pIHtcbiAgICBjb25zdCBpbWFnZVdpbmRvdyA9IHduZCB8fCBbMCwgMCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcblxuICAgIC8vIGNoZWNrIHBhcmFtZXRlcnNcbiAgICBpZiAoaW1hZ2VXaW5kb3dbMF0gPiBpbWFnZVdpbmRvd1syXSB8fCBpbWFnZVdpbmRvd1sxXSA+IGltYWdlV2luZG93WzNdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2V0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlV2luZG93V2lkdGggPSBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdO1xuICAgIGNvbnN0IGltYWdlV2luZG93SGVpZ2h0ID0gaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXTtcbiAgICBjb25zdCBudW1QaXhlbHMgPSBpbWFnZVdpbmRvd1dpZHRoICogaW1hZ2VXaW5kb3dIZWlnaHQ7XG4gICAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gdGhpcy5nZXRTYW1wbGVzUGVyUGl4ZWwoKTtcblxuICAgIGlmICghc2FtcGxlcyB8fCAhc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlc1BlclBpeGVsOyArK2kpIHtcbiAgICAgICAgc2FtcGxlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNhbXBsZXNbaV0gPj0gc2FtcGxlc1BlclBpeGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHNhbXBsZSBpbmRleCAnJHtzYW1wbGVzW2ldfScuYCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB2YWx1ZUFycmF5cztcbiAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgICA/IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXQpIDogMTtcbiAgICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSk7XG4gICAgICB2YWx1ZUFycmF5cyA9IGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIG51bVBpeGVscyAqIHNhbXBsZXMubGVuZ3RoKTtcbiAgICAgIGlmIChmaWxsVmFsdWUpIHtcbiAgICAgICAgdmFsdWVBcnJheXMuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZUFycmF5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQXJyYXkgPSB0aGlzLmdldEFycmF5Rm9yU2FtcGxlKHNhbXBsZXNbaV0sIG51bVBpeGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGxWYWx1ZSkgJiYgaSA8IGZpbGxWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWx1ZUFycmF5LmZpbGwoZmlsbFZhbHVlW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsVmFsdWUgJiYgIUFycmF5LmlzQXJyYXkoZmlsbFZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlQXJyYXkuZmlsbChmaWxsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQXJyYXlzLnB1c2godmFsdWVBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbE9yRGVjb2RlciA9IHBvb2wgfHwgYXdhaXQgZ2V0RGVjb2Rlcih0aGlzLmZpbGVEaXJlY3RvcnkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcmVhZFJhc3RlcihcbiAgICAgIGltYWdlV2luZG93LCBzYW1wbGVzLCB2YWx1ZUFycmF5cywgaW50ZXJsZWF2ZSwgcG9vbE9yRGVjb2Rlciwgd2lkdGgsIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIHNpZ25hbCxcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgaW1hZ2UgYXMgUkdCLiBUaGUgcmVzdWx0IGlzIGFsd2F5cyBhblxuICAgKiBpbnRlcmxlYXZlZCB0eXBlZCBhcnJheS5cbiAgICogQ29sb3JzcGFjZXMgb3RoZXIgdGhhbiBSR0Igd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBSR0IsIGNvbG9yIG1hcHMgZXhwYW5kZWQuXG4gICAqIFdoZW4gbm8gb3RoZXIgbWV0aG9kIGlzIGFwcGxpY2FibGUsIHRoZSBmaXJzdCBzYW1wbGUgaXMgdXNlZCB0byBwcm9kdWNlIGFcbiAgICogZ3JheXNjYWxlIGltYWdlLlxuICAgKiBXaGVuIHByb3ZpZGVkLCBvbmx5IGEgc3Vic2V0IG9mIHRoZSByYXN0ZXIgaXMgcmVhZCBmb3IgZWFjaCBzYW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLndpbmRvd10gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW50ZXJsZWF2ZT10cnVlXSB3aGV0aGVyIHRoZSBkYXRhIHNoYWxsIGJlIHJlYWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvbmUgc2luZ2xlIGFycmF5IG9yIHNlcGFyYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfSBbb3B0aW9ucy5wb29sPW51bGxdIFRoZSBvcHRpb25hbCBkZWNvZGVyIHBvb2wgdG8gdXNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5yZXNhbXBsZU1ldGhvZD0nbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZUFscGhhPWZhbHNlXSBFbmFibGUgcmVhZGluZyBhbHBoYSBjaGFubmVsIGlmIHByZXNlbnQuXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtvcHRpb25zLnNpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIFJHQiBhcnJheSBhcyBhIFByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSR0IoeyB3aW5kb3csIGludGVybGVhdmUgPSB0cnVlLCBwb29sID0gbnVsbCwgd2lkdGgsIGhlaWdodCxcbiAgICByZXNhbXBsZU1ldGhvZCwgZW5hYmxlQWxwaGEgPSBmYWxzZSwgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd2luZG93IHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGkgPSB0aGlzLmZpbGVEaXJlY3RvcnkuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbjtcblxuICAgIGlmIChwaSA9PT0gcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUkdCKSB7XG4gICAgICBsZXQgcyA9IFswLCAxLCAyXTtcbiAgICAgIGlmICgoISh0aGlzLmZpbGVEaXJlY3RvcnkuRXh0cmFTYW1wbGVzID09PSBFeHRyYVNhbXBsZXNWYWx1ZXMuVW5zcGVjaWZpZWQpKSAmJiBlbmFibGVBbHBoYSkge1xuICAgICAgICBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlYWRSYXN0ZXJzKHtcbiAgICAgICAgd2luZG93LFxuICAgICAgICBpbnRlcmxlYXZlLFxuICAgICAgICBzYW1wbGVzOiBzLFxuICAgICAgICBwb29sLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHNhbXBsZXM7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlBhbGV0dGU6XG4gICAgICAgIHNhbXBsZXMgPSBbMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDIsIDNdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgc2FtcGxlcyA9IFswLCAxLCAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViT3B0aW9ucyA9IHtcbiAgICAgIHdpbmRvdzogaW1hZ2VXaW5kb3csXG4gICAgICBpbnRlcmxlYXZlOiB0cnVlLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHBvb2wsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgc2lnbmFsLFxuICAgIH07XG4gICAgY29uc3QgeyBmaWxlRGlyZWN0b3J5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHJhc3RlciA9IGF3YWl0IHRoaXMucmVhZFJhc3RlcnMoc3ViT3B0aW9ucyk7XG5cbiAgICBjb25zdCBtYXggPSAyICoqIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdO1xuICAgIGxldCBkYXRhO1xuICAgIHN3aXRjaCAocGkpIHtcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuV2hpdGVJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQmxhY2tJc1plcm86XG4gICAgICAgIGRhdGEgPSBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgZGF0YSA9IGZyb21QYWxldHRlKHJhc3RlciwgZmlsZURpcmVjdG9yeS5Db2xvck1hcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DTVlLOlxuICAgICAgICBkYXRhID0gZnJvbUNNWUsocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLllDYkNyOlxuICAgICAgICBkYXRhID0gZnJvbVlDYkNyKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DSUVMYWI6XG4gICAgICAgIGRhdGEgPSBmcm9tQ0lFTGFiKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBpZiBub24taW50ZXJsZWF2ZWQgZGF0YSBpcyByZXF1ZXN0ZWQsIHdlIG11c3Qgc3BsaXQgdGhlIGNoYW5uZWxzXG4gICAgLy8gaW50byB0aGVpciByZXNwZWN0aXZlIGFycmF5c1xuICAgIGlmICghaW50ZXJsZWF2ZSkge1xuICAgICAgY29uc3QgcmVkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGdyZWVuID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGNvbnN0IGJsdWUgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMywgKytqKSB7XG4gICAgICAgIHJlZFtqXSA9IGRhdGFbaV07XG4gICAgICAgIGdyZWVuW2pdID0gZGF0YVtpICsgMV07XG4gICAgICAgIGJsdWVbal0gPSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBbcmVkLCBncmVlbiwgYmx1ZV07XG4gICAgfVxuXG4gICAgZGF0YS53aWR0aCA9IHJhc3Rlci53aWR0aDtcbiAgICBkYXRhLmhlaWdodCA9IHJhc3Rlci5oZWlnaHQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aWVwb2ludHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAgICovXG4gIGdldFRpZVBvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGllUG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdGllUG9pbnRzLnB1c2goe1xuICAgICAgICBpOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpXSxcbiAgICAgICAgajogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDFdLFxuICAgICAgICBrOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMl0sXG4gICAgICAgIHg6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAzXSxcbiAgICAgICAgeTogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDRdLFxuICAgICAgICB6OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNV0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpZVBvaW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgR0RBTCBtZXRhZGF0YSBpdGVtcy5cbiAgICpcbiAgICogSWYgc2FtcGxlIGlzIHBhc3NlZCB0byBudWxsLCBkYXRhc2V0LWxldmVsIG1ldGFkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIE90aGVyd2lzZSBvbmx5IG1ldGFkYXRhIHNwZWNpZmljIHRvIHRoZSBwcm92aWRlZCBzYW1wbGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGU9bnVsbF0gVGhlIHNhbXBsZSBpbmRleC5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldEdEQUxNZXRhZGF0YShzYW1wbGUgPSBudWxsKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX01FVEFEQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEE7XG5cbiAgICBsZXQgaXRlbXMgPSBmaW5kVGFnc0J5TmFtZShzdHJpbmcsICdJdGVtJyk7XG5cbiAgICBpZiAoc2FtcGxlID09PSBudWxsKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gZ2V0QXR0cmlidXRlKGl0ZW0sICdzYW1wbGUnKSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IE51bWJlcihnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpKSA9PT0gc2FtcGxlKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICBtZXRhZGF0YVtnZXRBdHRyaWJ1dGUoaXRlbSwgJ25hbWUnKV0gPSBpdGVtLmlubmVyO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgR0RBTCBub2RhdGEgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgKi9cbiAgZ2V0R0RBTE5vRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuZmlsZURpcmVjdG9yeS5HREFMX05PREFUQTtcbiAgICByZXR1cm4gTnVtYmVyKHN0cmluZy5zdWJzdHJpbmcoMCwgc3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvcmlnaW4gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgb3JpZ2luIGFzIGEgdmVjdG9yXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgY29uc3QgdGllUG9pbnRzID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQ7XG4gICAgY29uc3QgbW9kZWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuICAgIGlmICh0aWVQb2ludHMgJiYgdGllUG9pbnRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGllUG9pbnRzWzNdLFxuICAgICAgICB0aWVQb2ludHNbNF0sXG4gICAgICAgIHRpZVBvaW50c1s1XSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzNdLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzddLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzExXSxcbiAgICAgIF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIHJlc29sdXRpb24gYXMgYSBYWVotdmVjdG9yLiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lXG4gICAqIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSB7R2VvVElGRkltYWdlfSBbcmVmZXJlbmNlSW1hZ2U9bnVsbF0gQSByZWZlcmVuY2UgaW1hZ2UgdG8gY2FsY3VsYXRlIHRoZSByZXNvbHV0aW9uIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBjYXNlcyB3aGVuIHRoZSBjdXJyZW50IGltYWdlIGRvZXMgbm90IGhhdmUgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQgdGFncyBvbiBpdHMgb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIHJlc29sdXRpb24gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldFJlc29sdXRpb24ocmVmZXJlbmNlSW1hZ2UgPSBudWxsKSB7XG4gICAgY29uc3QgbW9kZWxQaXhlbFNjYWxlID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsUGl4ZWxTY2FsZTtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICBpZiAobW9kZWxQaXhlbFNjYWxlKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBtb2RlbFBpeGVsU2NhbGVbMF0sXG4gICAgICAgIC1tb2RlbFBpeGVsU2NhbGVbMV0sXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVsyXSxcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICBpZiAobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSA9PT0gMCAmJiBtb2RlbFRyYW5zZm9ybWF0aW9uWzRdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblswXSxcbiAgICAgICAgICAtbW9kZWxUcmFuc2Zvcm1hdGlvbls1XSxcbiAgICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblswXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMF0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls0XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNF0pKSxcbiAgICAgICAgLU1hdGguc3FydCgobW9kZWxUcmFuc2Zvcm1hdGlvblsxXSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bMV0pXG4gICAgICAgICAgKyAobW9kZWxUcmFuc2Zvcm1hdGlvbls1XSAqIG1vZGVsVHJhbnNmb3JtYXRpb25bNV0pKSxcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblsxMF1dO1xuICAgIH1cblxuICAgIGlmIChyZWZlcmVuY2VJbWFnZSkge1xuICAgICAgY29uc3QgW3JlZlJlc1gsIHJlZlJlc1ksIHJlZlJlc1pdID0gcmVmZXJlbmNlSW1hZ2UuZ2V0UmVzb2x1dGlvbigpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcmVmUmVzWCAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIHJlZlJlc1kgKiByZWZlcmVuY2VJbWFnZS5nZXRIZWlnaHQoKSAvIHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgIHJlZlJlc1ogKiByZWZlcmVuY2VJbWFnZS5nZXRXaWR0aCgpIC8gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbi4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwaXhlbHMgb2YgdGhlIGltYWdlIGRlcGljdCBhbiBhcmVhIChvciBwb2ludCkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBwaXhlbHMgYXJlIGEgcG9pbnRcbiAgICovXG4gIHBpeGVsSXNBcmVhKCkge1xuICAgIHJldHVybiB0aGlzLmdlb0tleXMuR1RSYXN0ZXJUeXBlR2VvS2V5ID09PSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIGJvdW5kaW5nIGJveCBhcyBhbiBhcnJheSBvZiA0IHZhbHVlczogbWluLXgsIG1pbi15LFxuICAgKiBtYXgteCBhbmQgbWF4LXkuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmUgdHJhbnNmb3JtYXRpb24sIHRoZW4gYW5cbiAgICogZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdGlsZWdyaWQ9ZmFsc2VdIElmIHRydWUgcmV0dXJuIGV4dGVudCBmb3IgYSB0aWxlZ3JpZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCBhZGp1c3RtZW50IGZvciBNb2RlbFRyYW5zZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIGJvdW5kaW5nIGJveFxuICAgKi9cbiAgZ2V0Qm91bmRpbmdCb3godGlsZWdyaWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICBpZiAodGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb24gJiYgIXRpbGVncmlkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoXSA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFswLCBoZWlnaHRdLFxuICAgICAgICBbd2lkdGgsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBwcm9qZWN0ZWQgPSBjb3JuZXJzLm1hcCgoW0ksIEpdKSA9PiBbXG4gICAgICAgIGQgKyAoYSAqIEkpICsgKGIgKiBKKSxcbiAgICAgICAgaCArIChlICogSSkgKyAoZiAqIEopLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHhzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzBdKTtcbiAgICAgIGNvbnN0IHlzID0gcHJvamVjdGVkLm1hcCgocHQpID0+IHB0WzFdKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oLi4ueHMpLFxuICAgICAgICBNYXRoLm1pbiguLi55cyksXG4gICAgICAgIE1hdGgubWF4KC4uLnhzKSxcbiAgICAgICAgTWF0aC5tYXgoLi4ueXMpLFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oKTtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgY29uc3QgeDEgPSBvcmlnaW5bMF07XG4gICAgICBjb25zdCB5MSA9IG9yaWdpblsxXTtcblxuICAgICAgY29uc3QgeDIgPSB4MSArIChyZXNvbHV0aW9uWzBdICogd2lkdGgpO1xuICAgICAgY29uc3QgeTIgPSB5MSArIChyZXNvbHV0aW9uWzFdICogaGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5taW4oeDEsIHgyKSxcbiAgICAgICAgTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgICAgTWF0aC5tYXgoeDEsIHgyKSxcbiAgICAgICAgTWF0aC5tYXgoeTEsIHkyKSxcbiAgICAgIF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdlb1RJRkZJbWFnZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiffimage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   writeGeotiff: () => (/* binding */ writeGeotiff)\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"(ssr)/./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RjtBQUNuQjs7QUFFdEUscUJBQXFCLGlEQUFNLENBQUMsc0RBQWE7QUFDekMsd0JBQXdCLGlEQUFNLENBQUMsb0RBQVc7QUFDMUM7QUFDQSxpREFBTTtBQUNOLGlEQUFNO0FBQ04sc0JBQXNCLGlEQUFNLENBQUMsdURBQWM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUksZ0RBQUs7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLGdEQUFLO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEscUJBQXFCLHNEQUFhO0FBQ2xDOztBQUVBO0FBQ0EsOENBQThDLElBQUk7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QUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGdlb3RpZmZ3cml0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgU29tZSBwYXJ0cyBvZiB0aGlzIGZpbGUgYXJlIGJhc2VkIG9uIFVUSUYuanMsXG4gIHdoaWNoIHdhcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gIFlvdSBjYW4gdmlldyB0aGF0IGhlcmU6XG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VVElGLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG5pbXBvcnQgeyBmaWVsZFRhZ05hbWVzLCBmaWVsZFRhZ1R5cGVzLCBmaWVsZFR5cGVOYW1lcywgZ2VvS2V5TmFtZXMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgYXNzaWduLCBlbmRzV2l0aCwgZm9yRWFjaCwgaW52ZXJ0LCB0aW1lcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCB0YWdOYW1lMkNvZGUgPSBpbnZlcnQoZmllbGRUYWdOYW1lcyk7XG5jb25zdCBnZW9LZXlOYW1lMkNvZGUgPSBpbnZlcnQoZ2VvS2V5TmFtZXMpO1xuY29uc3QgbmFtZTJjb2RlID0ge307XG5hc3NpZ24obmFtZTJjb2RlLCB0YWdOYW1lMkNvZGUpO1xuYXNzaWduKG5hbWUyY29kZSwgZ2VvS2V5TmFtZTJDb2RlKTtcbmNvbnN0IHR5cGVOYW1lMmJ5dGUgPSBpbnZlcnQoZmllbGRUeXBlTmFtZXMpO1xuXG4vLyBjb25maWcgdmFyaWFibGVzXG5jb25zdCBudW1CeXRlc0luSWZkID0gMTAwMDtcblxuY29uc3QgX2JpbkJFID0ge1xuICBuZXh0WmVybzogKGRhdGEsIG8pID0+IHtcbiAgICBsZXQgb2luY3IgPSBvO1xuICAgIHdoaWxlIChkYXRhW29pbmNyXSAhPT0gMCkge1xuICAgICAgb2luY3IrKztcbiAgICB9XG4gICAgcmV0dXJuIG9pbmNyO1xuICB9LFxuICByZWFkVXNob3J0OiAoYnVmZiwgcCkgPT4ge1xuICAgIHJldHVybiAoYnVmZltwXSA8PCA4KSB8IGJ1ZmZbcCArIDFdO1xuICB9LFxuICByZWFkU2hvcnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLmkxNlswXTtcbiAgfSxcbiAgcmVhZEludDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgM107XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDJdO1xuICAgIGFbMl0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzNdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS5pMzJbMF07XG4gIH0sXG4gIHJlYWRVaW50OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAzXTtcbiAgICBhWzFdID0gYnVmZltwICsgMl07XG4gICAgYVsyXSA9IGJ1ZmZbcCArIDFdO1xuICAgIGFbM10gPSBidWZmW3AgKyAwXTtcbiAgICByZXR1cm4gX2JpbkJFLnVpMzJbMF07XG4gIH0sXG4gIHJlYWRBU0NJSTogKGJ1ZmYsIHAsIGwpID0+IHtcbiAgICByZXR1cm4gbC5tYXAoKGkpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwICsgaV0pKS5qb2luKCcnKTtcbiAgfSxcbiAgcmVhZEZsb2F0OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIHRpbWVzKDQsIChpKSA9PiB7XG4gICAgICBhW2ldID0gYnVmZltwICsgMyAtIGldO1xuICAgIH0pO1xuICAgIHJldHVybiBfYmluQkUuZmwzMlswXTtcbiAgfSxcbiAgcmVhZERvdWJsZTogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgICAgYVtpXSA9IGJ1ZmZbcCArIDcgLSBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2JpbkJFLmZsNjRbMF07XG4gIH0sXG4gIHdyaXRlVXNob3J0OiAoYnVmZiwgcCwgbikgPT4ge1xuICAgIGJ1ZmZbcF0gPSAobiA+PiA4KSAmIDI1NTtcbiAgICBidWZmW3AgKyAxXSA9IG4gJiAyNTU7XG4gIH0sXG4gIHdyaXRlVWludDogKGJ1ZmYsIHAsIG4pID0+IHtcbiAgICBidWZmW3BdID0gKG4gPj4gMjQpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gKG4gPj4gMTYpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDJdID0gKG4gPj4gOCkgJiAyNTU7XG4gICAgYnVmZltwICsgM10gPSAobiA+PiAwKSAmIDI1NTtcbiAgfSxcbiAgd3JpdGVBU0NJSTogKGJ1ZmYsIHAsIHMpID0+IHtcbiAgICB0aW1lcyhzLmxlbmd0aCwgKGkpID0+IHtcbiAgICAgIGJ1ZmZbcCArIGldID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIH0pO1xuICB9LFxuICB1aTg6IG5ldyBVaW50OEFycmF5KDgpLFxufTtcblxuX2JpbkJFLmZsNjQgPSBuZXcgRmxvYXQ2NEFycmF5KF9iaW5CRS51aTguYnVmZmVyKTtcblxuX2JpbkJFLndyaXRlRG91YmxlID0gKGJ1ZmYsIHAsIG4pID0+IHtcbiAgX2JpbkJFLmZsNjRbMF0gPSBuO1xuICB0aW1lcyg4LCAoaSkgPT4ge1xuICAgIGJ1ZmZbcCArIGldID0gX2JpbkJFLnVpOFs3IC0gaV07XG4gIH0pO1xufTtcblxuY29uc3QgX3dyaXRlSUZEID0gKGJpbiwgZGF0YSwgX29mZnNldCwgaWZkKSA9PiB7XG4gIGxldCBvZmZzZXQgPSBfb2Zmc2V0O1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpZmQpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgcmV0dXJuIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleSAhPT0gbnVsbCAmJiBrZXkgIT09ICd1bmRlZmluZWQnO1xuICB9KTtcblxuICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCBrZXlzLmxlbmd0aCk7XG4gIG9mZnNldCArPSAyO1xuXG4gIGxldCBlb2ZmID0gb2Zmc2V0ICsgKDEyICoga2V5cy5sZW5ndGgpICsgNDtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgICB0YWcgPSBrZXk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGFnID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZU5hbWUgPSBmaWVsZFRhZ1R5cGVzW3RhZ107XG4gICAgY29uc3QgdHlwZU51bSA9IHR5cGVOYW1lMmJ5dGVbdHlwZU5hbWVdO1xuXG4gICAgaWYgKHR5cGVOYW1lID09IG51bGwgfHwgdHlwZU5hbWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZU5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZSBvZiB0YWc6ICR7dGFnfWApO1xuICAgIH1cblxuICAgIGxldCB2YWwgPSBpZmRba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gZ2V0IHZhbHVlIGZvciBrZXkgJHtrZXl9YCk7XG4gICAgfVxuXG4gICAgLy8gQVNDSUlaIGZvcm1hdCB3aXRoIHRyYWlsaW5nIDAgY2hhcmFjdGVyXG4gICAgLy8gaHR0cDovL3d3dy5maWxlZm9ybWF0LmluZm8vZm9ybWF0L3RpZmYvY29yaW9uLmh0bVxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc3ODMwNDQvd2hhdHMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi1hc2NpaXotdnMtYXNjaWlcbiAgICBpZiAodHlwZU5hbWUgPT09ICdBU0NJSScgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgZW5kc1dpdGgodmFsLCAnXFx1MDAwMCcpID09PSBmYWxzZSkge1xuICAgICAgdmFsICs9ICdcXHUwMDAwJztcbiAgICB9XG5cbiAgICBjb25zdCBudW0gPSB2YWwubGVuZ3RoO1xuXG4gICAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwgdGFnKTtcbiAgICBvZmZzZXQgKz0gMjtcblxuICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHR5cGVOdW0pO1xuICAgIG9mZnNldCArPSAyO1xuXG4gICAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIG51bSk7XG4gICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICBsZXQgZGxlbiA9IFstMSwgMSwgMSwgMiwgNCwgOCwgMCwgMCwgMCwgMCwgMCwgMCwgOF1bdHlwZU51bV0gKiBudW07XG4gICAgbGV0IHRvZmYgPSBvZmZzZXQ7XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBlb2ZmKTtcbiAgICAgIHRvZmYgPSBlb2ZmO1xuICAgIH1cblxuICAgIGlmICh0eXBlTmFtZSA9PT0gJ0FTQ0lJJykge1xuICAgICAgYmluLndyaXRlQVNDSUkoZGF0YSwgdG9mZiwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnU0hPUlQnKSB7XG4gICAgICB0aW1lcyhudW0sIChpKSA9PiB7XG4gICAgICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCB0b2ZmICsgKDIgKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdMT05HJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoNCAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ1JBVElPTkFMJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoOCAqIGkpLCBNYXRoLnJvdW5kKHZhbFtpXSAqIDEwMDAwKSk7XG4gICAgICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgdG9mZiArICg4ICogaSkgKyA0LCAxMDAwMCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnRE9VQkxFJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVEb3VibGUoZGF0YSwgdG9mZiArICg4ICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZGxlbiA+IDQpIHtcbiAgICAgIGRsZW4gKz0gKGRsZW4gJiAxKTtcbiAgICAgIGVvZmYgKz0gZGxlbjtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIHJldHVybiBbb2Zmc2V0LCBlb2ZmXTtcbn07XG5cbmNvbnN0IGVuY29kZUlmZHMgPSAoaWZkcykgPT4ge1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXNJbklmZCk7XG4gIGxldCBvZmZzZXQgPSA0O1xuICBjb25zdCBiaW4gPSBfYmluQkU7XG5cbiAgLy8gc2V0IGJpZy1lbmRpYW4gYnl0ZS1vcmRlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVswXSA9IDc3O1xuICBkYXRhWzFdID0gNzc7XG5cbiAgLy8gc2V0IGZvcm1hdC12ZXJzaW9uIG51bWJlclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9USUZGI0J5dGVfb3JkZXJcbiAgZGF0YVszXSA9IDQyO1xuXG4gIGxldCBpZmRvID0gODtcblxuICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgaWZkbyk7XG5cbiAgb2Zmc2V0ICs9IDQ7XG5cbiAgaWZkcy5mb3JFYWNoKChpZmQsIGkpID0+IHtcbiAgICBjb25zdCBub2ZmcyA9IF93cml0ZUlGRChiaW4sIGRhdGEsIGlmZG8sIGlmZCk7XG4gICAgaWZkbyA9IG5vZmZzWzFdO1xuICAgIGlmIChpIDwgaWZkcy5sZW5ndGggLSAxKSB7XG4gICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG5vZmZzWzBdLCBpZmRvKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkYXRhLnNsaWNlKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgaWZkbykuYnVmZmVyO1xuICB9XG5cbiAgLy8gbm9kZSBoYXNuJ3QgaW1wbGVtZW50ZWQgc2xpY2Ugb24gVWludDhBcnJheSB5ZXRcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaWZkbyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWZkbzsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gZGF0YVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG5cbmNvbnN0IGVuY29kZUltYWdlID0gKHZhbHVlcywgd2lkdGgsIGhlaWdodCwgbWV0YWRhdGEpID0+IHtcbiAgaWYgKGhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeW91IHBhc3NlZCBpbnRvIGVuY29kZUltYWdlIGEgd2lkdGggb2YgdHlwZSAke2hlaWdodH1gKTtcbiAgfVxuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHdpZHRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB5b3UgcGFzc2VkIGludG8gZW5jb2RlSW1hZ2UgYSB3aWR0aCBvZiB0eXBlICR7d2lkdGh9YCk7XG4gIH1cblxuICBjb25zdCBpZmQgPSB7XG4gICAgMjU2OiBbd2lkdGhdLCAvLyBJbWFnZVdpZHRoXG4gICAgMjU3OiBbaGVpZ2h0XSwgLy8gSW1hZ2VMZW5ndGhcbiAgICAyNzM6IFtudW1CeXRlc0luSWZkXSwgLy8gc3RyaXBzIG9mZnNldFxuICAgIDI3ODogW2hlaWdodF0sIC8vIFJvd3NQZXJTdHJpcFxuICAgIDMwNTogJ2dlb3RpZmYuanMnLCAvLyBubyBhcnJheSBmb3IgQVNDSUkoWilcbiAgfTtcblxuICBpZiAobWV0YWRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gbWV0YWRhdGEpIHtcbiAgICAgIGlmIChtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBpZmRbaV0gPSBtZXRhZGF0YVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwcmZ4ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlSWZkcyhbaWZkXSkpO1xuXG4gIGNvbnN0IGltZyA9IG5ldyBVaW50OEFycmF5KHZhbHVlcyk7XG5cbiAgY29uc3Qgc2FtcGxlc1BlclBpeGVsID0gaWZkWzI3N107XG5cbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzSW5JZmQgKyAod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpKTtcbiAgdGltZXMocHJmeC5sZW5ndGgsIChpKSA9PiB7XG4gICAgZGF0YVtpXSA9IHByZnhbaV07XG4gIH0pO1xuICBmb3JFYWNoKGltZywgKHZhbHVlLCBpKSA9PiB7XG4gICAgZGF0YVtudW1CeXRlc0luSWZkICsgaV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGEuYnVmZmVyO1xufTtcblxuY29uc3QgY29udmVydFRvVGlkcyA9IChpbnB1dCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICBpZiAoa2V5ICE9PSAnU3RyaXBPZmZzZXRzJykge1xuICAgICAgaWYgKCFuYW1lMmNvZGVba2V5XSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGtleSwgJ25vdCBpbiBuYW1lMmNvZGU6JywgT2JqZWN0LmtleXMobmFtZTJjb2RlKSk7XG4gICAgICB9XG4gICAgICByZXN1bHRbbmFtZTJjb2RlW2tleV1dID0gaW5wdXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvQXJyYXkgPSAoaW5wdXQpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBbaW5wdXRdO1xufTtcblxuY29uc3QgbWV0YWRhdGFEZWZhdWx0cyA9IFtcbiAgWydDb21wcmVzc2lvbicsIDFdLCAvLyBubyBjb21wcmVzc2lvblxuICBbJ1BsYW5hckNvbmZpZ3VyYXRpb24nLCAxXSxcbiAgWydFeHRyYVNhbXBsZXMnLCAwXSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUdlb3RpZmYoZGF0YSwgbWV0YWRhdGEpIHtcbiAgY29uc3QgaXNGbGF0dGVuZWQgPSB0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcic7XG5cbiAgbGV0IGhlaWdodDtcbiAgbGV0IG51bUJhbmRzO1xuICBsZXQgd2lkdGg7XG4gIGxldCBmbGF0dGVuZWRWYWx1ZXM7XG5cbiAgaWYgKGlzRmxhdHRlbmVkKSB7XG4gICAgaGVpZ2h0ID0gbWV0YWRhdGEuaGVpZ2h0IHx8IG1ldGFkYXRhLkltYWdlTGVuZ3RoO1xuICAgIHdpZHRoID0gbWV0YWRhdGEud2lkdGggfHwgbWV0YWRhdGEuSW1hZ2VXaWR0aDtcbiAgICBudW1CYW5kcyA9IGRhdGEubGVuZ3RoIC8gKGhlaWdodCAqIHdpZHRoKTtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIG51bUJhbmRzID0gZGF0YS5sZW5ndGg7XG4gICAgaGVpZ2h0ID0gZGF0YVswXS5sZW5ndGg7XG4gICAgd2lkdGggPSBkYXRhWzBdWzBdLmxlbmd0aDtcbiAgICBmbGF0dGVuZWRWYWx1ZXMgPSBbXTtcbiAgICB0aW1lcyhoZWlnaHQsIChyb3dJbmRleCkgPT4ge1xuICAgICAgdGltZXMod2lkdGgsIChjb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICB0aW1lcyhudW1CYW5kcywgKGJhbmRJbmRleCkgPT4ge1xuICAgICAgICAgIGZsYXR0ZW5lZFZhbHVlcy5wdXNoKGRhdGFbYmFuZEluZGV4XVtyb3dJbmRleF1bY29sdW1uSW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG1ldGFkYXRhLkltYWdlTGVuZ3RoID0gaGVpZ2h0O1xuICBkZWxldGUgbWV0YWRhdGEuaGVpZ2h0O1xuICBtZXRhZGF0YS5JbWFnZVdpZHRoID0gd2lkdGg7XG4gIGRlbGV0ZSBtZXRhZGF0YS53aWR0aDtcblxuICAvLyBjb25zdWx0IGh0dHBzOi8vd3d3LmxvYy5nb3YvcHJlc2VydmF0aW9uL2RpZ2l0YWwvZm9ybWF0cy9jb250ZW50L3RpZmZfdGFncy5zaHRtbFxuXG4gIGlmICghbWV0YWRhdGEuQml0c1BlclNhbXBsZSkge1xuICAgIG1ldGFkYXRhLkJpdHNQZXJTYW1wbGUgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gOCk7XG4gIH1cblxuICBtZXRhZGF0YURlZmF1bHRzLmZvckVhY2goKHRhZykgPT4ge1xuICAgIGNvbnN0IGtleSA9IHRhZ1swXTtcbiAgICBpZiAoIW1ldGFkYXRhW2tleV0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGFnWzFdO1xuICAgICAgbWV0YWRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlIGNvbG9yIHNwYWNlIG9mIHRoZSBpbWFnZSBkYXRhLlxuICAvLyAxPWJsYWNrIGlzIHplcm8gYW5kIDI9UkdCLlxuICBpZiAoIW1ldGFkYXRhLlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24pIHtcbiAgICBtZXRhZGF0YS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uID0gbWV0YWRhdGEuQml0c1BlclNhbXBsZS5sZW5ndGggPT09IDMgPyAyIDogMTtcbiAgfVxuXG4gIC8vIFRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBwZXIgcGl4ZWwuXG4gIGlmICghbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsKSB7XG4gICAgbWV0YWRhdGEuU2FtcGxlc1BlclBpeGVsID0gW251bUJhbmRzXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuU3RyaXBCeXRlQ291bnRzKSB7XG4gICAgLy8gd2UgYXJlIG9ubHkgd3JpdGluZyBvbmUgc3RyaXBcbiAgICBtZXRhZGF0YS5TdHJpcEJ5dGVDb3VudHMgPSBbbnVtQmFuZHMgKiBoZWlnaHQgKiB3aWR0aF07XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLk1vZGVsUGl4ZWxTY2FsZSkge1xuICAgIC8vIGFzc3VtZXMgcmFzdGVyIHRha2VzIHVwIGV4YWN0bHkgdGhlIHdob2xlIGdsb2JlXG4gICAgbWV0YWRhdGEuTW9kZWxQaXhlbFNjYWxlID0gWzM2MCAvIHdpZHRoLCAxODAgLyBoZWlnaHQsIDBdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5TYW1wbGVGb3JtYXQpIHtcbiAgICBtZXRhZGF0YS5TYW1wbGVGb3JtYXQgPSB0aW1lcyhudW1CYW5kcywgKCkgPT4gMSk7XG4gIH1cblxuICAvLyBpZiBkaWRuJ3QgcGFzcyBpbiBwcm9qZWN0aW9uIGluZm9ybWF0aW9uLCBhc3N1bWUgdGhlIHBvcHVsYXIgNDMyNiBcImdlb2dyYXBoaWMgcHJvamVjdGlvblwiXG4gIGlmICghbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JykgJiYgIW1ldGFkYXRhLmhhc093blByb3BlcnR5KCdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknKSkge1xuICAgIG1ldGFkYXRhLkdlb2dyYXBoaWNUeXBlR2VvS2V5ID0gNDMyNjtcbiAgICBtZXRhZGF0YS5Nb2RlbFRpZXBvaW50ID0gWzAsIDAsIDAsIC0xODAsIDkwLCAwXTsgLy8gcmFzdGVyIGZpdHMgd2hvbGUgZ2xvYmVcbiAgICBtZXRhZGF0YS5HZW9nQ2l0YXRpb25HZW9LZXkgPSAnV0dTIDg0JztcbiAgICBtZXRhZGF0YS5HVE1vZGVsVHlwZUdlb0tleSA9IDI7XG4gIH1cblxuICBjb25zdCBnZW9LZXlzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpXG4gICAgLmZpbHRlcigoa2V5KSA9PiBlbmRzV2l0aChrZXksICdHZW9LZXknKSlcbiAgICAuc29ydCgoYSwgYikgPT4gbmFtZTJjb2RlW2FdIC0gbmFtZTJjb2RlW2JdKTtcblxuICBpZiAoIW1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zKSB7XG4gICAgbGV0IGdlb0FzY2lpUGFyYW1zID0gJyc7XG4gICAgZ2VvS2V5cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gTnVtYmVyKG5hbWUyY29kZVtuYW1lXSk7XG4gICAgICBjb25zdCB0YWdUeXBlID0gZmllbGRUYWdUeXBlc1tjb2RlXTtcbiAgICAgIGlmICh0YWdUeXBlID09PSAnQVNDSUknKSB7XG4gICAgICAgIGdlb0FzY2lpUGFyYW1zICs9IGAke21ldGFkYXRhW25hbWVdLnRvU3RyaW5nKCl9XFx1MDAwMGA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGdlb0FzY2lpUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1ldGFkYXRhLkdlb0FzY2lpUGFyYW1zID0gZ2VvQXNjaWlQYXJhbXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkpIHtcbiAgICBjb25zdCBOdW1iZXJPZktleXMgPSBnZW9LZXlzLmxlbmd0aDtcblxuICAgIGNvbnN0IEdlb0tleURpcmVjdG9yeSA9IFsxLCAxLCAwLCBOdW1iZXJPZktleXNdO1xuICAgIGdlb0tleXMuZm9yRWFjaCgoZ2VvS2V5KSA9PiB7XG4gICAgICBjb25zdCBLZXlJRCA9IE51bWJlcihuYW1lMmNvZGVbZ2VvS2V5XSk7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChLZXlJRCk7XG5cbiAgICAgIGxldCBDb3VudDtcbiAgICAgIGxldCBUSUZGVGFnTG9jYXRpb247XG4gICAgICBsZXQgdmFsdWVPZmZzZXQ7XG4gICAgICBpZiAoZmllbGRUYWdUeXBlc1tLZXlJRF0gPT09ICdTSE9SVCcpIHtcbiAgICAgICAgQ291bnQgPSAxO1xuICAgICAgICBUSUZGVGFnTG9jYXRpb24gPSAwO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IG1ldGFkYXRhW2dlb0tleV07XG4gICAgICB9IGVsc2UgaWYgKGdlb0tleSA9PT0gJ0dlb2dDaXRhdGlvbkdlb0tleScpIHtcbiAgICAgICAgQ291bnQgPSBtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcy5sZW5ndGg7XG4gICAgICAgIFRJRkZUYWdMb2NhdGlvbiA9IE51bWJlcihuYW1lMmNvZGUuR2VvQXNjaWlQYXJhbXMpO1xuICAgICAgICB2YWx1ZU9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgW2dlb3RpZmYuanNdIGNvdWxkbid0IGdldCBUSUZGVGFnTG9jYXRpb24gZm9yICR7Z2VvS2V5fWApO1xuICAgICAgfVxuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goVElGRlRhZ0xvY2F0aW9uKTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKENvdW50KTtcbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKHZhbHVlT2Zmc2V0KTtcbiAgICB9KTtcbiAgICBtZXRhZGF0YS5HZW9LZXlEaXJlY3RvcnkgPSBHZW9LZXlEaXJlY3Rvcnk7XG4gIH1cblxuICAvLyBkZWxldGUgR2VvS2V5cyBmcm9tIG1ldGFkYXRhLCBiZWNhdXNlIHN0b3JlZCBpbiBHZW9LZXlEaXJlY3RvcnkgdGFnXG4gIGZvciAoY29uc3QgZ2VvS2V5IG9mIGdlb0tleXMpIHtcbiAgICBpZiAobWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZ2VvS2V5KSkge1xuICAgICAgZGVsZXRlIG1ldGFkYXRhW2dlb0tleV07XG4gICAgfVxuICB9XG5cbiAgW1xuICAgICdDb21wcmVzc2lvbicsXG4gICAgJ0V4dHJhU2FtcGxlcycsXG4gICAgJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgICAnR1RNb2RlbFR5cGVHZW9LZXknLFxuICAgICdHVFJhc3RlclR5cGVHZW9LZXknLFxuICAgICdJbWFnZUxlbmd0aCcsIC8vIHN5bm9ueW0gb2YgSW1hZ2VIZWlnaHRcbiAgICAnSW1hZ2VXaWR0aCcsXG4gICAgJ09yaWVudGF0aW9uJyxcbiAgICAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gICAgJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gICAgJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAgICdSZXNvbHV0aW9uVW5pdCcsXG4gICAgJ1NhbXBsZXNQZXJQaXhlbCcsXG4gICAgJ1hQb3NpdGlvbicsXG4gICAgJ1lQb3NpdGlvbicsXG4gICAgJ1Jvd3NQZXJTdHJpcCcsXG4gIF0uZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmIChtZXRhZGF0YVtuYW1lXSkge1xuICAgICAgbWV0YWRhdGFbbmFtZV0gPSB0b0FycmF5KG1ldGFkYXRhW25hbWVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGVuY29kZWRNZXRhZGF0YSA9IGNvbnZlcnRUb1RpZHMobWV0YWRhdGEpO1xuXG4gIGNvbnN0IG91dHB1dEltYWdlID0gZW5jb2RlSW1hZ2UoZmxhdHRlbmVkVmFsdWVzLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVkTWV0YWRhdGEpO1xuXG4gIHJldHVybiBvdXRwdXRJbWFnZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/geotiffwriter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtraSamplesValues: () => (/* binding */ ExtraSamplesValues),\n/* harmony export */   LercAddCompression: () => (/* binding */ LercAddCompression),\n/* harmony export */   LercParameters: () => (/* binding */ LercParameters),\n/* harmony export */   arrayFields: () => (/* binding */ arrayFields),\n/* harmony export */   fieldTagNames: () => (/* binding */ fieldTagNames),\n/* harmony export */   fieldTagTypes: () => (/* binding */ fieldTagTypes),\n/* harmony export */   fieldTags: () => (/* binding */ fieldTags),\n/* harmony export */   fieldTypeNames: () => (/* binding */ fieldTypeNames),\n/* harmony export */   fieldTypes: () => (/* binding */ fieldTypes),\n/* harmony export */   geoKeyNames: () => (/* binding */ geoKeyNames),\n/* harmony export */   geoKeys: () => (/* binding */ geoKeys),\n/* harmony export */   photometricInterpretations: () => (/* binding */ photometricInterpretations)\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXGdsb2JhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGZpZWxkVGFnTmFtZXMgPSB7XG4gIC8vIFRJRkYgQmFzZWxpbmVcbiAgMHgwMTNCOiAnQXJ0aXN0JyxcbiAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gIDB4MDEwOTogJ0NlbGxMZW5ndGgnLFxuICAweDAxMDg6ICdDZWxsV2lkdGgnLFxuICAweDAxNDA6ICdDb2xvck1hcCcsXG4gIDB4MDEwMzogJ0NvbXByZXNzaW9uJyxcbiAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxNTI6ICdFeHRyYVNhbXBsZXMnLFxuICAweDAxMEE6ICdGaWxsT3JkZXInLFxuICAweDAxMjE6ICdGcmVlQnl0ZUNvdW50cycsXG4gIDB4MDEyMDogJ0ZyZWVPZmZzZXRzJyxcbiAgMHgwMTIzOiAnR3JheVJlc3BvbnNlQ3VydmUnLFxuICAweDAxMjI6ICdHcmF5UmVzcG9uc2VVbml0JyxcbiAgMHgwMTNDOiAnSG9zdENvbXB1dGVyJyxcbiAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gIDB4MDEwMTogJ0ltYWdlTGVuZ3RoJyxcbiAgMHgwMTAwOiAnSW1hZ2VXaWR0aCcsXG4gIDB4MDEwRjogJ01ha2UnLFxuICAweDAxMTk6ICdNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDExODogJ01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTEwOiAnTW9kZWwnLFxuICAweDAwRkU6ICdOZXdTdWJmaWxlVHlwZScsXG4gIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMEZGOiAnU3ViZmlsZVR5cGUnLFxuICAweDAxMDc6ICdUaHJlc2hob2xkaW5nJyxcbiAgMHgwMTFBOiAnWFJlc29sdXRpb24nLFxuICAweDAxMUI6ICdZUmVzb2x1dGlvbicsXG5cbiAgLy8gVElGRiBFeHRlbmRlZFxuICAweDAxNDY6ICdCYWRGYXhMaW5lcycsXG4gIDB4MDE0NzogJ0NsZWFuRmF4RGF0YScsXG4gIDB4MDE1NzogJ0NsaXBQYXRoJyxcbiAgMHgwMTQ4OiAnQ29uc2VjdXRpdmVCYWRGYXhMaW5lcycsXG4gIDB4MDFCMTogJ0RlY29kZScsXG4gIDB4MDFCMjogJ0RlZmF1bHRJbWFnZUNvbG9yJyxcbiAgMHgwMTBEOiAnRG9jdW1lbnROYW1lJyxcbiAgMHgwMTUwOiAnRG90UmFuZ2UnLFxuICAweDAxNDE6ICdIYWxmdG9uZUhpbnRzJyxcbiAgMHgwMTVBOiAnSW5kZXhlZCcsXG4gIDB4MDE1QjogJ0pQRUdUYWJsZXMnLFxuICAweDAxMUQ6ICdQYWdlTmFtZScsXG4gIDB4MDEyOTogJ1BhZ2VOdW1iZXInLFxuICAweDAxM0Q6ICdQcmVkaWN0b3InLFxuICAweDAxM0Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTUzOiAnU2FtcGxlRm9ybWF0JyxcbiAgMHgwMTU0OiAnU01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTU1OiAnU01heFNhbXBsZVZhbHVlJyxcbiAgMHgwMjJGOiAnU3RyaXBSb3dDb3VudHMnLFxuICAweDAxNEE6ICdTdWJJRkRzJyxcbiAgMHgwMTI0OiAnVDRPcHRpb25zJyxcbiAgMHgwMTI1OiAnVDZPcHRpb25zJyxcbiAgMHgwMTQ1OiAnVGlsZUJ5dGVDb3VudHMnLFxuICAweDAxNDM6ICdUaWxlTGVuZ3RoJyxcbiAgMHgwMTQ0OiAnVGlsZU9mZnNldHMnLFxuICAweDAxNDI6ICdUaWxlV2lkdGgnLFxuICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgMHgwMTNFOiAnV2hpdGVQb2ludCcsXG4gIDB4MDE1ODogJ1hDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFFOiAnWFBvc2l0aW9uJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTM6ICdZQ2JDclBvc2l0aW9uaW5nJyxcbiAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gIDB4MDE1OTogJ1lDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFGOiAnWVBvc2l0aW9uJyxcblxuICAvLyBFWElGXG4gIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLFxuICAweEEwMDE6ICdDb2xvclNwYWNlJyxcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLFxuICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcbiAgMHg4NzY5OiAnRXhpZiBJRkQnLFxuICAweDkwMDA6ICdFeGlmVmVyc2lvbicsXG4gIDB4ODI5QTogJ0V4cG9zdXJlVGltZScsXG4gIDB4QTMwMDogJ0ZpbGVTb3VyY2UnLFxuICAweDkyMDk6ICdGbGFzaCcsXG4gIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsXG4gIDB4ODI5RDogJ0ZOdW1iZXInLFxuICAweEE0MjA6ICdJbWFnZVVuaXF1ZUlEJyxcbiAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLFxuICAweDkyN0M6ICdNYWtlck5vdGUnLFxuICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsXG4gIDB4OTI4NjogJ1VzZXJDb21tZW50JyxcblxuICAvLyBJUFRDXG4gIDB4ODNCQjogJ0lQVEMnLFxuXG4gIC8vIElDQ1xuICAweDg3NzM6ICdJQ0MgUHJvZmlsZScsXG5cbiAgLy8gWE1QXG4gIDB4MDJCQzogJ1hNUCcsXG5cbiAgLy8gR0RBTFxuICAweEE0ODA6ICdHREFMX01FVEFEQVRBJyxcbiAgMHhBNDgxOiAnR0RBTF9OT0RBVEEnLFxuXG4gIC8vIFBob3Rvc2hvcFxuICAweDg2NDk6ICdQaG90b3Nob3AnLFxuXG4gIC8vIEdlb1RpZmZcbiAgMHg4MzBFOiAnTW9kZWxQaXhlbFNjYWxlJyxcbiAgMHg4NDgyOiAnTW9kZWxUaWVwb2ludCcsXG4gIDB4ODVEODogJ01vZGVsVHJhbnNmb3JtYXRpb24nLFxuICAweDg3QUY6ICdHZW9LZXlEaXJlY3RvcnknLFxuICAweDg3QjA6ICdHZW9Eb3VibGVQYXJhbXMnLFxuICAweDg3QjE6ICdHZW9Bc2NpaVBhcmFtcycsXG5cbiAgLy8gTEVSQ1xuICAweEM1RjI6ICdMZXJjUGFyYW1ldGVycycsXG59O1xuXG5leHBvcnQgY29uc3QgZmllbGRUYWdzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFRhZ05hbWVzKSB7XG4gIGlmIChmaWVsZFRhZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBmaWVsZFRhZ3NbZmllbGRUYWdOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaWVsZFRhZ1R5cGVzID0ge1xuICAyNTY6ICdTSE9SVCcsXG4gIDI1NzogJ1NIT1JUJyxcbiAgMjU4OiAnU0hPUlQnLFxuICAyNTk6ICdTSE9SVCcsXG4gIDI2MjogJ1NIT1JUJyxcbiAgMjczOiAnTE9ORycsXG4gIDI3NDogJ1NIT1JUJyxcbiAgMjc3OiAnU0hPUlQnLFxuICAyNzg6ICdMT05HJyxcbiAgMjc5OiAnTE9ORycsXG4gIDI4MjogJ1JBVElPTkFMJyxcbiAgMjgzOiAnUkFUSU9OQUwnLFxuICAyODQ6ICdTSE9SVCcsXG4gIDI4NjogJ1NIT1JUJyxcbiAgMjg3OiAnUkFUSU9OQUwnLFxuICAyOTY6ICdTSE9SVCcsXG4gIDI5NzogJ1NIT1JUJyxcbiAgMzA1OiAnQVNDSUknLFxuICAzMDY6ICdBU0NJSScsXG4gIDMzODogJ1NIT1JUJyxcbiAgMzM5OiAnU0hPUlQnLFxuICA1MTM6ICdMT05HJyxcbiAgNTE0OiAnTE9ORycsXG4gIDEwMjQ6ICdTSE9SVCcsXG4gIDEwMjU6ICdTSE9SVCcsXG4gIDIwNDg6ICdTSE9SVCcsXG4gIDIwNDk6ICdBU0NJSScsXG4gIDMwNzI6ICdTSE9SVCcsXG4gIDMwNzM6ICdBU0NJSScsXG4gIDMzNTUwOiAnRE9VQkxFJyxcbiAgMzM5MjI6ICdET1VCTEUnLFxuICAzNDI2NDogJ0RPVUJMRScsXG4gIDM0NjY1OiAnTE9ORycsXG4gIDM0NzM1OiAnU0hPUlQnLFxuICAzNDczNjogJ0RPVUJMRScsXG4gIDM0NzM3OiAnQVNDSUknLFxuICA0MjExMzogJ0FTQ0lJJyxcbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUZpZWxkcyA9IFtcbiAgZmllbGRUYWdzLkJpdHNQZXJTYW1wbGUsXG4gIGZpZWxkVGFncy5FeHRyYVNhbXBsZXMsXG4gIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsXG4gIGZpZWxkVGFncy5TdHJpcEJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5TdHJpcE9mZnNldHMsXG4gIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZU9mZnNldHMsXG4gIGZpZWxkVGFncy5TdWJJRkRzLFxuXTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZU5hbWVzID0ge1xuICAweDAwMDE6ICdCWVRFJyxcbiAgMHgwMDAyOiAnQVNDSUknLFxuICAweDAwMDM6ICdTSE9SVCcsXG4gIDB4MDAwNDogJ0xPTkcnLFxuICAweDAwMDU6ICdSQVRJT05BTCcsXG4gIDB4MDAwNjogJ1NCWVRFJyxcbiAgMHgwMDA3OiAnVU5ERUZJTkVEJyxcbiAgMHgwMDA4OiAnU1NIT1JUJyxcbiAgMHgwMDA5OiAnU0xPTkcnLFxuICAweDAwMEE6ICdTUkFUSU9OQUwnLFxuICAweDAwMEI6ICdGTE9BVCcsXG4gIDB4MDAwQzogJ0RPVUJMRScsXG4gIC8vIElGRCBvZmZzZXQsIHN1Z2dlc3RlZCBieSBodHRwczovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9zdGFuZGFyZHMuaHRtbFxuICAweDAwMEQ6ICdJRkQnLFxuICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkZcbiAgMHgwMDEwOiAnTE9ORzgnLFxuICAweDAwMTE6ICdTTE9ORzgnLFxuICAweDAwMTI6ICdJRkQ4Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFR5cGVOYW1lcykge1xuICBpZiAoZmllbGRUeXBlTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMgPSB7XG4gIFdoaXRlSXNaZXJvOiAwLFxuICBCbGFja0lzWmVybzogMSxcbiAgUkdCOiAyLFxuICBQYWxldHRlOiAzLFxuICBUcmFuc3BhcmVuY3lNYXNrOiA0LFxuICBDTVlLOiA1LFxuICBZQ2JDcjogNixcblxuICBDSUVMYWI6IDgsXG4gIElDQ0xhYjogOSxcbn07XG5cbmV4cG9ydCBjb25zdCBFeHRyYVNhbXBsZXNWYWx1ZXMgPSB7XG4gIFVuc3BlY2lmaWVkOiAwLFxuICBBc3NvY2FscGhhOiAxLFxuICBVbmFzc2FscGhhOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNQYXJhbWV0ZXJzID0ge1xuICBWZXJzaW9uOiAwLFxuICBBZGRDb21wcmVzc2lvbjogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjQWRkQ29tcHJlc3Npb24gPSB7XG4gIE5vbmU6IDAsXG4gIERlZmxhdGU6IDEsXG4gIFpzdGFuZGFyZDogMixcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlOYW1lcyA9IHtcbiAgMTAyNDogJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgMTAyNTogJ0dUUmFzdGVyVHlwZUdlb0tleScsXG4gIDEwMjY6ICdHVENpdGF0aW9uR2VvS2V5JyxcbiAgMjA0ODogJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgMjA0OTogJ0dlb2dDaXRhdGlvbkdlb0tleScsXG4gIDIwNTA6ICdHZW9nR2VvZGV0aWNEYXR1bUdlb0tleScsXG4gIDIwNTE6ICdHZW9nUHJpbWVNZXJpZGlhbkdlb0tleScsXG4gIDIwNTI6ICdHZW9nTGluZWFyVW5pdHNHZW9LZXknLFxuICAyMDUzOiAnR2VvZ0xpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMjA1NDogJ0dlb2dBbmd1bGFyVW5pdHNHZW9LZXknLFxuICAyMDU1OiAnR2VvZ0FuZ3VsYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTY6ICdHZW9nRWxsaXBzb2lkR2VvS2V5JyxcbiAgMjA1NzogJ0dlb2dTZW1pTWFqb3JBeGlzR2VvS2V5JyxcbiAgMjA1ODogJ0dlb2dTZW1pTWlub3JBeGlzR2VvS2V5JyxcbiAgMjA1OTogJ0dlb2dJbnZGbGF0dGVuaW5nR2VvS2V5JyxcbiAgMjA2MDogJ0dlb2dBemltdXRoVW5pdHNHZW9LZXknLFxuICAyMDYxOiAnR2VvZ1ByaW1lTWVyaWRpYW5Mb25nR2VvS2V5JyxcbiAgMjA2MjogJ0dlb2dUT1dHUzg0R2VvS2V5JyxcbiAgMzA3MjogJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gIDMwNzM6ICdQQ1NDaXRhdGlvbkdlb0tleScsXG4gIDMwNzQ6ICdQcm9qZWN0aW9uR2VvS2V5JyxcbiAgMzA3NTogJ1Byb2pDb29yZFRyYW5zR2VvS2V5JyxcbiAgMzA3NjogJ1Byb2pMaW5lYXJVbml0c0dlb0tleScsXG4gIDMwNzc6ICdQcm9qTGluZWFyVW5pdFNpemVHZW9LZXknLFxuICAzMDc4OiAnUHJvalN0ZFBhcmFsbGVsMUdlb0tleScsXG4gIDMwNzk6ICdQcm9qU3RkUGFyYWxsZWwyR2VvS2V5JyxcbiAgMzA4MDogJ1Byb2pOYXRPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4MTogJ1Byb2pOYXRPcmlnaW5MYXRHZW9LZXknLFxuICAzMDgyOiAnUHJvakZhbHNlRWFzdGluZ0dlb0tleScsXG4gIDMwODM6ICdQcm9qRmFsc2VOb3J0aGluZ0dlb0tleScsXG4gIDMwODQ6ICdQcm9qRmFsc2VPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4NTogJ1Byb2pGYWxzZU9yaWdpbkxhdEdlb0tleScsXG4gIDMwODY6ICdQcm9qRmFsc2VPcmlnaW5FYXN0aW5nR2VvS2V5JyxcbiAgMzA4NzogJ1Byb2pGYWxzZU9yaWdpbk5vcnRoaW5nR2VvS2V5JyxcbiAgMzA4ODogJ1Byb2pDZW50ZXJMb25nR2VvS2V5JyxcbiAgMzA4OTogJ1Byb2pDZW50ZXJMYXRHZW9LZXknLFxuICAzMDkwOiAnUHJvakNlbnRlckVhc3RpbmdHZW9LZXknLFxuICAzMDkxOiAnUHJvakNlbnRlck5vcnRoaW5nR2VvS2V5JyxcbiAgMzA5MjogJ1Byb2pTY2FsZUF0TmF0T3JpZ2luR2VvS2V5JyxcbiAgMzA5MzogJ1Byb2pTY2FsZUF0Q2VudGVyR2VvS2V5JyxcbiAgMzA5NDogJ1Byb2pBemltdXRoQW5nbGVHZW9LZXknLFxuICAzMDk1OiAnUHJvalN0cmFpZ2h0VmVydFBvbGVMb25nR2VvS2V5JyxcbiAgMzA5NjogJ1Byb2pSZWN0aWZpZWRHcmlkQW5nbGVHZW9LZXknLFxuICA0MDk2OiAnVmVydGljYWxDU1R5cGVHZW9LZXknLFxuICA0MDk3OiAnVmVydGljYWxDaXRhdGlvbkdlb0tleScsXG4gIDQwOTg6ICdWZXJ0aWNhbERhdHVtR2VvS2V5JyxcbiAgNDA5OTogJ1ZlcnRpY2FsVW5pdHNHZW9LZXknLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb0tleXMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGdlb0tleU5hbWVzKSB7XG4gIGlmIChnZW9LZXlOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZ2VvS2V5c1tnZW9LZXlOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/globals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   time: () => (/* binding */ time),\n/* harmony export */   timeEnd: () => (/* binding */ timeEnd),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxsb2dnaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBuby1vcCBsb2dnZXJcbiAqL1xuY2xhc3MgRHVtbXlMb2dnZXIge1xuICBsb2coKSB7fVxuXG4gIGRlYnVnKCkge31cblxuICBpbmZvKCkge31cblxuICB3YXJuKCkge31cblxuICBlcnJvcigpIHt9XG5cbiAgdGltZSgpIHt9XG5cbiAgdGltZUVuZCgpIHt9XG59XG5cbmxldCBMT0dHRVIgPSBuZXcgRHVtbXlMb2dnZXIoKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGxvZ2dlciB0aGUgbmV3IGxvZ2dlci4gZS5nIGBjb25zb2xlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nZ2VyKGxvZ2dlciA9IG5ldyBEdW1teUxvZ2dlcigpKSB7XG4gIExPR0dFUiA9IGxvZ2dlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5kZWJ1ZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIubG9nKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuaW5mbyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm4oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLndhcm4oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvciguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZXJyb3IoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi50aW1lKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUVuZCguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZUVuZCguLi5hcmdzKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"(ssr)/./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/geotiff\"), __webpack_require__.e(\"vendor-chunks/web-worker\"), __webpack_require__.e(\"_ssr_node_modules_web-worker_lazy_recursive-_ssr_node_modules_web-worker_sync_recursive\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wb29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOFhBQTZCO0FBQ3JDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxwb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcblxuY29uc3QgZGVmYXVsdFBvb2xTaXplID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMikgOiAyO1xuXG4vKipcbiAqIEBtb2R1bGUgcG9vbFxuICovXG5cbi8qKlxuICogUG9vbCBmb3Igd29ya2VycyB0byBkZWNvZGUgY2h1bmtzIG9mIHRoZSBpbWFnZXMuXG4gKi9cbmNsYXNzIFBvb2wge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIHBvb2wuIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgQ1BVc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYG51bGxgIG9yIDAsIHRoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogV29ya2VyfSBbY3JlYXRlV29ya2VyXSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgZGVjb2RlciB3b3JrZXIuXG4gICAqIERlZmF1bHRzIHRvIGEgd29ya2VyIHdpdGggYWxsIGRlY29kZXJzIHRoYXQgc2hpcCB3aXRoIGdlb3RpZmYuanMuIFRoZSBgY3JlYXRlV29ya2VyKClgXG4gICAqIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGBXb3JrZXJgIGNvbXBhdGlibGUgd2l0aCBXZWIgV29ya2Vycy4gRm9yIGNvZGUgdGhhdFxuICAgKiBydW5zIGluIE5vZGUsIFt3ZWItd29ya2VyXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93ZWItd29ya2VyKSBpcyBhIGdvb2QgY2hvaWNlLlxuICAgKlxuICAgKiBBIHdvcmtlciB0aGF0IHVzZXMgYSBjdXN0b20gbHp3IGRlY29kZXIgd291bGQgbG9vayBsaWtlIHRoaXMgYG15LWN1c3RvbS13b3JrZXIuanNgIGZpbGU6XG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IGFkZERlY29kZXIsIGdldERlY29kZXIgfSBmcm9tICdnZW90aWZmJztcbiAgICogYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQgKCcuL215LWN1c3RvbS1sencnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiAgICogc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGUpID0+IHtcbiAgICogICBjb25zdCB7IGlkLCBmaWxlRGlyZWN0b3J5LCBidWZmZXIgfSA9IGUuZGF0YTtcbiAgICogICBjb25zdCBkZWNvZGVyID0gYXdhaXQgZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbiAgICogICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKTtcbiAgICogICBzZWxmLnBvc3RNZXNzYWdlKHsgZGVjb2RlZCwgaWQgfSwgW2RlY29kZWRdKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBUaGUgd2F5IHRoZSBhYm92ZSBjb2RlIGlzIGJ1aWx0IGludG8gYSB3b3JrZXIgYnkgdGhlIGBjcmVhdGVXb3JrZXIoKWAgZnVuY3Rpb25cbiAgICogZGVwZW5kcyBvbiB0aGUgdXNlZCBidW5kbGVyLiBGb3IgbW9zdCBidW5kbGVycywgc29tZXRoaW5nIGxpa2UgdGhpcyB3aWxsIHdvcms6XG4gICAqIGBgYGpzXG4gICAqIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcigpIHtcbiAgICogICByZXR1cm4gbmV3IFdvcmtlcihuZXcgVVJMKCcuL215LWN1c3RvbS13b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUgPSBkZWZhdWx0UG9vbFNpemUsIGNyZWF0ZVdvcmtlcikge1xuICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubWVzc2FnZUlkID0gMDtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gY3JlYXRlV29ya2VyID8gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVdvcmtlcikgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpbXBvcnQoJy4vd29ya2VyL2RlY29kZXIuanMnKS50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICByZXNvbHZlKG1vZHVsZS5jcmVhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyLnRoZW4oKGNyZWF0ZSkgPT4ge1xuICAgICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmtlcnMucHVzaCh7IHdvcmtlcjogY3JlYXRlKCksIGlkbGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJsb2NrIG9mIGJ5dGVzIHdpdGggdGhlIHNldCBjb21wcmVzc2lvbiBtZXRob2QuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciB0aGUgYXJyYXkgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSB0aGUgZGVjb2RlZCByZXN1bHQgYXMgYSBgUHJvbWlzZWBcbiAgICovXG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYXdhaXRpbmdEZWNvZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9hd2FpdGluZ0RlY29kZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpemUgPT09IDBcbiAgICAgID8gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KS50aGVuKChkZWNvZGVyKSA9PiBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpKVxuICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlcnMuZmluZCgoY2FuZGlkYXRlKSA9PiBjYW5kaWRhdGUuaWRsZSlcbiAgICAgICAgICB8fCB0aGlzLndvcmtlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplKV07XG4gICAgICAgIHdvcmtlci5pZGxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tZXNzYWdlSWQrKztcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgd29ya2VyLmlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEuZGVjb2RlZCk7XG4gICAgICAgICAgICB3b3JrZXIud29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLndvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGZpbGVEaXJlY3RvcnksIGJ1ZmZlciwgaWQgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLndvcmtlcnMpIHtcbiAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgd29ya2VyLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9vbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredictor: () => (/* binding */ applyPredictor)\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0EsTUFBTSw0QkFBNEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxccHJlZGljdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSkge1xuICBsZXQgbGVuZ3RoID0gcm93Lmxlbmd0aCAtIHN0cmlkZTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGRvIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgaS0tKSB7XG4gICAgICByb3dbb2Zmc2V0ICsgc3RyaWRlXSArPSByb3dbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIGxlbmd0aCAtPSBzdHJpZGU7XG4gIH0gd2hpbGUgKGxlbmd0aCA+IDApO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSkge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY291bnQgPSByb3cubGVuZ3RoO1xuICBjb25zdCB3YyA9IGNvdW50IC8gYnl0ZXNQZXJTYW1wbGU7XG5cbiAgd2hpbGUgKGNvdW50ID4gc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IC0taSkge1xuICAgICAgcm93W2luZGV4ICsgc3RyaWRlXSArPSByb3dbaW5kZXhdO1xuICAgICAgKytpbmRleDtcbiAgICB9XG4gICAgY291bnQgLT0gc3RyaWRlO1xuICB9XG5cbiAgY29uc3QgY29weSA9IHJvdy5zbGljZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdjOyArK2kpIHtcbiAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJ5dGVzUGVyU2FtcGxlOyArK2IpIHtcbiAgICAgIHJvd1soYnl0ZXNQZXJTYW1wbGUgKiBpKSArIGJdID0gY29weVsoKGJ5dGVzUGVyU2FtcGxlIC0gYiAtIDEpICogd2MpICsgaV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVByZWRpY3RvcihibG9jaywgcHJlZGljdG9yLCB3aWR0aCwgaGVpZ2h0LCBiaXRzUGVyU2FtcGxlLFxuICBwbGFuYXJDb25maWd1cmF0aW9uKSB7XG4gIGlmICghcHJlZGljdG9yIHx8IHByZWRpY3RvciA9PT0gMSkge1xuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICUgOCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBvbmx5IG11bHRpcGxlIG9mIDggYml0cyBhcmUgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAhPT0gYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBhbGwgc2FtcGxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2l6ZS4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGVbMF0gLyA4O1xuICBjb25zdCBzdHJpZGUgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyID8gMSA6IGJpdHNQZXJTYW1wbGUubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyArK2kpIHtcbiAgICAvLyBMYXN0IHN0cmlwIHdpbGwgYmUgdHJ1bmNhdGVkIGlmIGhlaWdodCAlIHN0cmlwSGVpZ2h0ICE9IDBcbiAgICBpZiAoaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgPj0gYmxvY2suYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCByb3c7XG4gICAgaWYgKHByZWRpY3RvciA9PT0gMikgeyAvLyBob3Jpem9udGFsIHByZWRpY3Rpb25cbiAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZVswXSkge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyAyLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gNCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJlZGljdG9yIDIgbm90IGFsbG93ZWQgd2l0aCAke2JpdHNQZXJTYW1wbGVbMF19IGJpdHMgcGVyIHNhbXBsZS5gKTtcbiAgICAgIH1cbiAgICAgIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH0gZWxzZSBpZiAocHJlZGljdG9yID09PSAzKSB7IC8vIGhvcml6b250YWwgZmxvYXRpbmcgcG9pbnRcbiAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsXG4gICAgICApO1xuICAgICAgZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2s7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/predictor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resample: () => (/* binding */ resample),\n/* harmony export */   resampleBilinear: () => (/* binding */ resampleBilinear),\n/* harmony export */   resampleBilinearInterleaved: () => (/* binding */ resampleBilinearInterleaved),\n/* harmony export */   resampleInterleaved: () => (/* binding */ resampleInterleaved),\n/* harmony export */   resampleNearest: () => (/* binding */ resampleNearest),\n/* harmony export */   resampleNearestInterleaved: () => (/* binding */ resampleNearestInterleaved)\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsY0FBYztBQUMzQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGNBQWM7QUFDM0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxccmVzYW1wbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHJlc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY29weU5ld1NpemUoYXJyYXksIHdpZHRoLCBoZWlnaHQsIHNhbXBsZXNQZXJQaXhlbCA9IDEpIHtcbiAgcmV0dXJuIG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFycmF5KS5jb25zdHJ1Y3Rvcikod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5WyhjeSAqIGluV2lkdGgpICsgY3hdO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8vIHNpbXBsZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb24jUHJvZ3JhbW1pbmdfbGFuZ3VhZ2Vfc3VwcG9ydFxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICgoMSAtIHQpICogdjApICsgKHQgKiB2MSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhoXTtcbiAgICAgICAgY29uc3QgbGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhoXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGUodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUFycmF5WyhjeSAqIGluV2lkdGggKiBzYW1wbGVzKSArIChjeCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCBsbCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGxoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBoaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXkgVGhlIGlucHV0IGFycmF5IHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVJbnRlcmxlYXZlZCh2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcywgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/resample.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBlackIsZero: () => (/* binding */ fromBlackIsZero),\n/* harmony export */   fromCIELab: () => (/* binding */ fromCIELab),\n/* harmony export */   fromCMYK: () => (/* binding */ fromCMYK),\n/* harmony export */   fromPalette: () => (/* binding */ fromPalette),\n/* harmony export */   fromWhiteIsZero: () => (/* binding */ fromWhiteIsZero),\n/* harmony export */   fromYCbCr: () => (/* binding */ fromYCbCr)\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUCxVQUFVLGdCQUFnQjtBQUMxQjs7QUFFQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0EsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxccmdiLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBmcm9tV2hpdGVJc1plcm8ocmFzdGVyLCBtYXgpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICB2YWx1ZSA9IDI1NiAtIChyYXN0ZXJbaV0gLyBtYXggKiAyNTYpO1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CbGFja0lzWmVybyhyYXN0ZXIsIG1heCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIHZhbHVlID0gcmFzdGVyW2ldIC8gbWF4ICogMjU2O1xuICAgIHJnYlJhc3RlcltqXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QYWxldHRlKHJhc3RlciwgY29sb3JNYXApIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGNvbnN0IGdyZWVuT2Zmc2V0ID0gY29sb3JNYXAubGVuZ3RoIC8gMztcbiAgY29uc3QgYmx1ZU9mZnNldCA9IGNvbG9yTWFwLmxlbmd0aCAvIDMgKiAyO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIGNvbnN0IG1hcEluZGV4ID0gcmFzdGVyW2ldO1xuICAgIHJnYlJhc3RlcltqXSA9IGNvbG9yTWFwW21hcEluZGV4XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSBjb2xvck1hcFttYXBJbmRleCArIGdyZWVuT2Zmc2V0XSAvIDY1NTM2ICogMjU2O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBjb2xvck1hcFttYXBJbmRleCArIGJsdWVPZmZzZXRdIC8gNjU1MzYgKiAyNTY7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21DTVlLKGNteWtSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjbXlrUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjbXlrUmFzdGVyLmxlbmd0aDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICBjb25zdCBjID0gY215a1Jhc3RlcltpXTtcbiAgICBjb25zdCBtID0gY215a1Jhc3RlcltpICsgMV07XG4gICAgY29uc3QgeSA9IGNteWtSYXN0ZXJbaSArIDJdO1xuICAgIGNvbnN0IGsgPSBjbXlrUmFzdGVyW2kgKyAzXTtcblxuICAgIHJnYlJhc3RlcltqXSA9IDI1NSAqICgoMjU1IC0gYykgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IDI1NSAqICgoMjU1IC0gbSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IDI1NSAqICgoMjU1IC0geSkgLyAyNTYpICogKCgyNTUgLSBrKSAvIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21ZQ2JDcih5Q2JDclJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHlDYkNyUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgeUNiQ3JSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IHkgPSB5Q2JDclJhc3RlcltpXTtcbiAgICBjb25zdCBjYiA9IHlDYkNyUmFzdGVyW2kgKyAxXTtcbiAgICBjb25zdCBjciA9IHlDYkNyUmFzdGVyW2kgKyAyXTtcblxuICAgIHJnYlJhc3RlcltqXSA9ICh5ICsgKDEuNDAyMDAgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSAoeSAtICgwLjM0NDE0ICogKGNiIC0gMHg4MCkpIC0gKDAuNzE0MTQgKiAoY3IgLSAweDgwKSkpO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSAoeSArICgxLjc3MjAwICogKGNiIC0gMHg4MCkpKTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5jb25zdCBYbiA9IDAuOTUwNDc7XG5jb25zdCBZbiA9IDEuMDAwMDA7XG5jb25zdCBabiA9IDEuMDg4ODM7XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FudGltYXR0ZXIxNS9yZ2ItbGFiL2Jsb2IvbWFzdGVyL2NvbG9yLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ0lFTGFiKGNpZUxhYlJhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNpZUxhYlJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcblxuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjaWVMYWJSYXN0ZXIubGVuZ3RoOyBpICs9IDMsIGogKz0gMykge1xuICAgIGNvbnN0IEwgPSBjaWVMYWJSYXN0ZXJbaSArIDBdO1xuICAgIGNvbnN0IGFfID0gY2llTGFiUmFzdGVyW2kgKyAxXSA8PCAyNCA+PiAyNDsgLy8gY29udmVyc2lvbiBmcm9tIHVpbnQ4IHRvIGludDhcbiAgICBjb25zdCBiXyA9IGNpZUxhYlJhc3RlcltpICsgMl0gPDwgMjQgPj4gMjQ7IC8vIHNhbWVcblxuICAgIGxldCB5ID0gKEwgKyAxNikgLyAxMTY7XG4gICAgbGV0IHggPSAoYV8gLyA1MDApICsgeTtcbiAgICBsZXQgeiA9IHkgLSAoYl8gLyAyMDApO1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuXG4gICAgeCA9IFhuICogKCh4ICogeCAqIHggPiAwLjAwODg1NikgPyB4ICogeCAqIHggOiAoeCAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuICAgIHkgPSBZbiAqICgoeSAqIHkgKiB5ID4gMC4wMDg4NTYpID8geSAqIHkgKiB5IDogKHkgLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcbiAgICB6ID0gWm4gKiAoKHogKiB6ICogeiA+IDAuMDA4ODU2KSA/IHogKiB6ICogeiA6ICh6IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG5cbiAgICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gICAgZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG4gICAgYiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cbiAgICByID0gKHIgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChyICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiByO1xuICAgIGcgPSAoZyA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKGcgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIGc7XG4gICAgYiA9IChiID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAoYiAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogYjtcblxuICAgIHJnYlJhc3RlcltqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHIpKSAqIDI1NTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZykpICogMjU1O1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBiKSkgKiAyNTU7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/rgb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeBufferSource: () => (/* binding */ makeBufferSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZDO0FBQ0o7O0FBRXpDLGdDQUFnQyxzREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcc291cmNlXFxhcnJheWJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEFycmF5QnVmZmVyU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gIH1cblxuICBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJ1ZmZlclNvdXJjZShhcnJheUJ1ZmZlcikge1xuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyU291cmNlKGFycmF5QnVmZmVyKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/arraybuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSource: () => (/* binding */ BaseSource)\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcc291cmNlXFxiYXNlc291cmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYgU2xpY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuXG5leHBvcnQgY2xhc3MgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlW119IHNsaWNlc1xuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJbXX1cbiAgICovXG4gIGFzeW5jIGZldGNoKHNsaWNlcywgc2lnbmFsID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgc2xpY2VzLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlfSBzbGljZVxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9XG4gICAqL1xuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBmZXRjaGluZyBvZiBzbGljZSAke3NsaWNlfSBub3QgcG9zc2libGUsIG5vdCBpbXBsZW1lbnRlZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbGVzaXplIGlmIGFscmVhZHkgZGV0ZXJtaW5lZCBhbmQgbnVsbCBvdGhlcndpc2VcbiAgICovXG4gIGdldCBmaWxlU2l6ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIC8vIG5vLW9wIGJ5IGRlZmF1bHRcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockedSource: () => (/* binding */ BlockedSource)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"(ssr)/./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWlDO0FBQ1k7QUFDdUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLDRCQUE0QixzREFBVTtBQUM3QztBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0JBQXdCLHFDQUFxQyxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaURBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUwsZUFBZSxvQkFBb0I7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLCtDQUFJO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFVO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBYztBQUM5Qjs7QUFFQTtBQUNBLG1DQUFtQyw4Q0FBRzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQiw0QkFBNEI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyx3QkFBd0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXHNvdXJjZVxcYmxvY2tlZHNvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUXVpY2tMUlUgZnJvbSAncXVpY2stbHJ1JztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQWJvcnRFcnJvciwgQWdncmVnYXRlRXJyb3IsIHdhaXQsIHppcCB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuY2xhc3MgQmxvY2sge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IFtkYXRhXVxuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIGRhdGEgPSBudWxsKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgdG9wIGJ5dGUgYm9yZGVyXG4gICAqL1xuICBnZXQgdG9wKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldCArIHRoaXMubGVuZ3RoO1xuICB9XG59XG5cbmNsYXNzIEJsb2NrR3JvdXAge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGJsb2NrSWRzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvZmZzZXQsIGxlbmd0aCwgYmxvY2tJZHMpIHtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmJsb2NrSWRzID0gYmxvY2tJZHM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJsb2NrZWRTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7QmFzZVNvdXJjZX0gc291cmNlIFRoZSB1bmRlcmx5aW5nIHNvdXJjZSB0aGF0IHNoYWxsIGJlIGJsb2NrZWQgYW5kIGNhY2hlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmxvY2tTaXplXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY2FjaGVTaXplXVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlLCB7IGJsb2NrU2l6ZSA9IDY1NTM2LCBjYWNoZVNpemUgPSAxMDAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmJsb2NrU2l6ZSA9IGJsb2NrU2l6ZTtcblxuICAgIHRoaXMuYmxvY2tDYWNoZSA9IG5ldyBRdWlja0xSVSh7XG4gICAgICBtYXhTaXplOiBjYWNoZVNpemUsXG4gICAgICBvbkV2aWN0aW9uOiAoYmxvY2tJZCwgYmxvY2spID0+IHtcbiAgICAgICAgdGhpcy5ldmljdGVkQmxvY2tzLnNldChibG9ja0lkLCBibG9jayk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLyoqIEB0eXBlIHtNYXA8bnVtYmVyLCBCbG9jaz59ICovXG4gICAgdGhpcy5ldmljdGVkQmxvY2tzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gbWFwcGluZyBibG9ja0lkIC0+IEJsb2NrIGluc3RhbmNlXG4gICAgdGhpcy5ibG9ja1JlcXVlc3RzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gc2V0IG9mIGJsb2NrSWRzIG1pc3NpbmcgZm9yIHRoZSBjdXJyZW50IHJlcXVlc3RzXG4gICAgdGhpcy5ibG9ja0lkc1RvRmV0Y2ggPSBuZXcgU2V0KCk7XG5cbiAgICB0aGlzLmFib3J0ZWRCbG9ja0lkcyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIGdldCBmaWxlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuZmlsZVNpemU7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Jhc2Vzb3VyY2VcIikuU2xpY2VbXX0gc2xpY2VzXG4gICAqL1xuICBhc3luYyBmZXRjaChzbGljZXMsIHNpZ25hbCkge1xuICAgIGNvbnN0IGJsb2NrUmVxdWVzdHMgPSBbXTtcbiAgICBjb25zdCBtaXNzaW5nQmxvY2tJZHMgPSBbXTtcbiAgICBjb25zdCBhbGxCbG9ja0lkcyA9IFtdO1xuICAgIHRoaXMuZXZpY3RlZEJsb2Nrcy5jbGVhcigpO1xuXG4gICAgZm9yIChjb25zdCB7IG9mZnNldCwgbGVuZ3RoIH0gb2Ygc2xpY2VzKSB7XG4gICAgICBsZXQgdG9wID0gb2Zmc2V0ICsgbGVuZ3RoO1xuXG4gICAgICBjb25zdCB7IGZpbGVTaXplIH0gPSB0aGlzO1xuICAgICAgaWYgKGZpbGVTaXplICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgZmlsZVNpemUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaXJzdEJsb2NrT2Zmc2V0ID0gTWF0aC5mbG9vcihvZmZzZXQgLyB0aGlzLmJsb2NrU2l6ZSkgKiB0aGlzLmJsb2NrU2l6ZTtcblxuICAgICAgZm9yIChsZXQgY3VycmVudCA9IGZpcnN0QmxvY2tPZmZzZXQ7IGN1cnJlbnQgPCB0b3A7IGN1cnJlbnQgKz0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgY29uc3QgYmxvY2tJZCA9IE1hdGguZmxvb3IoY3VycmVudCAvIHRoaXMuYmxvY2tTaXplKTtcbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrQ2FjaGUuaGFzKGJsb2NrSWQpICYmICF0aGlzLmJsb2NrUmVxdWVzdHMuaGFzKGJsb2NrSWQpKSB7XG4gICAgICAgICAgdGhpcy5ibG9ja0lkc1RvRmV0Y2guYWRkKGJsb2NrSWQpO1xuICAgICAgICAgIG1pc3NpbmdCbG9ja0lkcy5wdXNoKGJsb2NrSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJsb2NrUmVxdWVzdHMuaGFzKGJsb2NrSWQpKSB7XG4gICAgICAgICAgYmxvY2tSZXF1ZXN0cy5wdXNoKHRoaXMuYmxvY2tSZXF1ZXN0cy5nZXQoYmxvY2tJZCkpO1xuICAgICAgICB9XG4gICAgICAgIGFsbEJsb2NrSWRzLnB1c2goYmxvY2tJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgYWRkaXRpb25hbCBibG9jayByZXF1ZXN0cyB0byBhY2N1bXVsYXRlXG4gICAgYXdhaXQgd2FpdCgpO1xuICAgIHRoaXMuZmV0Y2hCbG9ja3Moc2lnbmFsKTtcblxuICAgIC8vIEdhdGhlciBhbGwgb2YgdGhlIG5ldyByZXF1ZXN0cyB0aGF0IHRoaXMgZmV0Y2ggY2FsbCBpcyBjb250cmlidXRpbmcgdG8gYGZldGNoYC5cbiAgICBjb25zdCBtaXNzaW5nUmVxdWVzdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2YgbWlzc2luZ0Jsb2NrSWRzKSB7XG4gICAgICAvLyBUaGUgcmVxdWVzdGVkIG1pc3NpbmcgYmxvY2sgY291bGQgYWxyZWFkeSBiZSBpbiB0aGUgY2FjaGVcbiAgICAgIC8vIGluc3RlYWQgb2YgaGF2aW5nIGl0cyByZXF1ZXN0IHN0aWxsIGJlIG91dHN0YW5kaW5nLlxuICAgICAgaWYgKHRoaXMuYmxvY2tSZXF1ZXN0cy5oYXMoYmxvY2tJZCkpIHtcbiAgICAgICAgbWlzc2luZ1JlcXVlc3RzLnB1c2godGhpcy5ibG9ja1JlcXVlc3RzLmdldChibG9ja0lkKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgYXdhaXQgYWxsIHBlbmRpbmcgcmVxdWVzdHMgdGhhdCBhcmUgbmVlZGVkIGZvciB0aGlzIGBmZXRjaGAuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGJsb2NrUmVxdWVzdHMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChtaXNzaW5nUmVxdWVzdHMpO1xuXG4gICAgLy8gUGVyZm9ybSByZXRyaWVzIGlmIGEgYmxvY2sgd2FzIGludGVycnVwdGVkIGJ5IGEgcHJldmlvdXMgc2lnbmFsXG4gICAgY29uc3QgYWJvcnRlZEJsb2NrUmVxdWVzdHMgPSBbXTtcbiAgICBjb25zdCBhYm9ydGVkQmxvY2tJZHMgPSBhbGxCbG9ja0lkc1xuICAgICAgLmZpbHRlcigoaWQpID0+IHRoaXMuYWJvcnRlZEJsb2NrSWRzLmhhcyhpZCkgfHwgIXRoaXMuYmxvY2tDYWNoZS5oYXMoaWQpKTtcbiAgICBhYm9ydGVkQmxvY2tJZHMuZm9yRWFjaCgoaWQpID0+IHRoaXMuYmxvY2tJZHNUb0ZldGNoLmFkZChpZCkpO1xuICAgIC8vIHN0YXJ0IHRoZSByZXRyeSBvZiBzb21lIGJsb2NrcyBpZiByZXF1aXJlZFxuICAgIGlmIChhYm9ydGVkQmxvY2tJZHMubGVuZ3RoID4gMCAmJiBzaWduYWwgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aGlzLmZldGNoQmxvY2tzKG51bGwpO1xuICAgICAgZm9yIChjb25zdCBibG9ja0lkIG9mIGFib3J0ZWRCbG9ja0lkcykge1xuICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuYmxvY2tSZXF1ZXN0cy5nZXQoYmxvY2tJZCk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2NrICR7YmxvY2tJZH0gaXMgbm90IGluIHRoZSBibG9jayByZXF1ZXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0ZWRCbG9ja1JlcXVlc3RzLnB1c2goYmxvY2spO1xuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGFib3J0ZWRCbG9ja1JlcXVlc3RzKTtcbiAgICB9XG5cbiAgICAvLyB0aHJvdyBhbiAgYWJvcnQgZXJyb3JcbiAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcignUmVxdWVzdCB3YXMgYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrcyA9IGFsbEJsb2NrSWRzLm1hcCgoaWQpID0+IHRoaXMuYmxvY2tDYWNoZS5nZXQoaWQpIHx8IHRoaXMuZXZpY3RlZEJsb2Nrcy5nZXQoaWQpKTtcbiAgICBjb25zdCBmYWlsZWRCbG9ja3MgPSBibG9ja3MuZmlsdGVyKChpKSA9PiAhaSk7XG4gICAgaWYgKGZhaWxlZEJsb2Nrcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsZWRCbG9ja3MsICdSZXF1ZXN0IGZhaWxlZCcpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIGZpbmFsIE1hcCwgd2l0aCBhbGwgcmVxdWlyZWQgYmxvY2tzIGZvciB0aGlzIHJlcXVlc3QgdG8gc2F0aXNmeVxuICAgIGNvbnN0IHJlcXVpcmVkQmxvY2tzID0gbmV3IE1hcCh6aXAoYWxsQmxvY2tJZHMsIGJsb2NrcykpO1xuXG4gICAgLy8gVE9ETzogc2F0aXNmeSBlYWNoIHNsaWNlXG4gICAgcmV0dXJuIHRoaXMucmVhZFNsaWNlRGF0YShzbGljZXMsIHJlcXVpcmVkQmxvY2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBzaWduYWxcbiAgICovXG4gIGZldGNoQmxvY2tzKHNpZ25hbCkge1xuICAgIC8vIGNoZWNrIGlmIHdlIHN0aWxsIG5lZWQgdG9cbiAgICBpZiAodGhpcy5ibG9ja0lkc1RvRmV0Y2guc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBCbG9ja3ModGhpcy5ibG9ja0lkc1RvRmV0Y2gpO1xuXG4gICAgICAvLyBzdGFydCByZXF1ZXN0aW5nIHNsaWNlcyBvZiBkYXRhXG4gICAgICBjb25zdCBncm91cFJlcXVlc3RzID0gdGhpcy5zb3VyY2UuZmV0Y2goZ3JvdXBzLCBzaWduYWwpO1xuXG4gICAgICBmb3IgKGxldCBncm91cEluZGV4ID0gMDsgZ3JvdXBJbmRleCA8IGdyb3Vwcy5sZW5ndGg7ICsrZ3JvdXBJbmRleCkge1xuICAgICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tncm91cEluZGV4XTtcblxuICAgICAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2YgZ3JvdXAuYmxvY2tJZHMpIHtcbiAgICAgICAgICAvLyBtYWtlIGFuIGFzeW5jIElJRkUgZm9yIGVhY2ggYmxvY2tcbiAgICAgICAgICB0aGlzLmJsb2NrUmVxdWVzdHMuc2V0KGJsb2NrSWQsIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBncm91cFJlcXVlc3RzKVtncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBibG9ja0lkICogdGhpcy5ibG9ja1NpemU7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSBibG9ja09mZnNldCAtIHJlc3BvbnNlLm9mZnNldDtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IE1hdGgubWluKG8gKyB0aGlzLmJsb2NrU2l6ZSwgcmVzcG9uc2UuZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGEuc2xpY2UobywgdCk7XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKFxuICAgICAgICAgICAgICAgIGJsb2NrT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGJsb2NrSWQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMuYmxvY2tDYWNoZS5zZXQoYmxvY2tJZCwgYmxvY2spO1xuICAgICAgICAgICAgICB0aGlzLmFib3J0ZWRCbG9ja0lkcy5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgc2lnbmFsIGhlcmUsIHdlIG5lZWQgaXQgdG8gZGV0ZXJtaW5lIGxhdGVyIGlmIGFuXG4gICAgICAgICAgICAgICAgLy8gZXJyb3Igd2FzIGNhdXNlZCBieSB0aGlzIHNpZ25hbFxuICAgICAgICAgICAgICAgIGVyci5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0NhY2hlLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0ZWRCbG9ja0lkcy5hZGQoYmxvY2tJZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICB0aGlzLmJsb2NrUmVxdWVzdHMuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJsb2NrSWRzVG9GZXRjaC5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NldH0gYmxvY2tJZHNcbiAgICogQHJldHVybnMge0Jsb2NrR3JvdXBbXX1cbiAgICovXG4gIGdyb3VwQmxvY2tzKGJsb2NrSWRzKSB7XG4gICAgY29uc3Qgc29ydGVkQmxvY2tJZHMgPSBBcnJheS5mcm9tKGJsb2NrSWRzKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgaWYgKHNvcnRlZEJsb2NrSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgY3VycmVudCA9IFtdO1xuICAgIGxldCBsYXN0QmxvY2tJZCA9IG51bGw7XG4gICAgY29uc3QgZ3JvdXBzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGJsb2NrSWQgb2Ygc29ydGVkQmxvY2tJZHMpIHtcbiAgICAgIGlmIChsYXN0QmxvY2tJZCA9PT0gbnVsbCB8fCBsYXN0QmxvY2tJZCArIDEgPT09IGJsb2NrSWQpIHtcbiAgICAgICAgY3VycmVudC5wdXNoKGJsb2NrSWQpO1xuICAgICAgICBsYXN0QmxvY2tJZCA9IGJsb2NrSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cHMucHVzaChuZXcgQmxvY2tHcm91cChcbiAgICAgICAgICBjdXJyZW50WzBdICogdGhpcy5ibG9ja1NpemUsXG4gICAgICAgICAgY3VycmVudC5sZW5ndGggKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICApKTtcbiAgICAgICAgY3VycmVudCA9IFtibG9ja0lkXTtcbiAgICAgICAgbGFzdEJsb2NrSWQgPSBibG9ja0lkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdyb3Vwcy5wdXNoKG5ldyBCbG9ja0dyb3VwKFxuICAgICAgY3VycmVudFswXSAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgY3VycmVudC5sZW5ndGggKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgIGN1cnJlbnQsXG4gICAgKSk7XG5cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9iYXNlc291cmNlXCIpLlNsaWNlW119IHNsaWNlc1xuICAgKiBAcGFyYW0ge01hcH0gYmxvY2tzXG4gICAqL1xuICByZWFkU2xpY2VEYXRhKHNsaWNlcywgYmxvY2tzKSB7XG4gICAgcmV0dXJuIHNsaWNlcy5tYXAoKHNsaWNlKSA9PiB7XG4gICAgICBsZXQgdG9wID0gc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZmlsZVNpemUgIT09IG51bGwpIHtcbiAgICAgICAgdG9wID0gTWF0aC5taW4odGhpcy5maWxlU2l6ZSwgdG9wKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJsb2NrSWRMb3cgPSBNYXRoLmZsb29yKHNsaWNlLm9mZnNldCAvIHRoaXMuYmxvY2tTaXplKTtcbiAgICAgIGNvbnN0IGJsb2NrSWRIaWdoID0gTWF0aC5mbG9vcih0b3AgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICBjb25zdCBzbGljZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoc2xpY2UubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNsaWNlVmlldyA9IG5ldyBVaW50OEFycmF5KHNsaWNlRGF0YSk7XG5cbiAgICAgIGZvciAobGV0IGJsb2NrSWQgPSBibG9ja0lkTG93OyBibG9ja0lkIDw9IGJsb2NrSWRIaWdoOyArK2Jsb2NrSWQpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja3MuZ2V0KGJsb2NrSWQpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGJsb2NrLm9mZnNldCAtIHNsaWNlLm9mZnNldDtcbiAgICAgICAgY29uc3QgdG9wRGVsdGEgPSBibG9jay50b3AgLSB0b3A7XG4gICAgICAgIGxldCBibG9ja0lubmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHJhbmdlSW5uZXJPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgdXNlZEJsb2NrTGVuZ3RoO1xuXG4gICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICBibG9ja0lubmVyT2Zmc2V0ID0gLWRlbHRhO1xuICAgICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgIHJhbmdlSW5uZXJPZmZzZXQgPSBkZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEZWx0YSA8IDApIHtcbiAgICAgICAgICB1c2VkQmxvY2tMZW5ndGggPSBibG9jay5sZW5ndGggLSBibG9ja0lubmVyT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVzZWRCbG9ja0xlbmd0aCA9IHRvcCAtIGJsb2NrLm9mZnNldCAtIGJsb2NrSW5uZXJPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBibG9ja1ZpZXcgPSBuZXcgVWludDhBcnJheShibG9jay5kYXRhLCBibG9ja0lubmVyT2Zmc2V0LCB1c2VkQmxvY2tMZW5ndGgpO1xuICAgICAgICBzbGljZVZpZXcuc2V0KGJsb2NrVmlldywgcmFuZ2VJbm5lck9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbGljZURhdGE7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* binding */ BaseClient),\n/* harmony export */   BaseResponse: () => (/* binding */ BaseResponse)\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDRDQUE0QyxXQUFXO0FBQ3JFLGVBQWU7QUFDZjtBQUNBLGtCQUFrQixrQkFBa0IsSUFBSSxJQUFJO0FBQzVDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcc291cmNlXFxjbGllbnRcXGJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBhbiBvaydpc2ggc3RhdHVzIGNvZGVcbiAgICovXG4gIGdldCBvaygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDw9IDI5OTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgY29kZSBvZiB0aGUgcmVzcG9uc2VcbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGhlYWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyTmFtZSB0aGUgaGVhZGVyIG5hbWVcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGhlYWRlciB2YWx1ZVxuICAgKi9cbiAgZ2V0SGVhZGVyKGhlYWRlck5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSB0aGUgcmVzcG9uc2UgZGF0YSBvZiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHJlcXVlc3Qgd2l0aCB0aGUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3toZWFkZXJzOiBIZWFkZXJzSW5pdCwgc2lnbmFsOiBBYm9ydFNpZ25hbH19IFtvcHRpb25zPXt9XVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCYXNlUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWVzdCBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchClient: () => (/* binding */ FetchClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEOztBQUVyRCw0QkFBNEIsa0RBQVk7QUFDeEM7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sMEJBQTBCLGdEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw0Q0FBNEMsV0FBVztBQUNyRSxlQUFlO0FBQ2Y7QUFDQSxrQkFBa0Isa0JBQWtCLElBQUk7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXHNvdXJjZVxcY2xpZW50XFxmZXRjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UuanMnO1xuXG5jbGFzcyBGZXRjaFJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIGZldGNoIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzO1xuICB9XG5cbiAgZ2V0SGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzcG9uc2UuYXJyYXlCdWZmZXJcbiAgICAgID8gYXdhaXQgdGhpcy5yZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gICAgICA6IChhd2FpdCB0aGlzLnJlc3BvbnNlLmJ1ZmZlcigpKS5idWZmZXI7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZldGNoQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgY3JlZGVudGlhbHMpIHtcbiAgICBzdXBlcih1cmwpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3toZWFkZXJzOiBIZWFkZXJzSW5pdCwgc2lnbmFsOiBBYm9ydFNpZ25hbH19IFtvcHRpb25zPXt9XVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnVybCwge1xuICAgICAgaGVhZGVycywgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsIHNpZ25hbCxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdCO0FBQ0U7QUFDRDs7QUFFNEI7QUFDVDs7QUFFNUMsMkJBQTJCLGtEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHlCQUF5QixnREFBVTtBQUMxQztBQUNBO0FBQ0EscUJBQXFCLHNDQUFZO0FBQ2pDLDBEQUEwRCxpQ0FBSSxHQUFHLGtDQUFLO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQVU7QUFDeEM7QUFDQSxtRUFBbUUsaURBQVU7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0JBQWtCLGtCQUFrQixJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxzb3VyY2VcXGNsaWVudFxcaHR0cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXJsTW9kIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBIdHRwUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3Igbm9kZSBIVFRQL0hUVFBTIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgZGF0YVByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRhdGFQcm9taXNlID0gZGF0YVByb21pc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnNbbmFtZV07XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFQcm9taXNlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5wYXJzZWRVcmwgPSB1cmxNb2QucGFyc2UodGhpcy51cmwpO1xuICAgIHRoaXMuaHR0cEFwaSA9ICh0aGlzLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGh0dHAgOiBodHRwcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwQXBpLmdldChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMucGFyc2VkVXJsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVEYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCBjaHVua3NcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgY2h1bmtzIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdGluZyBidWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcykuYnVmZmVyO1xuICAgICAgICAgICAgICByZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UsIGRhdGFQcm9taXNlKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCByZWplY3QpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHRClient: () => (/* binding */ XHRClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"(ssr)/./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFDVDs7QUFFNUMsMEJBQTBCLGtEQUFZO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sd0JBQXdCLGdEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFVO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrQkFBa0Isa0JBQWtCLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXHNvdXJjZVxcY2xpZW50XFx4aHIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIFhIUlJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4aHIsIGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueGhyID0geGhyO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnhoci5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWEhSQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMudXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhvb2sgc2lnbmFsc1xuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgcmVzb2x2ZShuZXcgWEhSUmVzcG9uc2UoeGhyLCBkYXRhKSk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICB4aHIub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB4aHIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileSource: () => (/* binding */ makeFileSource)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0I7QUFDeUI7O0FBRTdDO0FBQ0E7QUFDQSxJQUFJLHFDQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxvQ0FBTztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksb0NBQU87QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHlCQUF5QixzREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxzb3VyY2VcXGZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5mdW5jdGlvbiBjbG9zZUFzeW5jKGZkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMuY2xvc2UoZmQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcGVuQXN5bmMocGF0aCwgZmxhZ3MsIG1vZGUgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEFzeW5jKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKC4uLmFyZ3MsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgRmlsZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMub3BlblJlcXVlc3QgPSBvcGVuQXN5bmMocGF0aCwgJ3InKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICAvLyBUT0RPOiB1c2UgYHNpZ25hbGBcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHJlYWRBc3luYyhcbiAgICAgIGZkLFxuICAgICAgQnVmZmVyLmFsbG9jKHNsaWNlLmxlbmd0aCksXG4gICAgICAwLFxuICAgICAgc2xpY2UubGVuZ3RoLFxuICAgICAgc2xpY2Uub2Zmc2V0LFxuICAgICk7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgYXdhaXQgY2xvc2VBc3luYyhmZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlU291cmNlKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBGaWxlU291cmNlKHBhdGgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileReaderSource: () => (/* binding */ makeFileReaderSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2Qzs7QUFFN0MsK0JBQStCLHNEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFxzb3VyY2VcXGZpbGVyZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5cbmNsYXNzIEZpbGVSZWFkZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoZmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBibG9iID0gdGhpcy5maWxlLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICByZWFkZXIub25hYm9ydCA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiByZWFkZXIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc291cmNlIGZyb20gYSBnaXZlbiBmaWxlL2Jsb2IuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgVGhlIGZpbGUgb3IgYmxvYiB0byByZWFkIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVJlYWRlclNvdXJjZShmaWxlKSB7XG4gIHJldHVybiBuZXcgRmlsZVJlYWRlclNvdXJjZShmaWxlKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseByteRanges: () => (/* binding */ parseByteRanges),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   parseContentType: () => (/* binding */ parseContentType)\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQLHNEQUFzRDtBQUN0RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDLHlCQUF5QixjQUFjOztBQUV2QztBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYWJhcm5cXE9uZURyaXZlXFxEZXNrdG9wXFxTYW5qYXlhbiBSZWFjdCBGaWxlc1xcZ2Vvc3BhdGlhbF9hcHBcXEdlb3NwYXRpYWwtQXBwbGljYXRpb25cXGdlb3NwYXRpYWxfc2t5c2VydmVcXG5vZGVfbW9kdWxlc1xcZ2VvdGlmZlxcZGlzdC1tb2R1bGVcXHNvdXJjZVxcaHR0cHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENSTEZDUkxGID0gJ1xcclxcblxcclxcbic7XG5cbi8qXG4gKiBTaGltIGZvciAnT2JqZWN0LmZyb21FbnRyaWVzJ1xuICovXG5mdW5jdGlvbiBpdGVtc1RvT2JqZWN0KGl0ZW1zKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmZyb21FbnRyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaXRlbXMpO1xuICB9XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVtcykge1xuICAgIG9ialtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIEhUVFAgaGVhZGVycyBmcm9tIGEgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcGFyc2UgdGhlIGhlYWRlcnMgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBoZWFkZXJzIHdpdGggbG93ZXJjYXNlIGtleXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHRleHQpIHtcbiAgY29uc3QgaXRlbXMgPSB0ZXh0XG4gICAgLnNwbGl0KCdcXHJcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnOicpLm1hcCgoc3RyKSA9PiBzdHIudHJpbSgpKTtcbiAgICAgIGt2WzBdID0ga3ZbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBrdjtcbiAgICB9KTtcblxuICByZXR1cm4gaXRlbXNUb09iamVjdChpdGVtcyk7XG59XG5cbi8qKlxuICogUGFyc2UgYSAnQ29udGVudC1UeXBlJyBoZWFkZXIgdmFsdWUgdG8gdGhlIGNvbnRlbnQtdHlwZSBhbmQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRUeXBlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgY29udGVudCB0eXBlIHdpdGggdGhlIGZpZWxkczogdHlwZSBhbmQgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHJhd0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IFt0eXBlLCAuLi5yYXdQYXJhbXNdID0gcmF3Q29udGVudFR5cGUuc3BsaXQoJzsnKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgY29uc3QgcGFyYW1zSXRlbXMgPSByYXdQYXJhbXMubWFwKChwYXJhbSkgPT4gcGFyYW0uc3BsaXQoJz0nKSk7XG4gIHJldHVybiB7IHR5cGUsIHBhcmFtczogaXRlbXNUb09iamVjdChwYXJhbXNJdGVtcykgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVJhbmdlJyBoZWFkZXIgdmFsdWUgdG8gaXRzIHN0YXJ0LCBlbmQsIGFuZCB0b3RhbCBwYXJ0c1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRSYW5nZSB0aGUgcmF3IHN0cmluZyB0byBwYXJzZSBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIHBhcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRSYW5nZShyYXdDb250ZW50UmFuZ2UpIHtcbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBsZXQgdG90YWw7XG5cbiAgaWYgKHJhd0NvbnRlbnRSYW5nZSkge1xuICAgIFssIHN0YXJ0LCBlbmQsIHRvdGFsXSA9IHJhd0NvbnRlbnRSYW5nZS5tYXRjaCgvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8pO1xuICAgIHN0YXJ0ID0gcGFyc2VJbnQoc3RhcnQsIDEwKTtcbiAgICBlbmQgPSBwYXJzZUludChlbmQsIDEwKTtcbiAgICB0b3RhbCA9IHBhcnNlSW50KHRvdGFsLCAxMCk7XG4gIH1cblxuICByZXR1cm4geyBzdGFydCwgZW5kLCB0b3RhbCB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXJhbmdlcyBmcm9tIHRoZSBnaXZlbiAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnIEhUVFAgcmVzcG9uc2UuXG4gKiBFYWNoIGl0ZW0gaW4gdGhlIGxpc3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIC0gaGVhZGVyczogdGhlIEhUVFAgaGVhZGVyc1xuICogLSBkYXRhOiB0aGUgc2xpY2VkIEFycmF5QnVmZmVyIGZvciB0aGF0IHNwZWNpZmljIHBhcnRcbiAqIC0gb2Zmc2V0OiB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcmFuZ2Ugd2l0aGluIGl0cyBvcmlnaW5hdGluZyBmaWxlXG4gKiAtIGxlbmd0aDogdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXJhbmdlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSByZXNwb25zZUFycmF5QnVmZmVyIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYW5kIHNwbGl0XG4gKiBAcGFyYW0ge1N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHN0cmluZyB1c2VkIHRvIHNwbGl0IHRoZSBzZWN0aW9uc1xuICogQHJldHVybnMge09iamVjdFtdfSB0aGUgcGFyc2VkIGJ5dGVyYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnl0ZVJhbmdlcyhyZXNwb25zZUFycmF5QnVmZmVyLCBib3VuZGFyeSkge1xuICBsZXQgb2Zmc2V0ID0gbnVsbDtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignYXNjaWknKTtcbiAgY29uc3Qgb3V0ID0gW107XG5cbiAgY29uc3Qgc3RhcnRCb3VuZGFyeSA9IGAtLSR7Ym91bmRhcnl9YDtcbiAgY29uc3QgZW5kQm91bmRhcnkgPSBgJHtzdGFydEJvdW5kYXJ5fS0tYDtcblxuICAvLyBzZWFyY2ggZm9yIHRoZSBpbml0aWFsIGJvdW5kYXJ5LCBtYXkgYmUgb2Zmc2V0IGJ5IHNvbWUgYnl0ZXNcbiAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgdG8gY2hlY2sgZm9yIGAtLWAgaW4gYnl0ZXMgZGlyZWN0bHlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgaSwgc3RhcnRCb3VuZGFyeS5sZW5ndGgpLFxuICAgICk7XG4gICAgaWYgKHRleHQgPT09IHN0YXJ0Qm91bmRhcnkpIHtcbiAgICAgIG9mZnNldCA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaW5pdGlhbCBib3VuZGFyeScpO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3BvbnNlQXJyYXlCdWZmZXIsIG9mZnNldCxcbiAgICAgICAgTWF0aC5taW4oc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAxMDI0LCByZXNwb25zZUFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgLy8gYnJlYWsgaWYgd2UgYXJyaXZlZCBhdCB0aGUgZW5kXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwIHx8IHRleHQuc3RhcnRzV2l0aChlbmRCb3VuZGFyeSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCB0aGF0IHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBieXRlcmFuZ2UgYW5kIGFyZSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAgICBpZiAoIXRleHQuc3RhcnRzV2l0aChzdGFydEJvdW5kYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0IGRvZXMgbm90IHN0YXJ0IHdpdGggYm91bmRhcnknKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYSBzdWJzdHJpbmcgZnJvbSB3aGVyZSB3ZSByZWFkIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgaW5uZXJUZXh0ID0gdGV4dC5zdWJzdHIoc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAyKTtcblxuICAgIGlmIChpbm5lclRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBkb3VibGUgbGluZWJyZWFrIHRoYXQgZGVub3RlcyB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gaW5uZXJUZXh0LmluZGV4T2YoQ1JMRkNSTEYpO1xuXG4gICAgLy8gcGFyc2UgdGhlIGhlYWRlcnMgdG8gZ2V0IHRoZSBjb250ZW50IHJhbmdlIHNpemVcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKGlubmVyVGV4dC5zdWJzdHIoMCwgZW5kT2ZIZWFkZXJzKSk7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyc1snY29udGVudC1yYW5nZSddKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBhbmQgdGhlIG5leHQgb2Zmc2V0XG4gICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBvZmZzZXQgKyBzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIGVuZE9mSGVhZGVycyArIENSTEZDUkxGLmxlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChlbmQsIDEwKSArIDEgLSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIG91dC5wdXNoKHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiByZXNwb25zZUFycmF5QnVmZmVyLnNsaWNlKHN0YXJ0T2ZEYXRhLCBzdGFydE9mRGF0YSArIGxlbmd0aCksXG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgZmlsZVNpemU6IHRvdGFsLFxuICAgIH0pO1xuXG4gICAgb2Zmc2V0ID0gc3RhcnRPZkRhdGEgKyBsZW5ndGggKyA0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/httputils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCustomSource: () => (/* binding */ makeCustomSource),\n/* harmony export */   makeFetchSource: () => (/* binding */ makeFetchSource),\n/* harmony export */   makeHttpSource: () => (/* binding */ makeHttpSource),\n/* harmony export */   makeRemoteSource: () => (/* binding */ makeRemoteSource),\n/* harmony export */   makeXHRSource: () => (/* binding */ makeXHRSource)\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"(ssr)/./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ3pDO0FBQ007O0FBRUg7QUFDSjtBQUNFOztBQUU5QywyQkFBMkIsc0RBQVU7QUFDckM7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGtCQUFrQixnQkFBZ0IsUUFBUSxPQUFPLEdBQUcsZ0JBQWdCO0FBQ3BFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLGVBQWUsRUFBRSwrREFBZ0I7QUFDL0M7QUFDQSwyQkFBMkIsOERBQWU7QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsb0JBQW9CLEVBQUUsZ0VBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTyxHQUFHLGdCQUFnQjtBQUNsRCxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxjQUFjLFFBQVEsRUFBRSxnRUFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0REFBYSxXQUFXLHNCQUFzQjtBQUMzRDs7QUFFTyxnQ0FBZ0MsWUFBWSx1RUFBdUUsSUFBSTtBQUM5SCxxQkFBcUIseURBQVc7QUFDaEM7QUFDQTtBQUNBOztBQUVPLDhCQUE4QixZQUFZLDBEQUEwRCxJQUFJO0FBQy9HLHFCQUFxQixxREFBUztBQUM5QjtBQUNBO0FBQ0E7O0FBRU8sK0JBQStCLFlBQVksMERBQTBELElBQUk7QUFDaEgscUJBQXFCLHVEQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFTyxvQ0FBb0MsWUFBWSwwREFBMEQsSUFBSTtBQUNySDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTyxpQ0FBaUMscUNBQXFDLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcc291cmNlXFxyZW1vdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VCeXRlUmFuZ2VzLCBwYXJzZUNvbnRlbnRSYW5nZSwgcGFyc2VDb250ZW50VHlwZSB9IGZyb20gJy4vaHR0cHV0aWxzLmpzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQmxvY2tlZFNvdXJjZSB9IGZyb20gJy4vYmxvY2tlZHNvdXJjZS5qcyc7XG5cbmltcG9ydCB7IEZldGNoQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvZmV0Y2guanMnO1xuaW1wb3J0IHsgWEhSQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQveGhyLmpzJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICcuL2NsaWVudC9odHRwLmpzJztcblxuY2xhc3MgUmVtb3RlU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VDbGllbnR9IGNsaWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVyc1xuICAgKiBAcGFyYW0ge251bWJlcnN9IG1heFJhbmdlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RnVsbEZpbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMubWF4UmFuZ2VzID0gbWF4UmFuZ2VzO1xuICAgIHRoaXMuYWxsb3dGdWxsRmlsZSA9IGFsbG93RnVsbEZpbGU7XG4gICAgdGhpcy5fZmlsZVNpemUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqL1xuICBhc3luYyBmZXRjaChzbGljZXMsIHNpZ25hbCkge1xuICAgIC8vIGlmIHdlIGFsbG93IG11bHRpLXJhbmdlcywgc3BsaXQgdGhlIGluY29taW5nIHJlcXVlc3QgaW50byB0aGF0IG1hbnkgc3ViLXJlcXVlc3RzXG4gICAgLy8gYW5kIGpvaW4gdGhlbSBhZnRlcndhcmRzXG4gICAgaWYgKHRoaXMubWF4UmFuZ2VzID49IHNsaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoU2xpY2VzKHNsaWNlcywgc2lnbmFsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF4UmFuZ2VzID4gMCAmJiBzbGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gVE9ETzogc3BsaXQgaW50byBtdWx0aXBsZSBtdWx0aS1yYW5nZSByZXF1ZXN0c1xuXG4gICAgICAvLyBjb25zdCBzdWJTbGljZXNSZXF1ZXN0cyA9IFtdO1xuICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyBpICs9IHRoaXMubWF4UmFuZ2VzKSB7XG4gICAgICAvLyAgIHN1YlNsaWNlc1JlcXVlc3RzLnB1c2goXG4gICAgICAvLyAgICAgdGhpcy5mZXRjaFNsaWNlcyhzbGljZXMuc2xpY2UoaSwgaSArIHRoaXMubWF4UmFuZ2VzKSwgc2lnbmFsKSxcbiAgICAgIC8vICAgKTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3ViU2xpY2VzUmVxdWVzdHMpKS5mbGF0KCk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIG1ha2UgYSBzaW5nbGUgcmVxdWVzdCBmb3IgZWFjaCBzbGljZVxuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHNsaWNlcy5tYXAoKHNsaWNlKSA9PiB0aGlzLmZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkpLFxuICAgICk7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlcyhzbGljZXMsIHNpZ25hbCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgUmFuZ2U6IGBieXRlcz0ke3NsaWNlc1xuICAgICAgICAgIC5tYXAoKHsgb2Zmc2V0LCBsZW5ndGggfSkgPT4gYCR7b2Zmc2V0fS0ke29mZnNldCArIGxlbmd0aH1gKVxuICAgICAgICAgIC5qb2luKCcsJylcbiAgICAgICAgfWAsXG4gICAgICB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhLicpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgcGFyYW1zIH0gPSBwYXJzZUNvbnRlbnRUeXBlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC10eXBlJykpO1xuICAgICAgaWYgKHR5cGUgPT09ICdtdWx0aXBhcnQvYnl0ZXJhbmdlcycpIHtcbiAgICAgICAgY29uc3QgYnl0ZVJhbmdlcyA9IHBhcnNlQnl0ZVJhbmdlcyhhd2FpdCByZXNwb25zZS5nZXREYXRhKCksIHBhcmFtcy5ib3VuZGFyeSk7XG4gICAgICAgIHRoaXMuX2ZpbGVTaXplID0gYnl0ZVJhbmdlc1swXS5maWxlU2l6ZSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gYnl0ZVJhbmdlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXJhbmdlJykpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSB0b3RhbCB8fCBudWxsO1xuICAgICAgY29uc3QgZmlyc3QgPSBbe1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgfV07XG5cbiAgICAgIGlmIChzbGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyB3ZSByZXF1ZXN0ZWQgbW9yZSB0aGFuIG9uZSBzbGljZSwgYnV0IGdvdCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5LCBzb21lIEhUVFAgU2VydmVycyBkb24ndCBzdXBwb3J0IG11bHRpLXJhbmdlc1xuICAgICAgICAvLyBhbmQgcmV0dXJuIG9ubHkgdGhlIGZpcnN0XG5cbiAgICAgICAgLy8gZ2V0IHRoZSByZXN0IG9mIHRoZSBzbGljZXMgYW5kIGZldGNoIHRoZW0gaXRlcmF0aXZlbHlcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoc2xpY2VzLnNsaWNlKDEpLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSkpO1xuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KG90aGVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0Z1bGxGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbmRlZCB3aXRoIGZ1bGwgZmlsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICB9XTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgbGVuZ3RoIH0gPSBzbGljZTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RofWAsXG4gICAgICB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgdGhlIHJlc3BvbnNlIHdhcyBva2F5IGFuZCBpZiB0aGUgc2VydmVyIGFjdHVhbGx5IHVuZGVyc3RhbmRzIHJhbmdlIHJlcXVlc3RzXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhLicpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RnVsbEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZnVsbCBmaWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlU2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCB7IGJsb2NrU2l6ZSwgY2FjaGVTaXplIH0pIHtcbiAgaWYgKGJsb2NrU2l6ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9ja2VkU291cmNlKHNvdXJjZSwgeyBibG9ja1NpemUsIGNhY2hlU2l6ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGZXRjaFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBjcmVkZW50aWFscywgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBGZXRjaENsaWVudCh1cmwsIGNyZWRlbnRpYWxzKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVhIUlNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IFhIUkNsaWVudCh1cmwpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSHR0cFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IEh0dHBDbGllbnQodXJsKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUN1c3RvbVNvdXJjZShjbGllbnQsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlbW90ZVNvdXJjZSh1cmwsIHsgZm9yY2VYSFIgPSBmYWxzZSwgLi4uY2xpZW50T3B0aW9ucyB9ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZm9yY2VYSFIpIHtcbiAgICByZXR1cm4gbWFrZUZldGNoU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWFrZVhIUlNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBtYWtlSHR0cFNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/source/remote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   CustomAggregateError: () => (/* binding */ CustomAggregateError),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   times: () => (/* binding */ times),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toArrayRecursively: () => (/* binding */ toArrayRecursively),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   zip: () => (/* binding */ zip)\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxVQUFVLFNBQVM7QUFDbkIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLFVBQVUsU0FBUztBQUNuQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYmFyblxcT25lRHJpdmVcXERlc2t0b3BcXFNhbmpheWFuIFJlYWN0IEZpbGVzXFxnZW9zcGF0aWFsX2FwcFxcR2Vvc3BhdGlhbC1BcHBsaWNhdGlvblxcZ2Vvc3BhdGlhbF9za3lzZXJ2ZVxcbm9kZV9tb2R1bGVzXFxnZW90aWZmXFxkaXN0LW1vZHVsZVxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaHVuayhpdGVyYWJsZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgbGVuZ3RoT2ZJdGVyYWJsZSA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhPZkl0ZXJhYmxlOyBpICs9IGxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rZWQgPSBbXTtcbiAgICBmb3IgKGxldCBjaSA9IGk7IGNpIDwgaSArIGxlbmd0aDsgY2krKykge1xuICAgICAgY2h1bmtlZC5wdXNoKGl0ZXJhYmxlW2NpXSk7XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChjaHVua2VkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgZXhwZWN0ZWRFbmRpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPCBleHBlY3RlZEVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsRW5kaW5nID0gc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gZXhwZWN0ZWRFbmRpbmcubGVuZ3RoKTtcbiAgcmV0dXJuIGFjdHVhbEVuZGluZyA9PT0gZXhwZWN0ZWRFbmRpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVyYWJsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZ1bmMoaXRlcmFibGVbaV0sIGkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob2xkT2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRPYmopIHtcbiAgICBpZiAob2xkT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2xkT2JqW2tleV07XG4gICAgICBuZXdPYmpbdmFsdWVdID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uobikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXMobnVtVGltZXMsIGZ1bmMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goZnVuYyhpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlSZWN1cnNpdmVseShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoaW5wdXQpLm1hcCh0b0FycmF5UmVjdXJzaXZlbHkpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FjYWRlbWlhLWRlLWNvZGlnby9wYXJzZS1jb250ZW50LXJhbmdlLWhlYWRlci9ibG9iL21hc3Rlci9pbmRleC5qc1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKGhlYWRlclZhbHVlKSB7XG4gIGlmICghaGVhZGVyVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGVhZGVyVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBwYXJzZUludCA9IChudW1iZXIpID0+IE51bWJlci5wYXJzZUludChudW1iZXIsIDEwKTtcblxuICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2YgdW5pdFxuICBsZXQgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC9eKFxcdyopIC8pO1xuICBjb25zdCB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuXG4gIC8vIGNoZWNrIGZvciBzdGFydC1lbmQvc2l6ZSBoZWFkZXIgZm9ybWF0XG4gIG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvKFxcZCspLShcXGQrKVxcLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICAgIGxhc3Q6IHBhcnNlSW50KG1hdGNoZXNbMl0pLFxuICAgICAgbGVuZ3RoOiBtYXRjaGVzWzNdID09PSAnKicgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hlc1szXSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkK3xcXCopLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXQsXG4gICAgICBmaXJzdDogbnVsbCxcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbMV0gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBQcm9taXNpZmllZCB3cmFwcGVyIGFyb3VuZCAnc2V0VGltZW91dCcgdG8gYWxsb3cgJ2F3YWl0J1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdChtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpc2Vjb25kcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgY29uc3QgQSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogQXJyYXkuZnJvbShhKTtcbiAgY29uc3QgQiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogQXJyYXkuZnJvbShiKTtcbiAgcmV0dXJuIEEubWFwKChrLCBpKSA9PiBbaywgQltpXV0pO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIC8vIFBhc3MgcmVtYWluaW5nIGFyZ3VtZW50cyAoaW5jbHVkaW5nIHZlbmRvciBzcGVjaWZpYyBvbmVzKSB0byBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQWJvcnRFcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21BZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js":
/*!************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/worker/decoder.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var web_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-worker */ \"(ssr)/./node_modules/web-worker/node.js\");\n\n        \n        function create() {\n          const source = \"function A(A,e,t,i,r,I,g){try{var n=A[I](g),a=n.value}catch(A){return void t(A)}n.done?e(a):Promise.resolve(a).then(i,r)}function e(e){return function(){var t=this,i=arguments;return new Promise((function(r,I){var g=e.apply(t,i);function n(e){A(g,r,I,n,a,\\\"next\\\",e)}function a(e){A(g,r,I,n,a,\\\"throw\\\",e)}n(void 0)}))}}function t(A){return t=\\\"function\\\"==typeof Symbol&&\\\"symbol\\\"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&\\\"function\\\"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?\\\"symbol\\\":typeof A},t(A)}var i={exports:{}};!function(A){var e=function(A){var e,i=Object.prototype,r=i.hasOwnProperty,I=\\\"function\\\"==typeof Symbol?Symbol:{},g=I.iterator||\\\"@@iterator\\\",n=I.asyncIterator||\\\"@@asyncIterator\\\",a=I.toStringTag||\\\"@@toStringTag\\\";function o(A,e,t){return Object.defineProperty(A,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),A[e]}try{o({},\\\"\\\")}catch(A){o=function(A,e,t){return A[e]=t}}function B(A,e,t,i){var r=e&&e.prototype instanceof h?e:h,I=Object.create(r.prototype),g=new S(i||[]);return I._invoke=function(A,e,t){var i=Q;return function(r,I){if(i===s)throw new Error(\\\"Generator is already running\\\");if(i===f){if(\\\"throw\\\"===r)throw I;return R()}for(t.method=r,t.arg=I;;){var g=t.delegate;if(g){var n=m(g,t);if(n){if(n===c)continue;return n}}if(\\\"next\\\"===t.method)t.sent=t._sent=t.arg;else if(\\\"throw\\\"===t.method){if(i===Q)throw i=f,t.arg;t.dispatchException(t.arg)}else\\\"return\\\"===t.method&&t.abrupt(\\\"return\\\",t.arg);i=s;var a=C(A,e,t);if(\\\"normal\\\"===a.type){if(i=t.done?f:E,a.arg===c)continue;return{value:a.arg,done:t.done}}\\\"throw\\\"===a.type&&(i=f,t.method=\\\"throw\\\",t.arg=a.arg)}}}(A,t,g),I}function C(A,e,t){try{return{type:\\\"normal\\\",arg:A.call(e,t)}}catch(A){return{type:\\\"throw\\\",arg:A}}}A.wrap=B;var Q=\\\"suspendedStart\\\",E=\\\"suspendedYield\\\",s=\\\"executing\\\",f=\\\"completed\\\",c={};function h(){}function l(){}function u(){}var w={};o(w,g,(function(){return this}));var d=Object.getPrototypeOf,D=d&&d(d(v([])));D&&D!==i&&r.call(D,g)&&(w=D);var y=u.prototype=h.prototype=Object.create(w);function k(A){[\\\"next\\\",\\\"throw\\\",\\\"return\\\"].forEach((function(e){o(A,e,(function(A){return this._invoke(e,A)}))}))}function p(A,e){function i(I,g,n,a){var o=C(A[I],A,g);if(\\\"throw\\\"!==o.type){var B=o.arg,Q=B.value;return Q&&\\\"object\\\"===t(Q)&&r.call(Q,\\\"__await\\\")?e.resolve(Q.__await).then((function(A){i(\\\"next\\\",A,n,a)}),(function(A){i(\\\"throw\\\",A,n,a)})):e.resolve(Q).then((function(A){B.value=A,n(B)}),(function(A){return i(\\\"throw\\\",A,n,a)}))}a(o.arg)}var I;this._invoke=function(A,t){function r(){return new e((function(e,r){i(A,t,e,r)}))}return I=I?I.then(r,r):r()}}function m(A,t){var i=A.iterator[t.method];if(i===e){if(t.delegate=null,\\\"throw\\\"===t.method){if(A.iterator.return&&(t.method=\\\"return\\\",t.arg=e,m(A,t),\\\"throw\\\"===t.method))return c;t.method=\\\"throw\\\",t.arg=new TypeError(\\\"The iterator does not provide a 'throw' method\\\")}return c}var r=C(i,A.iterator,t.arg);if(\\\"throw\\\"===r.type)return t.method=\\\"throw\\\",t.arg=r.arg,t.delegate=null,c;var I=r.arg;return I?I.done?(t[A.resultName]=I.value,t.next=A.nextLoc,\\\"return\\\"!==t.method&&(t.method=\\\"next\\\",t.arg=e),t.delegate=null,c):I:(t.method=\\\"throw\\\",t.arg=new TypeError(\\\"iterator result is not an object\\\"),t.delegate=null,c)}function G(A){var e={tryLoc:A[0]};1 in A&&(e.catchLoc=A[1]),2 in A&&(e.finallyLoc=A[2],e.afterLoc=A[3]),this.tryEntries.push(e)}function F(A){var e=A.completion||{};e.type=\\\"normal\\\",delete e.arg,A.completion=e}function S(A){this.tryEntries=[{tryLoc:\\\"root\\\"}],A.forEach(G,this),this.reset(!0)}function v(A){if(A){var t=A[g];if(t)return t.call(A);if(\\\"function\\\"==typeof A.next)return A;if(!isNaN(A.length)){var i=-1,I=function t(){for(;++i<A.length;)if(r.call(A,i))return t.value=A[i],t.done=!1,t;return t.value=e,t.done=!0,t};return I.next=I}}return{next:R}}function R(){return{value:e,done:!0}}return l.prototype=u,o(y,\\\"constructor\\\",u),o(u,\\\"constructor\\\",l),l.displayName=o(u,a,\\\"GeneratorFunction\\\"),A.isGeneratorFunction=function(A){var e=\\\"function\\\"==typeof A&&A.constructor;return!!e&&(e===l||\\\"GeneratorFunction\\\"===(e.displayName||e.name))},A.mark=function(A){return Object.setPrototypeOf?Object.setPrototypeOf(A,u):(A.__proto__=u,o(A,a,\\\"GeneratorFunction\\\")),A.prototype=Object.create(y),A},A.awrap=function(A){return{__await:A}},k(p.prototype),o(p.prototype,n,(function(){return this})),A.AsyncIterator=p,A.async=function(e,t,i,r,I){void 0===I&&(I=Promise);var g=new p(B(e,t,i,r),I);return A.isGeneratorFunction(t)?g:g.next().then((function(A){return A.done?A.value:g.next()}))},k(y),o(y,a,\\\"Generator\\\"),o(y,g,(function(){return this})),o(y,\\\"toString\\\",(function(){return\\\"[object Generator]\\\"})),A.keys=function(A){var e=[];for(var t in A)e.push(t);return e.reverse(),function t(){for(;e.length;){var i=e.pop();if(i in A)return t.value=i,t.done=!1,t}return t.done=!0,t}},A.values=v,S.prototype={constructor:S,reset:function(A){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method=\\\"next\\\",this.arg=e,this.tryEntries.forEach(F),!A)for(var t in this)\\\"t\\\"===t.charAt(0)&&r.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=e)},stop:function(){this.done=!0;var A=this.tryEntries[0].completion;if(\\\"throw\\\"===A.type)throw A.arg;return this.rval},dispatchException:function(A){if(this.done)throw A;var t=this;function i(i,r){return n.type=\\\"throw\\\",n.arg=A,t.next=i,r&&(t.method=\\\"next\\\",t.arg=e),!!r}for(var I=this.tryEntries.length-1;I>=0;--I){var g=this.tryEntries[I],n=g.completion;if(\\\"root\\\"===g.tryLoc)return i(\\\"end\\\");if(g.tryLoc<=this.prev){var a=r.call(g,\\\"catchLoc\\\"),o=r.call(g,\\\"finallyLoc\\\");if(a&&o){if(this.prev<g.catchLoc)return i(g.catchLoc,!0);if(this.prev<g.finallyLoc)return i(g.finallyLoc)}else if(a){if(this.prev<g.catchLoc)return i(g.catchLoc,!0)}else{if(!o)throw new Error(\\\"try statement without catch or finally\\\");if(this.prev<g.finallyLoc)return i(g.finallyLoc)}}}},abrupt:function(A,e){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc<=this.prev&&r.call(i,\\\"finallyLoc\\\")&&this.prev<i.finallyLoc){var I=i;break}}I&&(\\\"break\\\"===A||\\\"continue\\\"===A)&&I.tryLoc<=e&&e<=I.finallyLoc&&(I=null);var g=I?I.completion:{};return g.type=A,g.arg=e,I?(this.method=\\\"next\\\",this.next=I.finallyLoc,c):this.complete(g)},complete:function(A,e){if(\\\"throw\\\"===A.type)throw A.arg;return\\\"break\\\"===A.type||\\\"continue\\\"===A.type?this.next=A.arg:\\\"return\\\"===A.type?(this.rval=this.arg=A.arg,this.method=\\\"return\\\",this.next=\\\"end\\\"):\\\"normal\\\"===A.type&&e&&(this.next=e),c},finish:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===A)return this.complete(t.completion,t.afterLoc),F(t),c}},catch:function(A){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===A){var i=t.completion;if(\\\"throw\\\"===i.type){var r=i.arg;F(t)}return r}}throw new Error(\\\"illegal catch attempt\\\")},delegateYield:function(A,t,i){return this.delegate={iterator:v(A),resultName:t,nextLoc:i},\\\"next\\\"===this.method&&(this.arg=e),c}},A}(A.exports);try{regeneratorRuntime=e}catch(A){\\\"object\\\"===(\\\"undefined\\\"==typeof globalThis?\\\"undefined\\\":t(globalThis))?globalThis.regeneratorRuntime=e:Function(\\\"r\\\",\\\"regeneratorRuntime = r\\\")(e)}}(i);var r=i.exports,I=new Map;function g(A,e){Array.isArray(A)||(A=[A]),A.forEach((function(A){return I.set(A,e)}))}function n(A){return a.apply(this,arguments)}function a(){return(a=e(r.mark((function A(e){var t,i;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:if(t=I.get(e.Compression)){A.next=3;break}throw new Error(\\\"Unknown compression method identifier: \\\".concat(e.Compression));case 3:return A.next=5,t();case 5:return i=A.sent,A.abrupt(\\\"return\\\",new i(e));case 7:case\\\"end\\\":return A.stop()}}),A)})))).apply(this,arguments)}g([void 0,1],(function(){return Promise.resolve().then((function(){return y})).then((function(A){return A.default}))})),g(5,(function(){return Promise.resolve().then((function(){return F})).then((function(A){return A.default}))})),g(6,(function(){throw new Error(\\\"old style JPEG compression is not supported.\\\")})),g(7,(function(){return Promise.resolve().then((function(){return N})).then((function(A){return A.default}))})),g([8,32946],(function(){return Promise.resolve().then((function(){return OA})).then((function(A){return A.default}))})),g(32773,(function(){return Promise.resolve().then((function(){return _A})).then((function(A){return A.default}))})),g(34887,(function(){return Promise.resolve().then((function(){return le})).then(function(){var A=e(r.mark((function A(e){return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,e.zstd.init();case 2:return A.abrupt(\\\"return\\\",e);case 3:case\\\"end\\\":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}()).then((function(A){return A.default}))})),g(50001,(function(){return Promise.resolve().then((function(){return de})).then((function(A){return A.default}))}));var o=globalThis;function B(A,e){if(!(A instanceof e))throw new TypeError(\\\"Cannot call a class as a function\\\")}function C(A,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,\\\"value\\\"in i&&(i.writable=!0),Object.defineProperty(A,i.key,i)}}function Q(A,e,t){return e&&C(A.prototype,e),t&&C(A,t),A}function E(A,e){return E=Object.setPrototypeOf||function(A,e){return A.__proto__=e,A},E(A,e)}function s(A,e){if(\\\"function\\\"!=typeof e&&null!==e)throw new TypeError(\\\"Super expression must either be null or a function\\\");A.prototype=Object.create(e&&e.prototype,{constructor:{value:A,writable:!0,configurable:!0}}),e&&E(A,e)}function f(A,e){if(e&&(\\\"object\\\"===t(e)||\\\"function\\\"==typeof e))return e;if(void 0!==e)throw new TypeError(\\\"Derived constructors may only return object or undefined\\\");return function(A){if(void 0===A)throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");return A}(A)}function c(A){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(A){return A.__proto__||Object.getPrototypeOf(A)},c(A)}function h(A,e){var t=A.length-e,i=0;do{for(var r=e;r>0;r--)A[i+e]+=A[i],i++;t-=e}while(t>0)}function l(A,e,t){for(var i=0,r=A.length,I=r/t;r>e;){for(var g=e;g>0;--g)A[i+e]+=A[i],++i;r-=e}for(var n=A.slice(),a=0;a<I;++a)for(var o=0;o<t;++o)A[t*a+o]=n[(t-o-1)*I+a]}function u(A,e,t,i,r,I){if(!e||1===e)return A;for(var g=0;g<r.length;++g){if(r[g]%8!=0)throw new Error(\\\"When decoding with predictor, only multiple of 8 bits are supported.\\\");if(r[g]!==r[0])throw new Error(\\\"When decoding with predictor, all samples must have the same size.\\\")}for(var n=r[0]/8,a=2===I?1:r.length,o=0;o<i&&!(o*a*t*n>=A.byteLength);++o){var B=void 0;if(2===e){switch(r[0]){case 8:B=new Uint8Array(A,o*a*t*n,a*t*n);break;case 16:B=new Uint16Array(A,o*a*t*n,a*t*n/2);break;case 32:B=new Uint32Array(A,o*a*t*n,a*t*n/4);break;default:throw new Error(\\\"Predictor 2 not allowed with \\\".concat(r[0],\\\" bits per sample.\\\"))}h(B,a)}else 3===e&&l(B=new Uint8Array(A,o*a*t*n,a*t*n),a,n)}return A}o.addEventListener(\\\"message\\\",function(){var A=e(r.mark((function A(e){var t,i,I,g,a,B;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return t=e.data,i=t.id,I=t.fileDirectory,g=t.buffer,A.next=3,n(I);case 3:return a=A.sent,A.next=6,a.decode(I,g);case 6:B=A.sent,o.postMessage({decoded:B,id:i},[B]);case 8:case\\\"end\\\":return A.stop()}}),A)})));return function(e){return A.apply(this,arguments)}}());var w=function(){function A(){B(this,A)}var t;return Q(A,[{key:\\\"decode\\\",value:(t=e(r.mark((function A(e,t){var i,I,g,n,a;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return A.next=2,this.decodeBlock(t);case 2:if(i=A.sent,1===(I=e.Predictor||1)){A.next=9;break}return g=!e.StripOffsets,n=g?e.TileWidth:e.ImageWidth,a=g?e.TileLength:e.RowsPerStrip||e.ImageLength,A.abrupt(\\\"return\\\",u(i,I,n,a,e.BitsPerSample,e.PlanarConfiguration));case 9:return A.abrupt(\\\"return\\\",i);case 10:case\\\"end\\\":return A.stop()}}),A,this)}))),function(A,e){return t.apply(this,arguments)})}]),A}();function d(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var D=function(A){s(t,w);var e=d(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return A}}]),t}(),y=Object.freeze({__proto__:null,default:D});function k(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}function p(A,e){for(var t=e.length-1;t>=0;t--)A.push(e[t]);return A}function m(A){for(var e=new Uint16Array(4093),t=new Uint8Array(4093),i=0;i<=257;i++)e[i]=4096,t[i]=i;var r=258,I=9,g=0;function n(){r=258,I=9}function a(A){var e=function(A,e,t){var i=e%8,r=Math.floor(e/8),I=8-i,g=e+t-8*(r+1),n=8*(r+2)-(e+t),a=8*(r+2)-e;if(n=Math.max(0,n),r>=A.length)return console.warn(\\\"ran off the end of the buffer before finding EOI_CODE (end on input code)\\\"),257;var o=A[r]&Math.pow(2,8-i)-1,B=o<<=t-I;if(r+1<A.length){var C=A[r+1]>>>n;B+=C<<=Math.max(0,t-a)}if(g>8&&r+2<A.length){var Q=8*(r+3)-(e+t);B+=A[r+2]>>>Q}return B}(A,g,I);return g+=I,e}function o(A,i){return t[r]=i,e[r]=A,++r-1}function B(A){for(var i=[],r=A;4096!==r;r=e[r])i.push(t[r]);return i}var C=[];n();for(var Q,E=new Uint8Array(A),s=a(E);257!==s;){if(256===s){for(n(),s=a(E);256===s;)s=a(E);if(257===s)break;if(s>256)throw new Error(\\\"corrupted code at scanline \\\".concat(s));p(C,B(s)),Q=s}else if(s<r){var f=B(s);p(C,f),o(Q,f[f.length-1]),Q=s}else{var c=B(Q);if(!c)throw new Error(\\\"Bogus entry. Not in dictionary, \\\".concat(Q,\\\" / \\\").concat(r,\\\", position: \\\").concat(g));p(C,c),C.push(c[c.length-1]),o(Q,c[c.length-1]),Q=s}r+1>=Math.pow(2,I)&&(12===I?Q=void 0:I++),s=a(E)}return new Uint8Array(C)}var G=function(A){s(t,w);var e=k(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return m(A).buffer}}]),t}(),F=Object.freeze({__proto__:null,default:G});function S(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var v=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function R(A,e){for(var t=0,i=[],r=16;r>0&&!A[r-1];)--r;i.push({children:[],index:0});for(var I,g=i[0],n=0;n<r;n++){for(var a=0;a<A[n];a++){for((g=i.pop()).children[g.index]=e[t];g.index>0;)g=i.pop();for(g.index++,i.push(g);i.length<=n;)i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I;t++}n+1<r&&(i.push(I={children:[],index:0}),g.children[g.index]=I.children,g=I)}return i[0].children}function U(A,e,i,r,I,g,n,a,o){var B=i.mcusPerLine,C=i.progressive,Q=e,E=e,s=0,f=0;function c(){if(f>0)return f--,s>>f&1;if(255===(s=A[E++])){var e=A[E++];if(e)throw new Error(\\\"unexpected marker: \\\".concat((s<<8|e).toString(16)))}return f=7,s>>>7}function h(A){for(var e,i=A;null!==(e=c());){if(\\\"number\\\"==typeof(i=i[e]))return i;if(\\\"object\\\"!==t(i))throw new Error(\\\"invalid huffman sequence\\\")}return null}function l(A){for(var e=A,t=0;e>0;){var i=c();if(null===i)return;t=t<<1|i,--e}return t}function u(A){var e=l(A);return e>=1<<A-1?e:e+(-1<<A)+1}var w=0;var d,D=0;function y(A,e,t,i,r){var I=t%B,g=(t/B|0)*A.v+i,n=I*A.h+r;e(A,A.blocks[g][n])}function k(A,e,t){var i=t/A.blocksPerLine|0,r=t%A.blocksPerLine;e(A,A.blocks[i][r])}var p,m,G,F,S,R,U=r.length;R=C?0===g?0===a?function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t)<<o;A.pred+=i,e[0]=A.pred}:function(A,e){e[0]|=c()<<o}:0===a?function(A,e){if(w>0)w--;else for(var t=g,i=n;t<=i;){var r=h(A.huffmanTableAC),I=15&r,a=r>>4;if(0===I){if(a<15){w=l(a)+(1<<a)-1;break}t+=16}else e[v[t+=a]]=u(I)*(1<<o),t++}}:function(A,e){for(var t=g,i=n,r=0;t<=i;){var I=v[t],a=e[I]<0?-1:1;switch(D){case 0:var B=h(A.huffmanTableAC),C=15&B;if(r=B>>4,0===C)r<15?(w=l(r)+(1<<r),D=4):(r=16,D=1);else{if(1!==C)throw new Error(\\\"invalid ACn encoding\\\");d=u(C),D=r?2:3}continue;case 1:case 2:e[I]?e[I]+=(c()<<o)*a:0==--r&&(D=2===D?3:0);break;case 3:e[I]?e[I]+=(c()<<o)*a:(e[I]=d<<o,D=0);break;case 4:e[I]&&(e[I]+=(c()<<o)*a)}t++}4===D&&0==--w&&(D=0)}:function(A,e){var t=h(A.huffmanTableDC),i=0===t?0:u(t);A.pred+=i,e[0]=A.pred;for(var r=1;r<64;){var I=h(A.huffmanTableAC),g=15&I,n=I>>4;if(0===g){if(n<15)break;r+=16}else e[v[r+=n]]=u(g),r++}};var L,b,M=0;b=1===U?r[0].blocksPerLine*r[0].blocksPerColumn:B*i.mcusPerColumn;for(var N=I||b;M<b;){for(m=0;m<U;m++)r[m].pred=0;if(w=0,1===U)for(p=r[0],S=0;S<N;S++)k(p,R,M),M++;else for(S=0;S<N;S++){for(m=0;m<U;m++){var x=p=r[m],J=x.h,q=x.v;for(G=0;G<q;G++)for(F=0;F<J;F++)y(p,R,M,G,F)}if(++M===b)break}if(f=0,(L=A[E]<<8|A[E+1])<65280)throw new Error(\\\"marker was not found\\\");if(!(L>=65488&&L<=65495))break;E+=2}return E-Q}function L(A,e){var t=[],i=e.blocksPerLine,r=e.blocksPerColumn,I=i<<3,g=new Int32Array(64),n=new Uint8Array(64);function a(A,t,i){var r,I,g,n,a,o,B,C,Q,E,s=e.quantizationTable,f=i;for(E=0;E<64;E++)f[E]=A[E]*s[E];for(E=0;E<8;++E){var c=8*E;0!==f[1+c]||0!==f[2+c]||0!==f[3+c]||0!==f[4+c]||0!==f[5+c]||0!==f[6+c]||0!==f[7+c]?(r=5793*f[0+c]+128>>8,I=5793*f[4+c]+128>>8,g=f[2+c],n=f[6+c],a=2896*(f[1+c]-f[7+c])+128>>8,C=2896*(f[1+c]+f[7+c])+128>>8,o=f[3+c]<<4,Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+128>>8,g=1567*g-3784*n+128>>8,n=Q,Q=a-(B=f[5+c]<<4)+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+c]=r+C,f[7+c]=r-C,f[1+c]=I+B,f[6+c]=I-B,f[2+c]=g+o,f[5+c]=g-o,f[3+c]=n+a,f[4+c]=n-a):(Q=5793*f[0+c]+512>>10,f[0+c]=Q,f[1+c]=Q,f[2+c]=Q,f[3+c]=Q,f[4+c]=Q,f[5+c]=Q,f[6+c]=Q,f[7+c]=Q)}for(E=0;E<8;++E){var h=E;0!==f[8+h]||0!==f[16+h]||0!==f[24+h]||0!==f[32+h]||0!==f[40+h]||0!==f[48+h]||0!==f[56+h]?(r=5793*f[0+h]+2048>>12,I=5793*f[32+h]+2048>>12,g=f[16+h],n=f[48+h],a=2896*(f[8+h]-f[56+h])+2048>>12,C=2896*(f[8+h]+f[56+h])+2048>>12,o=f[24+h],Q=r-I+1>>1,r=r+I+1>>1,I=Q,Q=3784*g+1567*n+2048>>12,g=1567*g-3784*n+2048>>12,n=Q,Q=a-(B=f[40+h])+1>>1,a=a+B+1>>1,B=Q,Q=C+o+1>>1,o=C-o+1>>1,C=Q,Q=r-n+1>>1,r=r+n+1>>1,n=Q,Q=I-g+1>>1,I=I+g+1>>1,g=Q,Q=2276*a+3406*C+2048>>12,a=3406*a-2276*C+2048>>12,C=Q,Q=799*o+4017*B+2048>>12,o=4017*o-799*B+2048>>12,B=Q,f[0+h]=r+C,f[56+h]=r-C,f[8+h]=I+B,f[48+h]=I-B,f[16+h]=g+o,f[40+h]=g-o,f[24+h]=n+a,f[32+h]=n-a):(Q=5793*i[E+0]+8192>>14,f[0+h]=Q,f[8+h]=Q,f[16+h]=Q,f[24+h]=Q,f[32+h]=Q,f[40+h]=Q,f[48+h]=Q,f[56+h]=Q)}for(E=0;E<64;++E){var l=128+(f[E]+8>>4);t[E]=l<0?0:l>255?255:l}}for(var o=0;o<r;o++){for(var B=o<<3,C=0;C<8;C++)t.push(new Uint8Array(I));for(var Q=0;Q<i;Q++){a(e.blocks[o][Q],n,g);for(var E=0,s=Q<<3,f=0;f<8;f++)for(var c=t[B+f],h=0;h<8;h++)c[s+h]=n[E++]}}return t}var b=function(){function A(){B(this,A),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return Q(A,[{key:\\\"resetFrames\\\",value:function(){this.frames=[]}},{key:\\\"parse\\\",value:function(A){var e=0;function t(){var t=A[e]<<8|A[e+1];return e+=2,t}function i(A){var e,t,i=0,r=0;for(t in A.components)A.components.hasOwnProperty(t)&&(i<(e=A.components[t]).h&&(i=e.h),r<e.v&&(r=e.v));var I=Math.ceil(A.samplesPerLine/8/i),g=Math.ceil(A.scanLines/8/r);for(t in A.components)if(A.components.hasOwnProperty(t)){e=A.components[t];for(var n=Math.ceil(Math.ceil(A.samplesPerLine/8)*e.h/i),a=Math.ceil(Math.ceil(A.scanLines/8)*e.v/r),o=I*e.h,B=g*e.v,C=[],Q=0;Q<B;Q++){for(var E=[],s=0;s<o;s++)E.push(new Int32Array(64));C.push(E)}e.blocksPerLine=n,e.blocksPerColumn=a,e.blocks=C}A.maxH=i,A.maxV=r,A.mcusPerLine=I,A.mcusPerColumn=g}var r,I,g=t();if(65496!==g)throw new Error(\\\"SOI not found\\\");for(g=t();65497!==g;){switch(g){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var n=(r=void 0,I=void 0,r=t(),I=A.subarray(e,e+r-2),e+=I.length,I);65504===g&&74===n[0]&&70===n[1]&&73===n[2]&&70===n[3]&&0===n[4]&&(this.jfif={version:{major:n[5],minor:n[6]},densityUnits:n[7],xDensity:n[8]<<8|n[9],yDensity:n[10]<<8|n[11],thumbWidth:n[12],thumbHeight:n[13],thumbData:n.subarray(14,14+3*n[12]*n[13])}),65518===g&&65===n[0]&&100===n[1]&&111===n[2]&&98===n[3]&&101===n[4]&&0===n[5]&&(this.adobe={version:n[6],flags0:n[7]<<8|n[8],flags1:n[9]<<8|n[10],transformCode:n[11]});break;case 65499:for(var a=t()+e-2;e<a;){var o=A[e++],B=new Int32Array(64);if(o>>4==0)for(var C=0;C<64;C++){B[v[C]]=A[e++]}else{if(o>>4!=1)throw new Error(\\\"DQT: invalid table spec\\\");for(var Q=0;Q<64;Q++){B[v[Q]]=t()}}this.quantizationTables[15&o]=B}break;case 65472:case 65473:case 65474:t();for(var E={extended:65473===g,progressive:65474===g,precision:A[e++],scanLines:t(),samplesPerLine:t(),components:{},componentsOrder:[]},s=A[e++],f=void 0,c=0;c<s;c++){f=A[e];var h=A[e+1]>>4,l=15&A[e+1],u=A[e+2];E.componentsOrder.push(f),E.components[f]={h:h,v:l,quantizationIdx:u},e+=3}i(E),this.frames.push(E);break;case 65476:for(var w=t(),d=2;d<w;){for(var D=A[e++],y=new Uint8Array(16),k=0,p=0;p<16;p++,e++)y[p]=A[e],k+=y[p];for(var m=new Uint8Array(k),G=0;G<k;G++,e++)m[G]=A[e];d+=17+k,D>>4==0?this.huffmanTablesDC[15&D]=R(y,m):this.huffmanTablesAC[15&D]=R(y,m)}break;case 65501:t(),this.resetInterval=t();break;case 65498:t();for(var F=A[e++],S=[],L=this.frames[0],b=0;b<F;b++){var M=L.components[A[e++]],N=A[e++];M.huffmanTableDC=this.huffmanTablesDC[N>>4],M.huffmanTableAC=this.huffmanTablesAC[15&N],S.push(M)}var x=A[e++],J=A[e++],q=A[e++],Y=U(A,e,L,S,this.resetInterval,x,J,q>>4,15&q);e+=Y;break;case 65535:255!==A[e]&&e--;break;default:if(255===A[e-3]&&A[e-2]>=192&&A[e-2]<=254){e-=3;break}throw new Error(\\\"unknown JPEG marker \\\".concat(g.toString(16)))}g=t()}}},{key:\\\"getResult\\\",value:function(){var A=this.frames;if(0===this.frames.length)throw new Error(\\\"no frames were decoded\\\");this.frames.length>1&&console.warn(\\\"more than one frame is not supported\\\");for(var e=0;e<this.frames.length;e++)for(var t=this.frames[e].components,i=0,r=Object.keys(t);i<r.length;i++){var I=r[i];t[I].quantizationTable=this.quantizationTables[t[I].quantizationIdx],delete t[I].quantizationIdx}for(var g=A[0],n=g.components,a=g.componentsOrder,o=[],B=g.samplesPerLine,C=g.scanLines,Q=0;Q<a.length;Q++){var E=n[a[Q]];o.push({lines:L(0,E),scaleX:E.h/g.maxH,scaleY:E.v/g.maxV})}for(var s=new Uint8Array(B*C*o.length),f=0,c=0;c<C;++c)for(var h=0;h<B;++h)for(var l=0;l<o.length;++l){var u=o[l];s[f]=u.lines[0|c*u.scaleY][0|h*u.scaleX],++f}return s}}]),A}(),M=function(A){s(t,w);var e=S(t);function t(A){var i;return B(this,t),(i=e.call(this)).reader=new b,A.JPEGTables&&i.reader.parse(A.JPEGTables),i}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(A)),this.reader.getResult().buffer}}]),t}(),N=Object.freeze({__proto__:null,default:M});function x(A){for(var e=A.length;--e>=0;)A[e]=0}x(new Array(576)),x(new Array(60)),x(new Array(512)),x(new Array(256)),x(new Array(29)),x(new Array(30));var J=function(A,e,t,i){for(var r=65535&A|0,I=A>>>16&65535|0,g=0;0!==t;){t-=g=t>2e3?2e3:t;do{I=I+(r=r+e[i++]|0)|0}while(--g);r%=65521,I%=65521}return r|I<<16|0},q=new Uint32Array(function(){for(var A,e=[],t=0;t<256;t++){A=t;for(var i=0;i<8;i++)A=1&A?3988292384^A>>>1:A>>>1;e[t]=A}return e}()),Y=function(A,e,t,i){var r=q,I=i+t;A^=-1;for(var g=i;g<I;g++)A=A>>>8^r[255&(A^e[g])];return-1^A},K={2:\\\"need dictionary\\\",1:\\\"stream end\\\",0:\\\"\\\",\\\"-1\\\":\\\"file error\\\",\\\"-2\\\":\\\"stream error\\\",\\\"-3\\\":\\\"data error\\\",\\\"-4\\\":\\\"insufficient memory\\\",\\\"-5\\\":\\\"buffer error\\\",\\\"-6\\\":\\\"incompatible version\\\"},H={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},O=function(A,e){return Object.prototype.hasOwnProperty.call(A,e)},P=function(A){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var i=e.shift();if(i){if(\\\"object\\\"!==t(i))throw new TypeError(i+\\\"must be non-object\\\");for(var r in i)O(i,r)&&(A[r]=i[r])}}return A},T=function(A){for(var e=0,t=0,i=A.length;t<i;t++)e+=A[t].length;for(var r=new Uint8Array(e),I=0,g=0,n=A.length;I<n;I++){var a=A[I];r.set(a,g),g+=a.length}return r},V=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(A){V=!1}for(var _=new Uint8Array(256),X=0;X<256;X++)_[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;_[254]=_[254]=1;var Z=function(A){if(\\\"function\\\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(A);var e,t,i,r,I,g=A.length,n=0;for(r=0;r<g;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),n+=t<128?1:t<2048?2:t<65536?3:4;for(e=new Uint8Array(n),I=0,r=0;I<n;r++)55296==(64512&(t=A.charCodeAt(r)))&&r+1<g&&56320==(64512&(i=A.charCodeAt(r+1)))&&(t=65536+(t-55296<<10)+(i-56320),r++),t<128?e[I++]=t:t<2048?(e[I++]=192|t>>>6,e[I++]=128|63&t):t<65536?(e[I++]=224|t>>>12,e[I++]=128|t>>>6&63,e[I++]=128|63&t):(e[I++]=240|t>>>18,e[I++]=128|t>>>12&63,e[I++]=128|t>>>6&63,e[I++]=128|63&t);return e},j=function(A,e){var t,i,r=e||A.length;if(\\\"function\\\"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(A.subarray(0,e));var I=new Array(2*r);for(i=0,t=0;t<r;){var g=A[t++];if(g<128)I[i++]=g;else{var n=_[g];if(n>4)I[i++]=65533,t+=n-1;else{for(g&=2===n?31:3===n?15:7;n>1&&t<r;)g=g<<6|63&A[t++],n--;n>1?I[i++]=65533:g<65536?I[i++]=g:(g-=65536,I[i++]=55296|g>>10&1023,I[i++]=56320|1023&g)}}}return function(A,e){if(e<65534&&A.subarray&&V)return String.fromCharCode.apply(null,A.length===e?A:A.subarray(0,e));for(var t=\\\"\\\",i=0;i<e;i++)t+=String.fromCharCode(A[i]);return t}(I,i)},W=function(A,e){(e=e||A.length)>A.length&&(e=A.length);for(var t=e-1;t>=0&&128==(192&A[t]);)t--;return t<0||0===t?e:t+_[A[t]]>e?t:e};var z=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\\\"\\\",this.state=null,this.data_type=2,this.adler=0},$=function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=A.state;t=A.next_in,k=A.input,i=t+(A.avail_in-5),r=A.next_out,p=A.output,I=r-(e-A.avail_out),g=r+(A.avail_out-257),n=m.dmax,a=m.wsize,o=m.whave,B=m.wnext,C=m.window,Q=m.hold,E=m.bits,s=m.lencode,f=m.distcode,c=(1<<m.lenbits)-1,h=(1<<m.distbits)-1;A:do{E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=s[Q&c];e:for(;;){if(Q>>>=u=l>>>24,E-=u,0===(u=l>>>16&255))p[r++]=65535&l;else{if(!(16&u)){if(0==(64&u)){l=s[(65535&l)+(Q&(1<<u)-1)];continue e}if(32&u){m.mode=12;break A}A.msg=\\\"invalid literal/length code\\\",m.mode=30;break A}w=65535&l,(u&=15)&&(E<u&&(Q+=k[t++]<<E,E+=8),w+=Q&(1<<u)-1,Q>>>=u,E-=u),E<15&&(Q+=k[t++]<<E,E+=8,Q+=k[t++]<<E,E+=8),l=f[Q&h];t:for(;;){if(Q>>>=u=l>>>24,E-=u,!(16&(u=l>>>16&255))){if(0==(64&u)){l=f[(65535&l)+(Q&(1<<u)-1)];continue t}A.msg=\\\"invalid distance code\\\",m.mode=30;break A}if(d=65535&l,E<(u&=15)&&(Q+=k[t++]<<E,(E+=8)<u&&(Q+=k[t++]<<E,E+=8)),(d+=Q&(1<<u)-1)>n){A.msg=\\\"invalid distance too far back\\\",m.mode=30;break A}if(Q>>>=u,E-=u,d>(u=r-I)){if((u=d-u)>o&&m.sane){A.msg=\\\"invalid distance too far back\\\",m.mode=30;break A}if(D=0,y=C,0===B){if(D+=a-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}else if(B<u){if(D+=a+B-u,(u-=B)<w){w-=u;do{p[r++]=C[D++]}while(--u);if(D=0,B<w){w-=u=B;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}}}else if(D+=B-u,u<w){w-=u;do{p[r++]=C[D++]}while(--u);D=r-d,y=p}for(;w>2;)p[r++]=y[D++],p[r++]=y[D++],p[r++]=y[D++],w-=3;w&&(p[r++]=y[D++],w>1&&(p[r++]=y[D++]))}else{D=r-d;do{p[r++]=p[D++],p[r++]=p[D++],p[r++]=p[D++],w-=3}while(w>2);w&&(p[r++]=p[D++],w>1&&(p[r++]=p[D++]))}break}}break}}while(t<i&&r<g);t-=w=E>>3,Q&=(1<<(E-=w<<3))-1,A.next_in=t,A.next_out=r,A.avail_in=t<i?i-t+5:5-(t-i),A.avail_out=r<g?g-r+257:257-(r-g),m.hold=Q,m.bits=E},AA=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),eA=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),tA=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),iA=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),rA=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E,s,f,c,h=n.bits,l=0,u=0,w=0,d=0,D=0,y=0,k=0,p=0,m=0,G=0,F=null,S=0,v=new Uint16Array(16),R=new Uint16Array(16),U=null,L=0;for(l=0;l<=15;l++)v[l]=0;for(u=0;u<i;u++)v[e[t+u]]++;for(D=h,d=15;d>=1&&0===v[d];d--);if(D>d&&(D=d),0===d)return r[I++]=20971520,r[I++]=20971520,n.bits=1,0;for(w=1;w<d&&0===v[w];w++);for(D<w&&(D=w),p=1,l=1;l<=15;l++)if(p<<=1,(p-=v[l])<0)return-1;if(p>0&&(0===A||1!==d))return-1;for(R[1]=0,l=1;l<15;l++)R[l+1]=R[l]+v[l];for(u=0;u<i;u++)0!==e[t+u]&&(g[R[e[t+u]]++]=u);if(0===A?(F=U=g,E=19):1===A?(F=AA,S-=257,U=eA,L-=257,E=256):(F=tA,U=iA,E=-1),G=0,u=0,l=w,Q=I,y=D,k=0,B=-1,C=(m=1<<D)-1,1===A&&m>852||2===A&&m>592)return 1;for(;;){s=l-k,g[u]<E?(f=0,c=g[u]):g[u]>E?(f=U[L+g[u]],c=F[S+g[u]]):(f=96,c=0),a=1<<l-k,w=o=1<<y;do{r[Q+(G>>k)+(o-=a)]=s<<24|f<<16|c|0}while(0!==o);for(a=1<<l-1;G&a;)a>>=1;if(0!==a?(G&=a-1,G+=a):G=0,u++,0==--v[l]){if(l===d)break;l=e[t+g[u]]}if(l>D&&(G&C)!==B){for(0===k&&(k=D),Q+=w,p=1<<(y=l-k);y+k<d&&!((p-=v[y+k])<=0);)y++,p<<=1;if(m+=1<<y,1===A&&m>852||2===A&&m>592)return 1;r[B=G&C]=D<<24|y<<16|Q-I|0}}return 0!==G&&(r[Q+G]=l-k<<24|64<<16|0),n.bits=D,0},IA=H.Z_FINISH,gA=H.Z_BLOCK,nA=H.Z_TREES,aA=H.Z_OK,oA=H.Z_STREAM_END,BA=H.Z_NEED_DICT,CA=H.Z_STREAM_ERROR,QA=H.Z_DATA_ERROR,EA=H.Z_MEM_ERROR,sA=H.Z_BUF_ERROR,fA=H.Z_DEFLATED,cA=function(A){return(A>>>24&255)+(A>>>8&65280)+((65280&A)<<8)+((255&A)<<24)};function hA(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var lA,uA,wA=function(A){if(!A||!A.state)return CA;var e=A.state;return A.total_in=A.total_out=e.total=0,A.msg=\\\"\\\",e.wrap&&(A.adler=1&e.wrap),e.mode=1,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new Int32Array(852),e.distcode=e.distdyn=new Int32Array(592),e.sane=1,e.back=-1,aA},dA=function(A){if(!A||!A.state)return CA;var e=A.state;return e.wsize=0,e.whave=0,e.wnext=0,wA(A)},DA=function(A,e){var t;if(!A||!A.state)return CA;var i=A.state;return e<0?(t=0,e=-e):(t=1+(e>>4),e<48&&(e&=15)),e&&(e<8||e>15)?CA:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=t,i.wbits=e,dA(A))},yA=function(A,e){if(!A)return CA;var t=new hA;A.state=t,t.window=null;var i=DA(A,e);return i!==aA&&(A.state=null),i},kA=!0,pA=function(A){if(kA){lA=new Int32Array(512),uA=new Int32Array(32);for(var e=0;e<144;)A.lens[e++]=8;for(;e<256;)A.lens[e++]=9;for(;e<280;)A.lens[e++]=7;for(;e<288;)A.lens[e++]=8;for(rA(1,A.lens,0,288,lA,0,A.work,{bits:9}),e=0;e<32;)A.lens[e++]=5;rA(2,A.lens,0,32,uA,0,A.work,{bits:5}),kA=!1}A.lencode=lA,A.lenbits=9,A.distcode=uA,A.distbits=5},mA=function(A,e,t,i){var r,I=A.state;return null===I.window&&(I.wsize=1<<I.wbits,I.wnext=0,I.whave=0,I.window=new Uint8Array(I.wsize)),i>=I.wsize?(I.window.set(e.subarray(t-I.wsize,t),0),I.wnext=0,I.whave=I.wsize):((r=I.wsize-I.wnext)>i&&(r=i),I.window.set(e.subarray(t-i,t-i+r),I.wnext),(i-=r)?(I.window.set(e.subarray(t-i,t),0),I.wnext=i,I.whave=I.wsize):(I.wnext+=r,I.wnext===I.wsize&&(I.wnext=0),I.whave<I.wsize&&(I.whave+=r))),0},GA={inflateReset:dA,inflateReset2:DA,inflateResetKeep:wA,inflateInit:function(A){return yA(A,15)},inflateInit2:yA,inflate:function(A,e){var t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c,h,l,u,w,d,D,y,k,p,m=0,G=new Uint8Array(4),F=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!A||!A.state||!A.output||!A.input&&0!==A.avail_in)return CA;12===(t=A.state).mode&&(t.mode=13),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,C=n,Q=a,y=aA;A:for(;;)switch(t.mode){case 1:if(0===t.wrap){t.mode=13;break}for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(2&t.wrap&&35615===o){t.check=0,G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0),o=0,B=0,t.mode=2;break}if(t.flags=0,t.head&&(t.head.done=!1),!(1&t.wrap)||(((255&o)<<8)+(o>>8))%31){A.msg=\\\"incorrect header check\\\",t.mode=30;break}if((15&o)!==fA){A.msg=\\\"unknown compression method\\\",t.mode=30;break}if(B-=4,D=8+(15&(o>>>=4)),0===t.wbits)t.wbits=D;else if(D>t.wbits){A.msg=\\\"invalid window size\\\",t.mode=30;break}t.dmax=1<<t.wbits,A.adler=t.check=1,t.mode=512&o?10:12,o=0,B=0;break;case 2:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.flags=o,(255&t.flags)!==fA){A.msg=\\\"unknown compression method\\\",t.mode=30;break}if(57344&t.flags){A.msg=\\\"unknown header flags set\\\",t.mode=30;break}t.head&&(t.head.text=o>>8&1),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=3;case 3:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.time=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,G[2]=o>>>16&255,G[3]=o>>>24&255,t.check=Y(t.check,G,4,0)),o=0,B=0,t.mode=4;case 4:for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.head&&(t.head.xflags=255&o,t.head.os=o>>8),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0,t.mode=5;case 5:if(1024&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length=o,t.head&&(t.head.extra_len=o),512&t.flags&&(G[0]=255&o,G[1]=o>>>8&255,t.check=Y(t.check,G,2,0)),o=0,B=0}else t.head&&(t.head.extra=null);t.mode=6;case 6:if(1024&t.flags&&((E=t.length)>n&&(E=n),E&&(t.head&&(D=t.head.extra_len-t.length,t.head.extra||(t.head.extra=new Uint8Array(t.head.extra_len)),t.head.extra.set(i.subarray(I,I+E),D)),512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,t.length-=E),t.length))break A;t.length=0,t.mode=7;case 7:if(2048&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.name+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.name=null);t.length=0,t.mode=8;case 8:if(4096&t.flags){if(0===n)break A;E=0;do{D=i[I+E++],t.head&&D&&t.length<65536&&(t.head.comment+=String.fromCharCode(D))}while(D&&E<n);if(512&t.flags&&(t.check=Y(t.check,i,E,I)),n-=E,I+=E,D)break A}else t.head&&(t.head.comment=null);t.mode=9;case 9:if(512&t.flags){for(;B<16;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(65535&t.check)){A.msg=\\\"header crc mismatch\\\",t.mode=30;break}o=0,B=0}t.head&&(t.head.hcrc=t.flags>>9&1,t.head.done=!0),A.adler=t.check=0,t.mode=12;break;case 10:for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}A.adler=t.check=cA(o),o=0,B=0,t.mode=11;case 11:if(0===t.havedict)return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,BA;A.adler=t.check=1,t.mode=12;case 12:if(e===gA||e===nA)break A;case 13:if(t.last){o>>>=7&B,B-=7&B,t.mode=27;break}for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}switch(t.last=1&o,B-=1,3&(o>>>=1)){case 0:t.mode=14;break;case 1:if(pA(t),t.mode=20,e===nA){o>>>=2,B-=2;break A}break;case 2:t.mode=17;break;case 3:A.msg=\\\"invalid block type\\\",t.mode=30}o>>>=2,B-=2;break;case 14:for(o>>>=7&B,B-=7&B;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if((65535&o)!=(o>>>16^65535)){A.msg=\\\"invalid stored block lengths\\\",t.mode=30;break}if(t.length=65535&o,o=0,B=0,t.mode=15,e===nA)break A;case 15:t.mode=16;case 16:if(E=t.length){if(E>n&&(E=n),E>a&&(E=a),0===E)break A;r.set(i.subarray(I,I+E),g),n-=E,I+=E,a-=E,g+=E,t.length-=E;break}t.mode=12;break;case 17:for(;B<14;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(t.nlen=257+(31&o),o>>>=5,B-=5,t.ndist=1+(31&o),o>>>=5,B-=5,t.ncode=4+(15&o),o>>>=4,B-=4,t.nlen>286||t.ndist>30){A.msg=\\\"too many length or distance symbols\\\",t.mode=30;break}t.have=0,t.mode=18;case 18:for(;t.have<t.ncode;){for(;B<3;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.lens[F[t.have++]]=7&o,o>>>=3,B-=3}for(;t.have<19;)t.lens[F[t.have++]]=0;if(t.lencode=t.lendyn,t.lenbits=7,k={bits:t.lenbits},y=rA(0,t.lens,0,19,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg=\\\"invalid code lengths set\\\",t.mode=30;break}t.have=0,t.mode=19;case 19:for(;t.have<t.nlen+t.ndist;){for(;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(l<16)o>>>=c,B-=c,t.lens[t.have++]=l;else{if(16===l){for(p=c+2;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o>>>=c,B-=c,0===t.have){A.msg=\\\"invalid bit length repeat\\\",t.mode=30;break}D=t.lens[t.have-1],E=3+(3&o),o>>>=2,B-=2}else if(17===l){for(p=c+3;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=3+(7&(o>>>=c)),o>>>=3,B-=3}else{for(p=c+7;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}B-=c,D=0,E=11+(127&(o>>>=c)),o>>>=7,B-=7}if(t.have+E>t.nlen+t.ndist){A.msg=\\\"invalid bit length repeat\\\",t.mode=30;break}for(;E--;)t.lens[t.have++]=D}}if(30===t.mode)break;if(0===t.lens[256]){A.msg=\\\"invalid code -- missing end-of-block\\\",t.mode=30;break}if(t.lenbits=9,k={bits:t.lenbits},y=rA(1,t.lens,0,t.nlen,t.lencode,0,t.work,k),t.lenbits=k.bits,y){A.msg=\\\"invalid literal/lengths set\\\",t.mode=30;break}if(t.distbits=6,t.distcode=t.distdyn,k={bits:t.distbits},y=rA(2,t.lens,t.nlen,t.ndist,t.distcode,0,t.work,k),t.distbits=k.bits,y){A.msg=\\\"invalid distances set\\\",t.mode=30;break}if(t.mode=20,e===nA)break A;case 20:t.mode=21;case 21:if(n>=6&&a>=258){A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,$(A,Q),g=A.next_out,r=A.output,a=A.avail_out,I=A.next_in,i=A.input,n=A.avail_in,o=t.hold,B=t.bits,12===t.mode&&(t.back=-1);break}for(t.back=0;h=(m=t.lencode[o&(1<<t.lenbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(h&&0==(240&h)){for(u=c,w=h,d=l;h=(m=t.lencode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,t.length=l,0===h){t.mode=26;break}if(32&h){t.back=-1,t.mode=12;break}if(64&h){A.msg=\\\"invalid literal/length code\\\",t.mode=30;break}t.extra=15&h,t.mode=22;case 22:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.length+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}t.was=t.length,t.mode=23;case 23:for(;h=(m=t.distcode[o&(1<<t.distbits)-1])>>>16&255,l=65535&m,!((c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(0==(240&h)){for(u=c,w=h,d=l;h=(m=t.distcode[d+((o&(1<<u+w)-1)>>u)])>>>16&255,l=65535&m,!(u+(c=m>>>24)<=B);){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}o>>>=u,B-=u,t.back+=u}if(o>>>=c,B-=c,t.back+=c,64&h){A.msg=\\\"invalid distance code\\\",t.mode=30;break}t.offset=l,t.extra=15&h,t.mode=24;case 24:if(t.extra){for(p=t.extra;B<p;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}t.offset+=o&(1<<t.extra)-1,o>>>=t.extra,B-=t.extra,t.back+=t.extra}if(t.offset>t.dmax){A.msg=\\\"invalid distance too far back\\\",t.mode=30;break}t.mode=25;case 25:if(0===a)break A;if(E=Q-a,t.offset>E){if((E=t.offset-E)>t.whave&&t.sane){A.msg=\\\"invalid distance too far back\\\",t.mode=30;break}E>t.wnext?(E-=t.wnext,s=t.wsize-E):s=t.wnext-E,E>t.length&&(E=t.length),f=t.window}else f=r,s=g-t.offset,E=t.length;E>a&&(E=a),a-=E,t.length-=E;do{r[g++]=f[s++]}while(--E);0===t.length&&(t.mode=21);break;case 26:if(0===a)break A;r[g++]=t.length,a--,t.mode=21;break;case 27:if(t.wrap){for(;B<32;){if(0===n)break A;n--,o|=i[I++]<<B,B+=8}if(Q-=a,A.total_out+=Q,t.total+=Q,Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,g-Q):J(t.check,r,Q,g-Q)),Q=a,(t.flags?o:cA(o))!==t.check){A.msg=\\\"incorrect data check\\\",t.mode=30;break}o=0,B=0}t.mode=28;case 28:if(t.wrap&&t.flags){for(;B<32;){if(0===n)break A;n--,o+=i[I++]<<B,B+=8}if(o!==(4294967295&t.total)){A.msg=\\\"incorrect length check\\\",t.mode=30;break}o=0,B=0}t.mode=29;case 29:y=oA;break A;case 30:y=QA;break A;case 31:return EA;default:return CA}return A.next_out=g,A.avail_out=a,A.next_in=I,A.avail_in=n,t.hold=o,t.bits=B,(t.wsize||Q!==A.avail_out&&t.mode<30&&(t.mode<27||e!==IA))&&mA(A,A.output,A.next_out,Q-A.avail_out),C-=A.avail_in,Q-=A.avail_out,A.total_in+=C,A.total_out+=Q,t.total+=Q,t.wrap&&Q&&(A.adler=t.check=t.flags?Y(t.check,r,Q,A.next_out-Q):J(t.check,r,Q,A.next_out-Q)),A.data_type=t.bits+(t.last?64:0)+(12===t.mode?128:0)+(20===t.mode||15===t.mode?256:0),(0===C&&0===Q||e===IA)&&y===aA&&(y=sA),y},inflateEnd:function(A){if(!A||!A.state)return CA;var e=A.state;return e.window&&(e.window=null),A.state=null,aA},inflateGetHeader:function(A,e){if(!A||!A.state)return CA;var t=A.state;return 0==(2&t.wrap)?CA:(t.head=e,e.done=!1,aA)},inflateSetDictionary:function(A,e){var t,i=e.length;return A&&A.state?0!==(t=A.state).wrap&&11!==t.mode?CA:11===t.mode&&J(1,e,i,0)!==t.check?QA:mA(A,e,i,i)?(t.mode=31,EA):(t.havedict=1,aA):CA},inflateInfo:\\\"pako inflate (from Nodeca project)\\\"};var FA=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\\\"\\\",this.comment=\\\"\\\",this.hcrc=0,this.done=!1},SA=Object.prototype.toString,vA=H.Z_NO_FLUSH,RA=H.Z_FINISH,UA=H.Z_OK,LA=H.Z_STREAM_END,bA=H.Z_NEED_DICT,MA=H.Z_STREAM_ERROR,NA=H.Z_DATA_ERROR,xA=H.Z_MEM_ERROR;function JA(A){this.options=P({chunkSize:65536,windowBits:15,to:\\\"\\\"},A||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||A&&A.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\\\"\\\",this.ended=!1,this.chunks=[],this.strm=new z,this.strm.avail_out=0;var t=GA.inflateInit2(this.strm,e.windowBits);if(t!==UA)throw new Error(K[t]);if(this.header=new FA,GA.inflateGetHeader(this.strm,this.header),e.dictionary&&(\\\"string\\\"==typeof e.dictionary?e.dictionary=Z(e.dictionary):\\\"[object ArrayBuffer]\\\"===SA.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)),e.raw&&(t=GA.inflateSetDictionary(this.strm,e.dictionary))!==UA))throw new Error(K[t])}function qA(A,e){var t=new JA(e);if(t.push(A),t.err)throw t.msg||K[t.err];return t.result}JA.prototype.push=function(A,e){var t,i,r,I=this.strm,g=this.options.chunkSize,n=this.options.dictionary;if(this.ended)return!1;for(i=e===~~e?e:!0===e?RA:vA,\\\"[object ArrayBuffer]\\\"===SA.call(A)?I.input=new Uint8Array(A):I.input=A,I.next_in=0,I.avail_in=I.input.length;;){for(0===I.avail_out&&(I.output=new Uint8Array(g),I.next_out=0,I.avail_out=g),(t=GA.inflate(I,i))===bA&&n&&((t=GA.inflateSetDictionary(I,n))===UA?t=GA.inflate(I,i):t===NA&&(t=bA));I.avail_in>0&&t===LA&&I.state.wrap>0&&0!==A[I.next_in];)GA.inflateReset(I),t=GA.inflate(I,i);switch(t){case MA:case NA:case bA:case xA:return this.onEnd(t),this.ended=!0,!1}if(r=I.avail_out,I.next_out&&(0===I.avail_out||t===LA))if(\\\"string\\\"===this.options.to){var a=W(I.output,I.next_out),o=I.next_out-a,B=j(I.output,a);I.next_out=o,I.avail_out=g-o,o&&I.output.set(I.output.subarray(a,a+o),0),this.onData(B)}else this.onData(I.output.length===I.next_out?I.output:I.output.subarray(0,I.next_out));if(t!==UA||0!==r){if(t===LA)return t=GA.inflateEnd(this.strm),this.onEnd(t),this.ended=!0,!0;if(0===I.avail_in)break}}return!0},JA.prototype.onData=function(A){this.chunks.push(A)},JA.prototype.onEnd=function(A){A===UA&&(\\\"string\\\"===this.options.to?this.result=this.chunks.join(\\\"\\\"):this.result=T(this.chunks)),this.chunks=[],this.err=A,this.msg=this.strm.msg};var YA={Inflate:JA,inflate:qA,inflateRaw:function(A,e){return(e=e||{}).raw=!0,qA(A,e)},ungzip:qA,constants:H}.inflate;function KA(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var HA=function(A){s(t,w);var e=KA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){return YA(new Uint8Array(A)).buffer}}]),t}(),OA=Object.freeze({__proto__:null,default:HA});function PA(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var TA,VA=function(A){s(t,w);var e=PA(t);function t(){return B(this,t),e.apply(this,arguments)}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){for(var e=new DataView(A),t=[],i=0;i<A.byteLength;++i){var r=e.getInt8(i);if(r<0){var I=e.getUint8(i+1);r=-r;for(var g=0;g<=r;++g)t.push(I);i+=1}else{for(var n=0;n<=r;++n)t.push(e.getUint8(i+n+1));i+=r+1}}return new Uint8Array(t).buffer}}]),t}(),_A=Object.freeze({__proto__:null,default:VA}),XA={exports:{}};TA=XA,\\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\\nfunction(){var A,e,t,i,r,I,g,n,a,o,B,C,Q,E,s,f,c=(A={defaultNoDataValue:-34027999387901484e22,decode:function(I,g){var n=(g=g||{}).encodedMaskData||null===g.encodedMaskData,a=r(I,g.inputOffset||0,n),o=null!==g.noDataValue?g.noDataValue:A.defaultNoDataValue,B=e(a,g.pixelType||Float32Array,g.encodedMaskData,o,g.returnMask),C={width:a.width,height:a.height,pixelData:B.resultPixels,minValue:B.minValue,maxValue:a.pixels.maxValue,noDataValue:o};return B.resultMask&&(C.maskData=B.resultMask),g.returnEncodedMask&&a.mask&&(C.encodedMaskData=a.mask.bitset?a.mask.bitset:null),g.returnFileInfo&&(C.fileInfo=t(a),g.computeUsedBitDepths&&(C.fileInfo.bitDepths=i(a))),C}},e=function(A,e,t,i,r){var g,n,a,o=0,B=A.pixels.numBlocksX,C=A.pixels.numBlocksY,Q=Math.floor(A.width/B),E=Math.floor(A.height/C),s=2*A.maxZError,f=Number.MAX_VALUE;t=t||(A.mask?A.mask.bitset:null),n=new e(A.width*A.height),r&&t&&(a=new Uint8Array(A.width*A.height));for(var c,h,l=new Float32Array(Q*E),u=0;u<=C;u++){var w=u!==C?E:A.height%C;if(0!==w)for(var d=0;d<=B;d++){var D=d!==B?Q:A.width%B;if(0!==D){var y,k,p,m,G=u*A.width*E+d*Q,F=A.width-D,S=A.pixels.blocks[o];if(S.encoding<2?(0===S.encoding?y=S.rawData:(I(S.stuffedData,S.bitsPerPixel,S.numValidPixels,S.offset,s,l,A.pixels.maxValue),y=l),k=0):p=2===S.encoding?0:S.offset,t)for(h=0;h<w;h++){for(7&G&&(m=t[G>>3],m<<=7&G),c=0;c<D;c++)7&G||(m=t[G>>3]),128&m?(a&&(a[G]=1),f=f>(g=S.encoding<2?y[k++]:p)?g:f,n[G++]=g):(a&&(a[G]=0),n[G++]=i),m<<=1;G+=F}else if(S.encoding<2)for(h=0;h<w;h++){for(c=0;c<D;c++)f=f>(g=y[k++])?g:f,n[G++]=g;G+=F}else for(f=f>p?p:f,h=0;h<w;h++){for(c=0;c<D;c++)n[G++]=p;G+=F}if(1===S.encoding&&k!==S.numValidPixels)throw\\\"Block and Mask do not match\\\";o++}}}return{resultPixels:n,resultMask:a,minValue:f}},t=function(A){return{fileIdentifierString:A.fileIdentifierString,fileVersion:A.fileVersion,imageType:A.imageType,height:A.height,width:A.width,maxZError:A.maxZError,eofOffset:A.eofOffset,mask:A.mask?{numBlocksX:A.mask.numBlocksX,numBlocksY:A.mask.numBlocksY,numBytes:A.mask.numBytes,maxValue:A.mask.maxValue}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,numBytes:A.pixels.numBytes,maxValue:A.pixels.maxValue,noDataValue:A.noDataValue}}},i=function(A){for(var e=A.pixels.numBlocksX*A.pixels.numBlocksY,t={},i=0;i<e;i++){var r=A.pixels.blocks[i];0===r.encoding?t.float32=!0:1===r.encoding?t[r.bitsPerPixel]=!0:t[0]=!0}return Object.keys(t)},r=function(A,e,t){var i={},r=new Uint8Array(A,e,10);if(i.fileIdentifierString=String.fromCharCode.apply(null,r),\\\"CntZImage\\\"!==i.fileIdentifierString.trim())throw\\\"Unexpected file identifier string: \\\"+i.fileIdentifierString;e+=10;var I=new DataView(A,e,24);if(i.fileVersion=I.getInt32(0,!0),i.imageType=I.getInt32(4,!0),i.height=I.getUint32(8,!0),i.width=I.getUint32(12,!0),i.maxZError=I.getFloat64(16,!0),e+=24,!t)if(I=new DataView(A,e,16),i.mask={},i.mask.numBlocksY=I.getUint32(0,!0),i.mask.numBlocksX=I.getUint32(4,!0),i.mask.numBytes=I.getUint32(8,!0),i.mask.maxValue=I.getFloat32(12,!0),e+=16,i.mask.numBytes>0){var g=new Uint8Array(Math.ceil(i.width*i.height/8)),n=(I=new DataView(A,e,i.mask.numBytes)).getInt16(0,!0),a=2,o=0;do{if(n>0)for(;n--;)g[o++]=I.getUint8(a++);else{var B=I.getUint8(a++);for(n=-n;n--;)g[o++]=B}n=I.getInt16(a,!0),a+=2}while(a<i.mask.numBytes);if(-32768!==n||o<g.length)throw\\\"Unexpected end of mask RLE encoding\\\";i.mask.bitset=g,e+=i.mask.numBytes}else 0==(i.mask.numBytes|i.mask.numBlocksY|i.mask.maxValue)&&(i.mask.bitset=new Uint8Array(Math.ceil(i.width*i.height/8)));I=new DataView(A,e,16),i.pixels={},i.pixels.numBlocksY=I.getUint32(0,!0),i.pixels.numBlocksX=I.getUint32(4,!0),i.pixels.numBytes=I.getUint32(8,!0),i.pixels.maxValue=I.getFloat32(12,!0),e+=16;var C=i.pixels.numBlocksX,Q=i.pixels.numBlocksY,E=C+(i.width%C>0?1:0),s=Q+(i.height%Q>0?1:0);i.pixels.blocks=new Array(E*s);for(var f=0,c=0;c<s;c++)for(var h=0;h<E;h++){var l=0,u=A.byteLength-e;I=new DataView(A,e,Math.min(10,u));var w={};i.pixels.blocks[f++]=w;var d=I.getUint8(0);if(l++,w.encoding=63&d,w.encoding>3)throw\\\"Invalid block encoding (\\\"+w.encoding+\\\")\\\";if(2!==w.encoding){if(0!==d&&2!==d){if(d>>=6,w.offsetType=d,2===d)w.offset=I.getInt8(1),l++;else if(1===d)w.offset=I.getInt16(1,!0),l+=2;else{if(0!==d)throw\\\"Invalid block offset type\\\";w.offset=I.getFloat32(1,!0),l+=4}if(1===w.encoding)if(d=I.getUint8(l),l++,w.bitsPerPixel=63&d,d>>=6,w.numValidPixelsType=d,2===d)w.numValidPixels=I.getUint8(l),l++;else if(1===d)w.numValidPixels=I.getUint16(l,!0),l+=2;else{if(0!==d)throw\\\"Invalid valid pixel count type\\\";w.numValidPixels=I.getUint32(l,!0),l+=4}}var D;if(e+=l,3!==w.encoding)if(0===w.encoding){var y=(i.pixels.numBytes-1)/4;if(y!==Math.floor(y))throw\\\"uncompressed block has invalid length\\\";D=new ArrayBuffer(4*y),new Uint8Array(D).set(new Uint8Array(A,e,4*y));var k=new Float32Array(D);w.rawData=k,e+=4*y}else if(1===w.encoding){var p=Math.ceil(w.numValidPixels*w.bitsPerPixel/8),m=Math.ceil(p/4);D=new ArrayBuffer(4*m),new Uint8Array(D).set(new Uint8Array(A,e,p)),w.stuffedData=new Uint32Array(D),e+=p}}else e++}return i.eofOffset=e,i},I=function(A,e,t,i,r,I,g){var n,a,o,B=(1<<e)-1,C=0,Q=0,E=Math.ceil((g-i)/r),s=4*A.length-Math.ceil(e*t/8);for(A[A.length-1]<<=8*s,n=0;n<t;n++){if(0===Q&&(o=A[C++],Q=32),Q>=e)a=o>>>Q-e&B,Q-=e;else{var f=e-Q;a=(o&B)<<f&B,a+=(o=A[C++])>>>(Q=32-f)}I[n]=a<E?i+a*r:g}return I},A),h=(g=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q,E=(1<<t)-1,s=0,f=0,c=4*A.length-Math.ceil(t*i/8);if(A[A.length-1]<<=8*c,r)for(a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=r[o];else for(Q=Math.ceil((n-I)/g),a=0;a<i;a++)0===f&&(B=A[s++],f=32),f>=t?(o=B>>>f-t&E,f-=t):(o=(B&E)<<(C=t-f)&E,o+=(B=A[s++])>>>(f=32-C)),e[a]=o<Q?I+o*g:n},n=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=[],s=4*A.length-Math.ceil(e*t/8);A[A.length-1]<<=8*s;var f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32),C>=e?(Q=g>>>C-e&n,C-=e):(Q=(g&n)<<(B=e-C)&n,Q+=(g=A[a++])>>>(C=32-B)),E[o]=Q<f?i+Q*r:I;return E.unshift(i),E},a=function(A,e,t,i,r,I,g,n){var a,o,B,C,Q=(1<<t)-1,E=0,s=0,f=0;if(r)for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=r[o];else{var c=Math.ceil((n-I)/g);for(a=0;a<i;a++)0===s&&(B=A[E++],s=32,f=0),s>=t?(o=B>>>f&Q,s-=t,f+=t):(o=B>>>f&Q,s=32-(C=t-s),o|=((B=A[E++])&(1<<C)-1)<<t-C,f=C),e[a]=o<c?I+o*g:n}return e},o=function(A,e,t,i,r,I){var g,n=(1<<e)-1,a=0,o=0,B=0,C=0,Q=0,E=0,s=[],f=Math.ceil((I-i)/r);for(o=0;o<t;o++)0===C&&(g=A[a++],C=32,E=0),C>=e?(Q=g>>>E&n,C-=e,E+=e):(Q=g>>>E&n,C=32-(B=e-C),Q|=((g=A[a++])&(1<<B)-1)<<e-B,E=B),s[o]=Q<f?i+Q*r:I;return s.unshift(i),s},B=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=4*A.length-Math.ceil(t*i/8);for(A[A.length-1]<<=8*C,r=0;r<i;r++)0===B&&(g=A[o++],B=32),B>=t?(I=g>>>B-t&a,B-=t):(I=(g&a)<<(n=t-B)&a,I+=(g=A[o++])>>>(B=32-n)),e[r]=I;return e},C=function(A,e,t,i){var r,I,g,n,a=(1<<t)-1,o=0,B=0,C=0;for(r=0;r<i;r++)0===B&&(g=A[o++],B=32,C=0),B>=t?(I=g>>>C&a,B-=t,C+=t):(I=g>>>C&a,B=32-(n=t-B),I|=((g=A[o++])&(1<<n)-1)<<t-n,C=n),e[r]=I;return e},Q={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(A){for(var e=65535,t=65535,i=A.length,r=Math.floor(i/2),I=0;r;){var g=r>=359?359:r;r-=g;do{e+=A[I++]<<8,t+=e+=A[I++]}while(--g);e=(65535&e)+(e>>>16),t=(65535&t)+(t>>>16)}return 1&i&&(t+=e+=A[I]<<8),((t=(65535&t)+(t>>>16))<<16|(e=(65535&e)+(e>>>16)))>>>0},readHeaderInfo:function(A,e){var t=e.ptr,i=new Uint8Array(A,t,6),r={};if(r.fileIdentifierString=String.fromCharCode.apply(null,i),0!==r.fileIdentifierString.lastIndexOf(\\\"Lerc2\\\",0))throw\\\"Unexpected file identifier string (expect Lerc2 ): \\\"+r.fileIdentifierString;t+=6;var I,g=new DataView(A,t,8),n=g.getInt32(0,!0);if(r.fileVersion=n,t+=4,n>=3&&(r.checksum=g.getUint32(4,!0),t+=4),g=new DataView(A,t,12),r.height=g.getUint32(0,!0),r.width=g.getUint32(4,!0),t+=8,n>=4?(r.numDims=g.getUint32(8,!0),t+=4):r.numDims=1,g=new DataView(A,t,40),r.numValidPixel=g.getUint32(0,!0),r.microBlockSize=g.getInt32(4,!0),r.blobSize=g.getInt32(8,!0),r.imageType=g.getInt32(12,!0),r.maxZError=g.getFloat64(16,!0),r.zMin=g.getFloat64(24,!0),r.zMax=g.getFloat64(32,!0),t+=40,e.headerInfo=r,e.ptr=t,n>=3&&(I=n>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(A,t-I,r.blobSize-14))!==r.checksum))throw\\\"Checksum failed.\\\";return!0},checkMinMaxRanges:function(A,e){var t=e.headerInfo,i=this.getDataTypeArray(t.imageType),r=t.numDims*this.getDataTypeSize(t.imageType),I=this.readSubArray(A,e.ptr,i,r),g=this.readSubArray(A,e.ptr+r,i,r);e.ptr+=2*r;var n,a=!0;for(n=0;n<t.numDims;n++)if(I[n]!==g[n]){a=!1;break}return t.minValues=I,t.maxValues=g,a},readSubArray:function(A,e,t,i){var r;if(t===Uint8Array)r=new Uint8Array(A,e,i);else{var I=new ArrayBuffer(i);new Uint8Array(I).set(new Uint8Array(A,e,i)),r=new t(I)}return r},readMask:function(A,e){var t,i,r=e.ptr,I=e.headerInfo,g=I.width*I.height,n=I.numValidPixel,a=new DataView(A,r,4),o={};if(o.numBytes=a.getUint32(0,!0),r+=4,(0===n||g===n)&&0!==o.numBytes)throw\\\"invalid mask\\\";if(0===n)t=new Uint8Array(Math.ceil(g/8)),o.bitset=t,i=new Uint8Array(g),e.pixels.resultMask=i,r+=o.numBytes;else if(o.numBytes>0){t=new Uint8Array(Math.ceil(g/8));var B=(a=new DataView(A,r,o.numBytes)).getInt16(0,!0),C=2,Q=0,E=0;do{if(B>0)for(;B--;)t[Q++]=a.getUint8(C++);else for(E=a.getUint8(C++),B=-B;B--;)t[Q++]=E;B=a.getInt16(C,!0),C+=2}while(C<o.numBytes);if(-32768!==B||Q<t.length)throw\\\"Unexpected end of mask RLE encoding\\\";i=new Uint8Array(g);var s=0,f=0;for(f=0;f<g;f++)7&f?(s=t[f>>3],s<<=7&f):s=t[f>>3],128&s&&(i[f]=1);e.pixels.resultMask=i,o.bitset=t,r+=o.numBytes}return e.ptr=r,e.mask=o,!0},readDataOneSweep:function(A,e,t,i){var r,I=e.ptr,g=e.headerInfo,n=g.numDims,a=g.width*g.height,o=g.imageType,B=g.numValidPixel*Q.getDataTypeSize(o)*n,C=e.pixels.resultMask;if(t===Uint8Array)r=new Uint8Array(A,I,B);else{var E=new ArrayBuffer(B);new Uint8Array(E).set(new Uint8Array(A,I,B)),r=new t(E)}if(r.length===a*n)e.pixels.resultPixels=i?Q.swapDimensionOrder(r,a,n,t,!0):r;else{e.pixels.resultPixels=new t(a*n);var s=0,f=0,c=0,h=0;if(n>1){if(i){for(f=0;f<a;f++)if(C[f])for(h=f,c=0;c<n;c++,h+=a)e.pixels.resultPixels[h]=r[s++]}else for(f=0;f<a;f++)if(C[f])for(h=f*n,c=0;c<n;c++)e.pixels.resultPixels[h+c]=r[s++]}else for(f=0;f<a;f++)C[f]&&(e.pixels.resultPixels[f]=r[s++])}return I+=B,e.ptr=I,!0},readHuffmanTree:function(A,e){var t=this.HUFFMAN_LUT_BITS_MAX,i=new DataView(A,e.ptr,16);if(e.ptr+=16,i.getInt32(0,!0)<2)throw\\\"unsupported Huffman version\\\";var r=i.getInt32(4,!0),I=i.getInt32(8,!0),g=i.getInt32(12,!0);if(I>=g)return!1;var n=new Uint32Array(g-I);Q.decodeBits(A,e,n);var a,o,B,C,s=[];for(a=I;a<g;a++)s[o=a-(a<r?0:r)]={first:n[a-I],second:null};var f=A.byteLength-e.ptr,c=Math.ceil(f/4),h=new ArrayBuffer(4*c);new Uint8Array(h).set(new Uint8Array(A,e.ptr,f));var l,u=new Uint32Array(h),w=0,d=0;for(l=u[0],a=I;a<g;a++)(C=s[o=a-(a<r?0:r)].first)>0&&(s[o].second=l<<w>>>32-C,32-w>=C?32===(w+=C)&&(w=0,l=u[++d]):(w+=C-32,l=u[++d],s[o].second|=l>>>32-w));var D=0,y=0,k=new E;for(a=0;a<s.length;a++)void 0!==s[a]&&(D=Math.max(D,s[a].first));y=D>=t?t:D;var p,m,G,F,S,v=[];for(a=I;a<g;a++)if((C=s[o=a-(a<r?0:r)].first)>0)if(p=[C,o],C<=y)for(m=s[o].second<<y-C,G=1<<y-C,B=0;B<G;B++)v[m|B]=p;else for(m=s[o].second,S=k,F=C-1;F>=0;F--)m>>>F&1?(S.right||(S.right=new E),S=S.right):(S.left||(S.left=new E),S=S.left),0!==F||S.val||(S.val=p[1]);return{decodeLut:v,numBitsLUTQick:y,numBitsLUT:D,tree:k,stuffedData:u,srcPtr:d,bitPos:w}},readHuffman:function(A,e,t,i){var r,I,g,n,a,o,B,C,E,s=e.headerInfo.numDims,f=e.headerInfo.height,c=e.headerInfo.width,h=c*f,l=this.readHuffmanTree(A,e),u=l.decodeLut,w=l.tree,d=l.stuffedData,D=l.srcPtr,y=l.bitPos,k=l.numBitsLUTQick,p=l.numBitsLUT,m=0===e.headerInfo.imageType?128:0,G=e.pixels.resultMask,F=0;y>0&&(D++,y=0);var S,v=d[D],R=1===e.encodeMode,U=new t(h*s),L=U;if(s<2||R){for(S=0;S<s;S++)if(s>1&&(L=new t(U.buffer,h*S,h),F=0),e.headerInfo.numValidPixel===c*f)for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(g+=B>0?F:o>0?L[C-c]:F,g&=255,L[C]=g,F=g):L[C]=g}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++,C++)if(G[C]){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,R?(B>0&&G[C-1]?g+=F:o>0&&G[C-c]?g+=L[C-c]:g+=F,g&=255,L[C]=g,F=g):L[C]=g}}else for(C=0,o=0;o<f;o++)for(B=0;B<c;B++)if(C=o*c+B,!G||G[C])for(S=0;S<s;S++,C+=h){if(I=0,a=n=v<<y>>>32-k,32-y<k&&(a=n|=d[D+1]>>>64-y-k),u[a])I=u[a][1],y+=u[a][0];else for(a=n=v<<y>>>32-p,32-y<p&&(a=n|=d[D+1]>>>64-y-p),r=w,E=0;E<p;E++)if(!(r=n>>>p-E-1&1?r.right:r.left).left&&!r.right){I=r.val,y=y+E+1;break}y>=32&&(y-=32,v=d[++D]),g=I-m,L[C]=g}e.ptr=e.ptr+4*(D+1)+(y>0?4:0),e.pixels.resultPixels=U,s>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(U,h,s,t))},decodeBits:function(A,e,t,i,r){var I=e.headerInfo,Q=I.fileVersion,E=0,s=A.byteLength-e.ptr>=5?5:A.byteLength-e.ptr,f=new DataView(A,e.ptr,s),c=f.getUint8(0);E++;var h=c>>6,l=0===h?4:3-h,u=(32&c)>0,w=31&c,d=0;if(1===l)d=f.getUint8(E),E++;else if(2===l)d=f.getUint16(E,!0),E+=2;else{if(4!==l)throw\\\"Invalid valid pixel count type\\\";d=f.getUint32(E,!0),E+=4}var D,y,k,p,m,G,F,S,v,R=2*I.maxZError,U=I.numDims>1?I.maxValues[r]:I.zMax;if(u){for(e.counter.lut++,S=f.getUint8(E),E++,p=Math.ceil((S-1)*w/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),k=new Uint8Array(y),e.ptr+=E,k.set(new Uint8Array(A,e.ptr,p)),F=new Uint32Array(y),e.ptr+=p,v=0;S-1>>>v;)v++;p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,G=Q>=3?o(F,w,S-1,i,R,U):n(F,w,S-1,i,R,U),Q>=3?a(D,t,v,d,G):g(D,t,v,d,G)}else e.counter.bitstuffer++,v=w,e.ptr+=E,v>0&&(p=Math.ceil(d*v/8),m=Math.ceil(p/4),y=new ArrayBuffer(4*m),(k=new Uint8Array(y)).set(new Uint8Array(A,e.ptr,p)),D=new Uint32Array(y),e.ptr+=p,Q>=3?null==i?C(D,t,v,d):a(D,t,v,d,!1,i,R,U):null==i?B(D,t,v,d):g(D,t,v,d,!1,i,R,U))},readTiles:function(A,e,t,i){var r=e.headerInfo,I=r.width,g=r.height,n=I*g,a=r.microBlockSize,o=r.imageType,B=Q.getDataTypeSize(o),C=Math.ceil(I/a),E=Math.ceil(g/a);e.pixels.numBlocksY=E,e.pixels.numBlocksX=C,e.pixels.ptr=0;var s,f,c,h,l,u,w,d,D,y,k=0,p=0,m=0,G=0,F=0,S=0,v=0,R=0,U=0,L=0,b=0,M=0,N=0,x=0,J=0,q=new t(a*a),Y=g%a||a,K=I%a||a,H=r.numDims,O=e.pixels.resultMask,P=e.pixels.resultPixels,T=r.fileVersion>=5?14:15,V=r.zMax;for(m=0;m<E;m++)for(F=m!==E-1?a:Y,G=0;G<C;G++)for(L=m*I*a+G*a,b=I-(S=G!==C-1?a:K),d=0;d<H;d++){if(H>1?(y=P,L=m*I*a+G*a,P=new t(e.pixels.resultPixels.buffer,n*d*B,n),V=r.maxValues[d]):y=null,v=A.byteLength-e.ptr,f={},J=0,R=(s=new DataView(A,e.ptr,Math.min(10,v))).getUint8(0),J++,D=r.fileVersion>=5?4&R:0,U=R>>6&255,(R>>2&T)!=(G*a>>3&T))throw\\\"integrity issue\\\";if(D&&0===d)throw\\\"integrity issue\\\";if((l=3&R)>3)throw e.ptr+=J,\\\"Invalid block encoding (\\\"+l+\\\")\\\";if(2!==l)if(0===l){if(D)throw\\\"integrity issue\\\";if(e.counter.uncompressed++,e.ptr+=J,M=(M=F*S*B)<(N=A.byteLength-e.ptr)?M:N,c=new ArrayBuffer(M%B==0?M:M+B-M%B),new Uint8Array(c).set(new Uint8Array(A,e.ptr,M)),h=new t(c),x=0,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=h[x++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=h[x++];L+=b}e.ptr+=x*B}else if(u=Q.getDataTypeUsed(D&&o<6?4:o,U),w=Q.getOnePixel(f,J,u,s),J+=Q.getDataTypeSize(u),3===l)if(e.ptr+=J,e.counter.constantoffset++,O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=D?Math.min(V,y[L]+w):w),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=D?Math.min(V,y[L]+w):w,L++;L+=b}else if(e.ptr+=J,Q.decodeBits(A,e,q,w,d),J=0,D)if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]+y[L]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L]=q[J++]+y[L],L++;L+=b}else if(O)for(k=0;k<F;k++){for(p=0;p<S;p++)O[L]&&(P[L]=q[J++]),L++;L+=b}else for(k=0;k<F;k++){for(p=0;p<S;p++)P[L++]=q[J++];L+=b}else{if(D)if(O)for(k=0;k<F;k++)for(p=0;p<S;p++)O[L]&&(P[L]=y[L]),L++;else for(k=0;k<F;k++)for(p=0;p<S;p++)P[L]=y[L],L++;e.counter.constant++,e.ptr+=J}}H>1&&!i&&(e.pixels.resultPixels=Q.swapDimensionOrder(e.pixels.resultPixels,n,H,t))},formatFileInfo:function(A){return{fileIdentifierString:A.headerInfo.fileIdentifierString,fileVersion:A.headerInfo.fileVersion,imageType:A.headerInfo.imageType,height:A.headerInfo.height,width:A.headerInfo.width,numValidPixel:A.headerInfo.numValidPixel,microBlockSize:A.headerInfo.microBlockSize,blobSize:A.headerInfo.blobSize,maxZError:A.headerInfo.maxZError,pixelType:Q.getPixelType(A.headerInfo.imageType),eofOffset:A.eofOffset,mask:A.mask?{numBytes:A.mask.numBytes}:null,pixels:{numBlocksX:A.pixels.numBlocksX,numBlocksY:A.pixels.numBlocksY,maxValue:A.headerInfo.zMax,minValue:A.headerInfo.zMin,noDataValue:A.noDataValue}}},constructConstantSurface:function(A,e){var t=A.headerInfo.zMax,i=A.headerInfo.zMin,r=A.headerInfo.maxValues,I=A.headerInfo.numDims,g=A.headerInfo.height*A.headerInfo.width,n=0,a=0,o=0,B=A.pixels.resultMask,C=A.pixels.resultPixels;if(B)if(I>1){if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)B[a]&&(C[o+a]=t);else for(a=0;a<g;a++)if(B[a])for(o=a*I,n=0;n<I;n++)C[o+I]=r[n]}else for(a=0;a<g;a++)B[a]&&(C[a]=t);else if(I>1&&i!==t)if(e)for(n=0;n<I;n++)for(o=n*g,t=r[n],a=0;a<g;a++)C[o+a]=t;else for(a=0;a<g;a++)for(o=a*I,n=0;n<I;n++)C[o+n]=r[n];else for(a=0;a<g*I;a++)C[a]=t},getDataTypeArray:function(A){var e;switch(A){case 0:e=Int8Array;break;case 1:e=Uint8Array;break;case 2:e=Int16Array;break;case 3:e=Uint16Array;break;case 4:e=Int32Array;break;case 5:e=Uint32Array;break;case 6:default:e=Float32Array;break;case 7:e=Float64Array}return e},getPixelType:function(A){var e;switch(A){case 0:e=\\\"S8\\\";break;case 1:e=\\\"U8\\\";break;case 2:e=\\\"S16\\\";break;case 3:e=\\\"U16\\\";break;case 4:e=\\\"S32\\\";break;case 5:e=\\\"U32\\\";break;case 6:default:e=\\\"F32\\\";break;case 7:e=\\\"F64\\\"}return e},isValidPixelValue:function(A,e){if(null==e)return!1;var t;switch(A){case 0:t=e>=-128&&e<=127;break;case 1:t=e>=0&&e<=255;break;case 2:t=e>=-32768&&e<=32767;break;case 3:t=e>=0&&e<=65536;break;case 4:t=e>=-2147483648&&e<=2147483647;break;case 5:t=e>=0&&e<=4294967296;break;case 6:t=e>=-34027999387901484e22&&e<=34027999387901484e22;break;case 7:t=e>=-17976931348623157e292&&e<=17976931348623157e292;break;default:t=!1}return t},getDataTypeSize:function(A){var e=0;switch(A){case 0:case 1:e=1;break;case 2:case 3:e=2;break;case 4:case 5:case 6:e=4;break;case 7:e=8;break;default:e=A}return e},getDataTypeUsed:function(A,e){var t=A;switch(A){case 2:case 4:t=A-e;break;case 3:case 5:t=A-2*e;break;case 6:t=0===e?A:1===e?2:1;break;case 7:t=0===e?A:A-2*e+1;break;default:t=A}return t},getOnePixel:function(A,e,t,i){var r=0;switch(t){case 0:r=i.getInt8(e);break;case 1:r=i.getUint8(e);break;case 2:r=i.getInt16(e,!0);break;case 3:r=i.getUint16(e,!0);break;case 4:r=i.getInt32(e,!0);break;case 5:r=i.getUInt32(e,!0);break;case 6:r=i.getFloat32(e,!0);break;case 7:r=i.getFloat64(e,!0);break;default:throw\\\"the decoder does not understand this pixel type\\\"}return r},swapDimensionOrder:function(A,e,t,i,r){var I=0,g=0,n=0,a=0,o=A;if(t>1)if(o=new i(e*t),r)for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[a]=A[g++];else for(I=0;I<e;I++)for(a=I,n=0;n<t;n++,a+=e)o[g++]=A[a];return o}},E=function(A,e,t){this.val=A,this.left=e,this.right=t},{decode:function(A,e){var t=(e=e||{}).noDataValue,i=0,r={};r.ptr=e.inputOffset||0,r.pixels={},Q.readHeaderInfo(A,r);var I=r.headerInfo,g=I.fileVersion,n=Q.getDataTypeArray(I.imageType);if(g>5)throw\\\"unsupported lerc version 2.\\\"+g;Q.readMask(A,r),I.numValidPixel===I.width*I.height||r.pixels.resultMask||(r.pixels.resultMask=e.maskData);var a=I.width*I.height;r.pixels.resultPixels=new n(a*I.numDims),r.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var o,B=!e.returnPixelInterleavedDims;if(0!==I.numValidPixel)if(I.zMax===I.zMin)Q.constructConstantSurface(r,B);else if(g>=4&&Q.checkMinMaxRanges(A,r))Q.constructConstantSurface(r,B);else{var C=new DataView(A,r.ptr,2),E=C.getUint8(0);if(r.ptr++,E)Q.readDataOneSweep(A,r,n,B);else if(g>1&&I.imageType<=1&&Math.abs(I.maxZError-.5)<1e-5){var s=C.getUint8(1);if(r.ptr++,r.encodeMode=s,s>2||g<4&&s>1)throw\\\"Invalid Huffman flag \\\"+s;s?Q.readHuffman(A,r,n,B):Q.readTiles(A,r,n,B)}else Q.readTiles(A,r,n,B)}r.eofOffset=r.ptr,e.inputOffset?(o=r.headerInfo.blobSize+e.inputOffset-r.ptr,Math.abs(o)>=1&&(r.eofOffset=e.inputOffset+r.headerInfo.blobSize)):(o=r.headerInfo.blobSize-r.ptr,Math.abs(o)>=1&&(r.eofOffset=r.headerInfo.blobSize));var f={width:I.width,height:I.height,pixelData:r.pixels.resultPixels,minValue:I.zMin,maxValue:I.zMax,validPixelCount:I.numValidPixel,dimCount:I.numDims,dimStats:{minValues:I.minValues,maxValues:I.maxValues},maskData:r.pixels.resultMask};if(r.pixels.resultMask&&Q.isValidPixelValue(I.imageType,t)){var c=r.pixels.resultMask;for(i=0;i<a;i++)c[i]||(f.pixelData[i]=t);f.noDataValue=t}return r.noDataValue=t,e.returnFileInfo&&(f.fileInfo=Q.formatFileInfo(r)),f},getBandCount:function(A){for(var e=0,t=0,i={ptr:0,pixels:{}};t<A.byteLength-58;)Q.readHeaderInfo(A,i),t+=i.headerInfo.blobSize,e++,i.ptr=t;return e}}),l=(s=new ArrayBuffer(4),f=new Uint8Array(s),new Uint32Array(s)[0]=1,1===f[0]),u={decode:function(A,e){if(!l)throw\\\"Big endian system is not supported.\\\";var t,i,r=(e=e||{}).inputOffset||0,I=new Uint8Array(A,r,10),g=String.fromCharCode.apply(null,I);if(\\\"CntZImage\\\"===g.trim())t=c,i=1;else{if(\\\"Lerc2\\\"!==g.substring(0,5))throw\\\"Unexpected file identifier string: \\\"+g;t=h,i=2}for(var n,a,o,B,C,Q,E=0,s=A.byteLength-10,f=[],u={width:0,height:0,pixels:[],pixelType:e.pixelType,mask:null,statistics:[]},w=0;r<s;){var d=t.decode(A,{inputOffset:r,encodedMaskData:n,maskData:o,returnMask:0===E,returnEncodedMask:0===E,returnFileInfo:!0,returnPixelInterleavedDims:e.returnPixelInterleavedDims,pixelType:e.pixelType||null,noDataValue:e.noDataValue||null});r=d.fileInfo.eofOffset,o=d.maskData,0===E&&(n=d.encodedMaskData,u.width=d.width,u.height=d.height,u.dimCount=d.dimCount||1,u.pixelType=d.pixelType||d.fileInfo.pixelType,u.mask=o),i>1&&(o&&f.push(o),d.fileInfo.mask&&d.fileInfo.mask.numBytes>0&&w++),E++,u.pixels.push(d.pixelData),u.statistics.push({minValue:d.minValue,maxValue:d.maxValue,noDataValue:d.noDataValue,dimStats:d.dimStats})}if(i>1&&w>1){for(Q=u.width*u.height,u.bandMasks=f,(o=new Uint8Array(Q)).set(f[0]),B=1;B<f.length;B++)for(a=f[B],C=0;C<Q;C++)o[C]=o[C]&a[C];u.maskData=o}return u}};TA.exports?TA.exports=u:this.Lerc=u}();var ZA,jA,WA,zA=XA.exports,$A={env:{emscripten_notify_memory_growth:function(A){WA=new Uint8Array(jA.exports.memory.buffer)}}},Ae=function(){function A(){B(this,A)}return Q(A,[{key:\\\"init\\\",value:function(){return ZA||(ZA=\\\"undefined\\\"!=typeof fetch?fetch(\\\"data:application/wasm;base64,\\\"+ee).then((function(A){return A.arrayBuffer()})).then((function(A){return WebAssembly.instantiate(A,$A)})).then(this._init):WebAssembly.instantiate(Buffer.from(ee,\\\"base64\\\"),$A).then(this._init))}},{key:\\\"_init\\\",value:function(A){jA=A.instance,$A.env.emscripten_notify_memory_growth(0)}},{key:\\\"decode\\\",value:function(A){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!jA)throw new Error(\\\"ZSTDDecoder: Await .init() before decoding.\\\");var t=A.byteLength,i=jA.exports.malloc(t);WA.set(A,i),e=e||Number(jA.exports.ZSTD_findDecompressedSize(i,t));var r=jA.exports.malloc(e),I=jA.exports.ZSTD_decompress(r,e,i,t),g=WA.slice(r,r+I);return jA.exports.free(i),jA.exports.free(r),g}}]),A}(),ee=\\\"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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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\\\",te={315:\\\"Artist\\\",258:\\\"BitsPerSample\\\",265:\\\"CellLength\\\",264:\\\"CellWidth\\\",320:\\\"ColorMap\\\",259:\\\"Compression\\\",33432:\\\"Copyright\\\",306:\\\"DateTime\\\",338:\\\"ExtraSamples\\\",266:\\\"FillOrder\\\",289:\\\"FreeByteCounts\\\",288:\\\"FreeOffsets\\\",291:\\\"GrayResponseCurve\\\",290:\\\"GrayResponseUnit\\\",316:\\\"HostComputer\\\",270:\\\"ImageDescription\\\",257:\\\"ImageLength\\\",256:\\\"ImageWidth\\\",271:\\\"Make\\\",281:\\\"MaxSampleValue\\\",280:\\\"MinSampleValue\\\",272:\\\"Model\\\",254:\\\"NewSubfileType\\\",274:\\\"Orientation\\\",262:\\\"PhotometricInterpretation\\\",284:\\\"PlanarConfiguration\\\",296:\\\"ResolutionUnit\\\",278:\\\"RowsPerStrip\\\",277:\\\"SamplesPerPixel\\\",305:\\\"Software\\\",279:\\\"StripByteCounts\\\",273:\\\"StripOffsets\\\",255:\\\"SubfileType\\\",263:\\\"Threshholding\\\",282:\\\"XResolution\\\",283:\\\"YResolution\\\",326:\\\"BadFaxLines\\\",327:\\\"CleanFaxData\\\",343:\\\"ClipPath\\\",328:\\\"ConsecutiveBadFaxLines\\\",433:\\\"Decode\\\",434:\\\"DefaultImageColor\\\",269:\\\"DocumentName\\\",336:\\\"DotRange\\\",321:\\\"HalftoneHints\\\",346:\\\"Indexed\\\",347:\\\"JPEGTables\\\",285:\\\"PageName\\\",297:\\\"PageNumber\\\",317:\\\"Predictor\\\",319:\\\"PrimaryChromaticities\\\",532:\\\"ReferenceBlackWhite\\\",339:\\\"SampleFormat\\\",340:\\\"SMinSampleValue\\\",341:\\\"SMaxSampleValue\\\",559:\\\"StripRowCounts\\\",330:\\\"SubIFDs\\\",292:\\\"T4Options\\\",293:\\\"T6Options\\\",325:\\\"TileByteCounts\\\",323:\\\"TileLength\\\",324:\\\"TileOffsets\\\",322:\\\"TileWidth\\\",301:\\\"TransferFunction\\\",318:\\\"WhitePoint\\\",344:\\\"XClipPathUnits\\\",286:\\\"XPosition\\\",529:\\\"YCbCrCoefficients\\\",531:\\\"YCbCrPositioning\\\",530:\\\"YCbCrSubSampling\\\",345:\\\"YClipPathUnits\\\",287:\\\"YPosition\\\",37378:\\\"ApertureValue\\\",40961:\\\"ColorSpace\\\",36868:\\\"DateTimeDigitized\\\",36867:\\\"DateTimeOriginal\\\",34665:\\\"Exif IFD\\\",36864:\\\"ExifVersion\\\",33434:\\\"ExposureTime\\\",41728:\\\"FileSource\\\",37385:\\\"Flash\\\",40960:\\\"FlashpixVersion\\\",33437:\\\"FNumber\\\",42016:\\\"ImageUniqueID\\\",37384:\\\"LightSource\\\",37500:\\\"MakerNote\\\",37377:\\\"ShutterSpeedValue\\\",37510:\\\"UserComment\\\",33723:\\\"IPTC\\\",34675:\\\"ICC Profile\\\",700:\\\"XMP\\\",42112:\\\"GDAL_METADATA\\\",42113:\\\"GDAL_NODATA\\\",34377:\\\"Photoshop\\\",33550:\\\"ModelPixelScale\\\",33922:\\\"ModelTiepoint\\\",34264:\\\"ModelTransformation\\\",34735:\\\"GeoKeyDirectory\\\",34736:\\\"GeoDoubleParams\\\",34737:\\\"GeoAsciiParams\\\",50674:\\\"LercParameters\\\"},ie={};for(var re in te)te.hasOwnProperty(re)&&(ie[te[re]]=parseInt(re,10));ie.BitsPerSample,ie.ExtraSamples,ie.SampleFormat,ie.StripByteCounts,ie.StripOffsets,ie.StripRowCounts,ie.TileByteCounts,ie.TileOffsets,ie.SubIFDs;var Ie={1:\\\"BYTE\\\",2:\\\"ASCII\\\",3:\\\"SHORT\\\",4:\\\"LONG\\\",5:\\\"RATIONAL\\\",6:\\\"SBYTE\\\",7:\\\"UNDEFINED\\\",8:\\\"SSHORT\\\",9:\\\"SLONG\\\",10:\\\"SRATIONAL\\\",11:\\\"FLOAT\\\",12:\\\"DOUBLE\\\",13:\\\"IFD\\\",16:\\\"LONG8\\\",17:\\\"SLONG8\\\",18:\\\"IFD8\\\"},ge={};for(var ne in Ie)Ie.hasOwnProperty(ne)&&(ge[Ie[ne]]=parseInt(ne,10));var ae=1,oe=0,Be=1,Ce=2,Qe={1024:\\\"GTModelTypeGeoKey\\\",1025:\\\"GTRasterTypeGeoKey\\\",1026:\\\"GTCitationGeoKey\\\",2048:\\\"GeographicTypeGeoKey\\\",2049:\\\"GeogCitationGeoKey\\\",2050:\\\"GeogGeodeticDatumGeoKey\\\",2051:\\\"GeogPrimeMeridianGeoKey\\\",2052:\\\"GeogLinearUnitsGeoKey\\\",2053:\\\"GeogLinearUnitSizeGeoKey\\\",2054:\\\"GeogAngularUnitsGeoKey\\\",2055:\\\"GeogAngularUnitSizeGeoKey\\\",2056:\\\"GeogEllipsoidGeoKey\\\",2057:\\\"GeogSemiMajorAxisGeoKey\\\",2058:\\\"GeogSemiMinorAxisGeoKey\\\",2059:\\\"GeogInvFlatteningGeoKey\\\",2060:\\\"GeogAzimuthUnitsGeoKey\\\",2061:\\\"GeogPrimeMeridianLongGeoKey\\\",2062:\\\"GeogTOWGS84GeoKey\\\",3072:\\\"ProjectedCSTypeGeoKey\\\",3073:\\\"PCSCitationGeoKey\\\",3074:\\\"ProjectionGeoKey\\\",3075:\\\"ProjCoordTransGeoKey\\\",3076:\\\"ProjLinearUnitsGeoKey\\\",3077:\\\"ProjLinearUnitSizeGeoKey\\\",3078:\\\"ProjStdParallel1GeoKey\\\",3079:\\\"ProjStdParallel2GeoKey\\\",3080:\\\"ProjNatOriginLongGeoKey\\\",3081:\\\"ProjNatOriginLatGeoKey\\\",3082:\\\"ProjFalseEastingGeoKey\\\",3083:\\\"ProjFalseNorthingGeoKey\\\",3084:\\\"ProjFalseOriginLongGeoKey\\\",3085:\\\"ProjFalseOriginLatGeoKey\\\",3086:\\\"ProjFalseOriginEastingGeoKey\\\",3087:\\\"ProjFalseOriginNorthingGeoKey\\\",3088:\\\"ProjCenterLongGeoKey\\\",3089:\\\"ProjCenterLatGeoKey\\\",3090:\\\"ProjCenterEastingGeoKey\\\",3091:\\\"ProjCenterNorthingGeoKey\\\",3092:\\\"ProjScaleAtNatOriginGeoKey\\\",3093:\\\"ProjScaleAtCenterGeoKey\\\",3094:\\\"ProjAzimuthAngleGeoKey\\\",3095:\\\"ProjStraightVertPoleLongGeoKey\\\",3096:\\\"ProjRectifiedGridAngleGeoKey\\\",4096:\\\"VerticalCSTypeGeoKey\\\",4097:\\\"VerticalCitationGeoKey\\\",4098:\\\"VerticalDatumGeoKey\\\",4099:\\\"VerticalUnitsGeoKey\\\"},Ee={};for(var se in Qe)Qe.hasOwnProperty(se)&&(Ee[Qe[se]]=parseInt(se,10));function fe(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var ce=new Ae,he=function(A){s(t,w);var e=fe(t);function t(A){var i;return B(this,t),(i=e.call(this)).planarConfiguration=void 0!==A.PlanarConfiguration?A.PlanarConfiguration:1,i.samplesPerPixel=void 0!==A.SamplesPerPixel?A.SamplesPerPixel:1,i.addCompression=A.LercParameters[ae],i}return Q(t,[{key:\\\"decodeBlock\\\",value:function(A){switch(this.addCompression){case oe:break;case Be:A=YA(new Uint8Array(A)).buffer;break;case Ce:A=ce.decode(new Uint8Array(A)).buffer;break;default:throw new Error(\\\"Unsupported LERC additional compression method identifier: \\\".concat(this.addCompression))}return zA.decode(A,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),t}(),le=Object.freeze({__proto__:null,zstd:ce,default:he});function ue(A){var e=function(){if(\\\"undefined\\\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\\\"function\\\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(A){return!1}}();return function(){var t,i=c(A);if(e){var r=c(this).constructor;t=Reflect.construct(i,arguments,r)}else t=i.apply(this,arguments);return f(this,t)}}var we=function(A){s(I,w);var t,i=ue(I);function I(){var A;if(B(this,I),A=i.call(this),\\\"undefined\\\"==typeof createImageBitmap)throw new Error(\\\"Cannot decode WebImage as `createImageBitmap` is not available\\\");if(\\\"undefined\\\"==typeof document&&\\\"undefined\\\"==typeof OffscreenCanvas)throw new Error(\\\"Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available\\\");return A}return Q(I,[{key:\\\"decode\\\",value:(t=e(r.mark((function A(e,t){var i,I,g,n;return r.wrap((function(A){for(;;)switch(A.prev=A.next){case 0:return i=new Blob([t]),A.next=3,createImageBitmap(i);case 3:return I=A.sent,\\\"undefined\\\"!=typeof document?((g=document.createElement(\\\"canvas\\\")).width=I.width,g.height=I.height):g=new OffscreenCanvas(I.width,I.height),(n=g.getContext(\\\"2d\\\")).drawImage(I,0,0),A.abrupt(\\\"return\\\",n.getImageData(0,0,I.width,I.height).data.buffer);case 8:case\\\"end\\\":return A.stop()}}),A)}))),function(A,e){return t.apply(this,arguments)})}]),I}(),de=Object.freeze({__proto__:null,default:we});\";\n          return new web_worker__WEBPACK_IMPORTED_MODULE_0__[\"default\"](typeof Buffer !== 'undefined' \n            ? 'data:application/javascript;base64,' + Buffer.from(source, 'binary').toString('base64')\n            : URL.createObjectURL(new Blob([source], {type: 'application/javascript'})));\n        }\n      \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS93b3JrZXIvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxRQUF3QztBQUN4QyxRQUFlO0FBQ2Ysb0RBQW9ELElBQUksd0JBQXdCLFNBQVMsaUJBQWlCLHlDQUF5QyxjQUFjLGtCQUFrQix1QkFBdUIsa0NBQWtDLG1CQUFtQixjQUFjLHdCQUF3QixjQUFjLHlCQUF5QixVQUFVLElBQUksY0FBYyxxRkFBcUYsZ0JBQWdCLGFBQWEsd0dBQXdHLE1BQU0sT0FBTyxZQUFZLGFBQWEsa0JBQWtCLG1GQUFtRix3R0FBd0csa0JBQWtCLGtDQUFrQyxrREFBa0QsT0FBTyxJQUFJLElBQUksT0FBTyxTQUFTLGtCQUFrQixlQUFlLG9CQUFvQixrRkFBa0YsaUNBQWlDLFFBQVEscUJBQXFCLDJEQUEyRCxVQUFVLHlCQUF5QixXQUFXLHdCQUF3QixFQUFFLGlCQUFpQixNQUFNLGFBQWEsTUFBTSxrQkFBa0IsVUFBVSw0Q0FBNEMsOEJBQThCLHlCQUF5QiwyQkFBMkIsc0RBQXNELElBQUksZUFBZSx3QkFBd0IsbUNBQW1DLE9BQU8seUJBQXlCLDJEQUEyRCxVQUFVLGtCQUFrQixJQUFJLE9BQU8saUNBQWlDLFNBQVMsT0FBTyx1QkFBdUIsU0FBUyxtRkFBbUYsY0FBYyxjQUFjLGNBQWMsU0FBUyxrQkFBa0IsWUFBWSxHQUFHLDZDQUE2Qyw2QkFBNkIsK0NBQStDLGNBQWMscURBQXFELG1CQUFtQix5QkFBeUIsR0FBRyxHQUFHLGdCQUFnQixvQkFBb0Isa0JBQWtCLHVCQUF1QixzQkFBc0IsMEZBQTBGLGtCQUFrQixlQUFlLG1CQUFtQixrQ0FBa0MsZUFBZSxlQUFlLDBCQUEwQixHQUFHLFNBQVMsTUFBTSwyQkFBMkIsYUFBYSw0QkFBNEIsV0FBVyxHQUFHLDRCQUE0QixnQkFBZ0IsMkJBQTJCLFVBQVUseUNBQXlDLHlGQUF5RiwyRkFBMkYsU0FBUyw0QkFBNEIsOEVBQThFLFlBQVksbU9BQW1P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QUFxRSxrSkFBa0osUUFBUSxnTkFBZ04sT0FBTyxxRUFBcUUsNEJBQTRCLGkrQ0FBaStDLE9BQU8scUVBQXFFLGVBQWUsaUJBQWlCLDhEQUE4RCxtQ0FBbUMsdUNBQXVDLElBQUksZ0ZBQWdGLE9BQU8sU0FBUyxVQUFVLEdBQUcsa0JBQWtCLGFBQWEsTUFBTSwwQkFBMEIsbUNBQW1DLCtCQUErQixrQkFBa0IsNkJBQTZCLE9BQU8sWUFBWSxjQUFjLE1BQU0sc05BQXNOLGFBQWEsc0NBQXNDLDRCQUE0QixjQUFjLHVDQUF1QyxNQUFNLDhDQUE4QyxNQUFNLHFIQUFxSCxvQkFBb0Isd0RBQXdELG9CQUFvQixLQUFLLHFCQUFxQixrQ0FBa0MsRUFBRSxlQUFlLGlCQUFpQiw4REFBOEQsbUNBQW1DLHVDQUF1QyxJQUFJLGdGQUFnRixPQUFPLFNBQVMsVUFBVSxHQUFHLGtCQUFrQixhQUFhLE1BQU0sMEJBQTBCLG1DQUFtQywrQkFBK0Isa0JBQWtCLG1CQUFtQixPQUFPLGNBQWMsYUFBYSxNQUFNLHdKQUF3SixrTEFBa0wsU0FBUyxhQUFhLGtEQUFrRCxZQUFZLDJCQUEyQixNQUFNLHVCQUF1Qiw0REFBNEQsdVJBQXVSLG9DQUFvQyxLQUFLLGtCQUFrQiwrQkFBK0IsRUFBRSxLQUFLLHFCQUFxQiwwQkFBMEIsRUFBRTtBQUN6L2lILHFCQUFxQixrREFBTTtBQUMzQiwyQ0FBMkM7QUFDM0Msc0RBQXNELCtCQUErQjtBQUNyRjtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGFiYXJuXFxPbmVEcml2ZVxcRGVza3RvcFxcU2FuamF5YW4gUmVhY3QgRmlsZXNcXGdlb3NwYXRpYWxfYXBwXFxHZW9zcGF0aWFsLUFwcGxpY2F0aW9uXFxnZW9zcGF0aWFsX3NreXNlcnZlXFxub2RlX21vZHVsZXNcXGdlb3RpZmZcXGRpc3QtbW9kdWxlXFx3b3JrZXJcXGRlY29kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgICAgIGltcG9ydCBXb3JrZXIgZnJvbSAnd2ViLXdvcmtlcic7XG4gICAgICAgIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gXCJmdW5jdGlvbiBBKEEsZSx0LGkscixJLGcpe3RyeXt2YXIgbj1BW0ldKGcpLGE9bi52YWx1ZX1jYXRjaChBKXtyZXR1cm4gdm9pZCB0KEEpfW4uZG9uZT9lKGEpOlByb21pc2UucmVzb2x2ZShhKS50aGVuKGkscil9ZnVuY3Rpb24gZShlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD10aGlzLGk9YXJndW1lbnRzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixJKXt2YXIgZz1lLmFwcGx5KHQsaSk7ZnVuY3Rpb24gbihlKXtBKGcscixJLG4sYSxcXFwibmV4dFxcXCIsZSl9ZnVuY3Rpb24gYShlKXtBKGcscixJLG4sYSxcXFwidGhyb3dcXFwiLGUpfW4odm9pZCAwKX0pKX19ZnVuY3Rpb24gdChBKXtyZXR1cm4gdD1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgU3ltYm9sJiZcXFwic3ltYm9sXFxcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihBKXtyZXR1cm4gdHlwZW9mIEF9OmZ1bmN0aW9uKEEpe3JldHVybiBBJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgU3ltYm9sJiZBLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZBIT09U3ltYm9sLnByb3RvdHlwZT9cXFwic3ltYm9sXFxcIjp0eXBlb2YgQX0sdChBKX12YXIgaT17ZXhwb3J0czp7fX07IWZ1bmN0aW9uKEEpe3ZhciBlPWZ1bmN0aW9uKEEpe3ZhciBlLGk9T2JqZWN0LnByb3RvdHlwZSxyPWkuaGFzT3duUHJvcGVydHksST1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxnPUkuaXRlcmF0b3J8fFxcXCJAQGl0ZXJhdG9yXFxcIixuPUkuYXN5bmNJdGVyYXRvcnx8XFxcIkBAYXN5bmNJdGVyYXRvclxcXCIsYT1JLnRvU3RyaW5nVGFnfHxcXFwiQEB0b1N0cmluZ1RhZ1xcXCI7ZnVuY3Rpb24gbyhBLGUsdCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGUse3ZhbHVlOnQsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KSxBW2VdfXRyeXtvKHt9LFxcXCJcXFwiKX1jYXRjaChBKXtvPWZ1bmN0aW9uKEEsZSx0KXtyZXR1cm4gQVtlXT10fX1mdW5jdGlvbiBCKEEsZSx0LGkpe3ZhciByPWUmJmUucHJvdG90eXBlIGluc3RhbmNlb2YgaD9lOmgsST1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxnPW5ldyBTKGl8fFtdKTtyZXR1cm4gSS5faW52b2tlPWZ1bmN0aW9uKEEsZSx0KXt2YXIgaT1RO3JldHVybiBmdW5jdGlvbihyLEkpe2lmKGk9PT1zKXRocm93IG5ldyBFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1xcXCIpO2lmKGk9PT1mKXtpZihcXFwidGhyb3dcXFwiPT09cil0aHJvdyBJO3JldHVybiBSKCl9Zm9yKHQubWV0aG9kPXIsdC5hcmc9STs7KXt2YXIgZz10LmRlbGVnYXRlO2lmKGcpe3ZhciBuPW0oZyx0KTtpZihuKXtpZihuPT09Yyljb250aW51ZTtyZXR1cm4gbn19aWYoXFxcIm5leHRcXFwiPT09dC5tZXRob2QpdC5zZW50PXQuX3NlbnQ9dC5hcmc7ZWxzZSBpZihcXFwidGhyb3dcXFwiPT09dC5tZXRob2Qpe2lmKGk9PT1RKXRocm93IGk9Zix0LmFyZzt0LmRpc3BhdGNoRXhjZXB0aW9uKHQuYXJnKX1lbHNlXFxcInJldHVyblxcXCI9PT10Lm1ldGhvZCYmdC5hYnJ1cHQoXFxcInJldHVyblxcXCIsdC5hcmcpO2k9czt2YXIgYT1DKEEsZSx0KTtpZihcXFwibm9ybWFsXFxcIj09PWEudHlwZSl7aWYoaT10LmRvbmU/ZjpFLGEuYXJnPT09Yyljb250aW51ZTtyZXR1cm57dmFsdWU6YS5hcmcsZG9uZTp0LmRvbmV9fVxcXCJ0aHJvd1xcXCI9PT1hLnR5cGUmJihpPWYsdC5tZXRob2Q9XFxcInRocm93XFxcIix0LmFyZz1hLmFyZyl9fX0oQSx0LGcpLEl9ZnVuY3Rpb24gQyhBLGUsdCl7dHJ5e3JldHVybnt0eXBlOlxcXCJub3JtYWxcXFwiLGFyZzpBLmNhbGwoZSx0KX19Y2F0Y2goQSl7cmV0dXJue3R5cGU6XFxcInRocm93XFxcIixhcmc6QX19fUEud3JhcD1CO3ZhciBRPVxcXCJzdXNwZW5kZWRTdGFydFxcXCIsRT1cXFwic3VzcGVuZGVkWWllbGRcXFwiLHM9XFxcImV4ZWN1dGluZ1xcXCIsZj1cXFwiY29tcGxldGVkXFxcIixjPXt9O2Z1bmN0aW9uIGgoKXt9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiB1KCl7fXZhciB3PXt9O28odyxnLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpO3ZhciBkPU9iamVjdC5nZXRQcm90b3R5cGVPZixEPWQmJmQoZCh2KFtdKSkpO0QmJkQhPT1pJiZyLmNhbGwoRCxnKSYmKHc9RCk7dmFyIHk9dS5wcm90b3R5cGU9aC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh3KTtmdW5jdGlvbiBrKEEpe1tcXFwibmV4dFxcXCIsXFxcInRocm93XFxcIixcXFwicmV0dXJuXFxcIl0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7byhBLGUsKGZ1bmN0aW9uKEEpe3JldHVybiB0aGlzLl9pbnZva2UoZSxBKX0pKX0pKX1mdW5jdGlvbiBwKEEsZSl7ZnVuY3Rpb24gaShJLGcsbixhKXt2YXIgbz1DKEFbSV0sQSxnKTtpZihcXFwidGhyb3dcXFwiIT09by50eXBlKXt2YXIgQj1vLmFyZyxRPUIudmFsdWU7cmV0dXJuIFEmJlxcXCJvYmplY3RcXFwiPT09dChRKSYmci5jYWxsKFEsXFxcIl9fYXdhaXRcXFwiKT9lLnJlc29sdmUoUS5fX2F3YWl0KS50aGVuKChmdW5jdGlvbihBKXtpKFxcXCJuZXh0XFxcIixBLG4sYSl9KSwoZnVuY3Rpb24oQSl7aShcXFwidGhyb3dcXFwiLEEsbixhKX0pKTplLnJlc29sdmUoUSkudGhlbigoZnVuY3Rpb24oQSl7Qi52YWx1ZT1BLG4oQil9KSwoZnVuY3Rpb24oQSl7cmV0dXJuIGkoXFxcInRocm93XFxcIixBLG4sYSl9KSl9YShvLmFyZyl9dmFyIEk7dGhpcy5faW52b2tlPWZ1bmN0aW9uKEEsdCl7ZnVuY3Rpb24gcigpe3JldHVybiBuZXcgZSgoZnVuY3Rpb24oZSxyKXtpKEEsdCxlLHIpfSkpfXJldHVybiBJPUk/SS50aGVuKHIscik6cigpfX1mdW5jdGlvbiBtKEEsdCl7dmFyIGk9QS5pdGVyYXRvclt0Lm1ldGhvZF07aWYoaT09PWUpe2lmKHQuZGVsZWdhdGU9bnVsbCxcXFwidGhyb3dcXFwiPT09dC5tZXRob2Qpe2lmKEEuaXRlcmF0b3IucmV0dXJuJiYodC5tZXRob2Q9XFxcInJldHVyblxcXCIsdC5hcmc9ZSxtKEEsdCksXFxcInRocm93XFxcIj09PXQubWV0aG9kKSlyZXR1cm4gYzt0Lm1ldGhvZD1cXFwidGhyb3dcXFwiLHQuYXJnPW5ldyBUeXBlRXJyb3IoXFxcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcXFwiKX1yZXR1cm4gY312YXIgcj1DKGksQS5pdGVyYXRvcix0LmFyZyk7aWYoXFxcInRocm93XFxcIj09PXIudHlwZSlyZXR1cm4gdC5tZXRob2Q9XFxcInRocm93XFxcIix0LmFyZz1yLmFyZyx0LmRlbGVnYXRlPW51bGwsYzt2YXIgST1yLmFyZztyZXR1cm4gST9JLmRvbmU/KHRbQS5yZXN1bHROYW1lXT1JLnZhbHVlLHQubmV4dD1BLm5leHRMb2MsXFxcInJldHVyblxcXCIhPT10Lm1ldGhvZCYmKHQubWV0aG9kPVxcXCJuZXh0XFxcIix0LmFyZz1lKSx0LmRlbGVnYXRlPW51bGwsYyk6SToodC5tZXRob2Q9XFxcInRocm93XFxcIix0LmFyZz1uZXcgVHlwZUVycm9yKFxcXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFxcXCIpLHQuZGVsZWdhdGU9bnVsbCxjKX1mdW5jdGlvbiBHKEEpe3ZhciBlPXt0cnlMb2M6QVswXX07MSBpbiBBJiYoZS5jYXRjaExvYz1BWzFdKSwyIGluIEEmJihlLmZpbmFsbHlMb2M9QVsyXSxlLmFmdGVyTG9jPUFbM10pLHRoaXMudHJ5RW50cmllcy5wdXNoKGUpfWZ1bmN0aW9uIEYoQSl7dmFyIGU9QS5jb21wbGV0aW9ufHx7fTtlLnR5cGU9XFxcIm5vcm1hbFxcXCIsZGVsZXRlIGUuYXJnLEEuY29tcGxldGlvbj1lfWZ1bmN0aW9uIFMoQSl7dGhpcy50cnlFbnRyaWVzPVt7dHJ5TG9jOlxcXCJyb290XFxcIn1dLEEuZm9yRWFjaChHLHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIHYoQSl7aWYoQSl7dmFyIHQ9QVtnXTtpZih0KXJldHVybiB0LmNhbGwoQSk7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIEEubmV4dClyZXR1cm4gQTtpZighaXNOYU4oQS5sZW5ndGgpKXt2YXIgaT0tMSxJPWZ1bmN0aW9uIHQoKXtmb3IoOysraTxBLmxlbmd0aDspaWYoci5jYWxsKEEsaSkpcmV0dXJuIHQudmFsdWU9QVtpXSx0LmRvbmU9ITEsdDtyZXR1cm4gdC52YWx1ZT1lLHQuZG9uZT0hMCx0fTtyZXR1cm4gSS5uZXh0PUl9fXJldHVybntuZXh0OlJ9fWZ1bmN0aW9uIFIoKXtyZXR1cm57dmFsdWU6ZSxkb25lOiEwfX1yZXR1cm4gbC5wcm90b3R5cGU9dSxvKHksXFxcImNvbnN0cnVjdG9yXFxcIix1KSxvKHUsXFxcImNvbnN0cnVjdG9yXFxcIixsKSxsLmRpc3BsYXlOYW1lPW8odSxhLFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCIpLEEuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbihBKXt2YXIgZT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgQSYmQS5jb25zdHJ1Y3RvcjtyZXR1cm4hIWUmJihlPT09bHx8XFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIj09PShlLmRpc3BsYXlOYW1lfHxlLm5hbWUpKX0sQS5tYXJrPWZ1bmN0aW9uKEEpe3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKEEsdSk6KEEuX19wcm90b19fPXUsbyhBLGEsXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIikpLEEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoeSksQX0sQS5hd3JhcD1mdW5jdGlvbihBKXtyZXR1cm57X19hd2FpdDpBfX0sayhwLnByb3RvdHlwZSksbyhwLnByb3RvdHlwZSxuLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpLEEuQXN5bmNJdGVyYXRvcj1wLEEuYXN5bmM9ZnVuY3Rpb24oZSx0LGkscixJKXt2b2lkIDA9PT1JJiYoST1Qcm9taXNlKTt2YXIgZz1uZXcgcChCKGUsdCxpLHIpLEkpO3JldHVybiBBLmlzR2VuZXJhdG9yRnVuY3Rpb24odCk/ZzpnLm5leHQoKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gQS5kb25lP0EudmFsdWU6Zy5uZXh0KCl9KSl9LGsoeSksbyh5LGEsXFxcIkdlbmVyYXRvclxcXCIpLG8oeSxnLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpLG8oeSxcXFwidG9TdHJpbmdcXFwiLChmdW5jdGlvbigpe3JldHVyblxcXCJbb2JqZWN0IEdlbmVyYXRvcl1cXFwifSkpLEEua2V5cz1mdW5jdGlvbihBKXt2YXIgZT1bXTtmb3IodmFyIHQgaW4gQSllLnB1c2godCk7cmV0dXJuIGUucmV2ZXJzZSgpLGZ1bmN0aW9uIHQoKXtmb3IoO2UubGVuZ3RoOyl7dmFyIGk9ZS5wb3AoKTtpZihpIGluIEEpcmV0dXJuIHQudmFsdWU9aSx0LmRvbmU9ITEsdH1yZXR1cm4gdC5kb25lPSEwLHR9fSxBLnZhbHVlcz12LFMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpTLHJlc2V0OmZ1bmN0aW9uKEEpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PWUsdGhpcy5kb25lPSExLHRoaXMuZGVsZWdhdGU9bnVsbCx0aGlzLm1ldGhvZD1cXFwibmV4dFxcXCIsdGhpcy5hcmc9ZSx0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChGKSwhQSlmb3IodmFyIHQgaW4gdGhpcylcXFwidFxcXCI9PT10LmNoYXJBdCgwKSYmci5jYWxsKHRoaXMsdCkmJiFpc05hTigrdC5zbGljZSgxKSkmJih0aGlzW3RdPWUpfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5kb25lPSEwO3ZhciBBPXRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO2lmKFxcXCJ0aHJvd1xcXCI9PT1BLnR5cGUpdGhyb3cgQS5hcmc7cmV0dXJuIHRoaXMucnZhbH0sZGlzcGF0Y2hFeGNlcHRpb246ZnVuY3Rpb24oQSl7aWYodGhpcy5kb25lKXRocm93IEE7dmFyIHQ9dGhpcztmdW5jdGlvbiBpKGkscil7cmV0dXJuIG4udHlwZT1cXFwidGhyb3dcXFwiLG4uYXJnPUEsdC5uZXh0PWksciYmKHQubWV0aG9kPVxcXCJuZXh0XFxcIix0LmFyZz1lKSwhIXJ9Zm9yKHZhciBJPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtJPj0wOy0tSSl7dmFyIGc9dGhpcy50cnlFbnRyaWVzW0ldLG49Zy5jb21wbGV0aW9uO2lmKFxcXCJyb290XFxcIj09PWcudHJ5TG9jKXJldHVybiBpKFxcXCJlbmRcXFwiKTtpZihnLnRyeUxvYzw9dGhpcy5wcmV2KXt2YXIgYT1yLmNhbGwoZyxcXFwiY2F0Y2hMb2NcXFwiKSxvPXIuY2FsbChnLFxcXCJmaW5hbGx5TG9jXFxcIik7aWYoYSYmbyl7aWYodGhpcy5wcmV2PGcuY2F0Y2hMb2MpcmV0dXJuIGkoZy5jYXRjaExvYywhMCk7aWYodGhpcy5wcmV2PGcuZmluYWxseUxvYylyZXR1cm4gaShnLmZpbmFsbHlMb2MpfWVsc2UgaWYoYSl7aWYodGhpcy5wcmV2PGcuY2F0Y2hMb2MpcmV0dXJuIGkoZy5jYXRjaExvYywhMCl9ZWxzZXtpZighbyl0aHJvdyBuZXcgRXJyb3IoXFxcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XFxcIik7aWYodGhpcy5wcmV2PGcuZmluYWxseUxvYylyZXR1cm4gaShnLmZpbmFsbHlMb2MpfX19fSxhYnJ1cHQ6ZnVuY3Rpb24oQSxlKXtmb3IodmFyIHQ9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO3Q+PTA7LS10KXt2YXIgaT10aGlzLnRyeUVudHJpZXNbdF07aWYoaS50cnlMb2M8PXRoaXMucHJldiYmci5jYWxsKGksXFxcImZpbmFsbHlMb2NcXFwiKSYmdGhpcy5wcmV2PGkuZmluYWxseUxvYyl7dmFyIEk9aTticmVha319SSYmKFxcXCJicmVha1xcXCI9PT1BfHxcXFwiY29udGludWVcXFwiPT09QSkmJkkudHJ5TG9jPD1lJiZlPD1JLmZpbmFsbHlMb2MmJihJPW51bGwpO3ZhciBnPUk/SS5jb21wbGV0aW9uOnt9O3JldHVybiBnLnR5cGU9QSxnLmFyZz1lLEk/KHRoaXMubWV0aG9kPVxcXCJuZXh0XFxcIix0aGlzLm5leHQ9SS5maW5hbGx5TG9jLGMpOnRoaXMuY29tcGxldGUoZyl9LGNvbXBsZXRlOmZ1bmN0aW9uKEEsZSl7aWYoXFxcInRocm93XFxcIj09PUEudHlwZSl0aHJvdyBBLmFyZztyZXR1cm5cXFwiYnJlYWtcXFwiPT09QS50eXBlfHxcXFwiY29udGludWVcXFwiPT09QS50eXBlP3RoaXMubmV4dD1BLmFyZzpcXFwicmV0dXJuXFxcIj09PUEudHlwZT8odGhpcy5ydmFsPXRoaXMuYXJnPUEuYXJnLHRoaXMubWV0aG9kPVxcXCJyZXR1cm5cXFwiLHRoaXMubmV4dD1cXFwiZW5kXFxcIik6XFxcIm5vcm1hbFxcXCI9PT1BLnR5cGUmJmUmJih0aGlzLm5leHQ9ZSksY30sZmluaXNoOmZ1bmN0aW9uKEEpe2Zvcih2YXIgZT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ZT49MDstLWUpe3ZhciB0PXRoaXMudHJ5RW50cmllc1tlXTtpZih0LmZpbmFsbHlMb2M9PT1BKXJldHVybiB0aGlzLmNvbXBsZXRlKHQuY29tcGxldGlvbix0LmFmdGVyTG9jKSxGKHQpLGN9fSxjYXRjaDpmdW5jdGlvbihBKXtmb3IodmFyIGU9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO2U+PTA7LS1lKXt2YXIgdD10aGlzLnRyeUVudHJpZXNbZV07aWYodC50cnlMb2M9PT1BKXt2YXIgaT10LmNvbXBsZXRpb247aWYoXFxcInRocm93XFxcIj09PWkudHlwZSl7dmFyIHI9aS5hcmc7Rih0KX1yZXR1cm4gcn19dGhyb3cgbmV3IEVycm9yKFxcXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcXFwiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbihBLHQsaSl7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOnYoQSkscmVzdWx0TmFtZTp0LG5leHRMb2M6aX0sXFxcIm5leHRcXFwiPT09dGhpcy5tZXRob2QmJih0aGlzLmFyZz1lKSxjfX0sQX0oQS5leHBvcnRzKTt0cnl7cmVnZW5lcmF0b3JSdW50aW1lPWV9Y2F0Y2goQSl7XFxcIm9iamVjdFxcXCI9PT0oXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBnbG9iYWxUaGlzP1xcXCJ1bmRlZmluZWRcXFwiOnQoZ2xvYmFsVGhpcykpP2dsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lPWU6RnVuY3Rpb24oXFxcInJcXFwiLFxcXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXFxcIikoZSl9fShpKTt2YXIgcj1pLmV4cG9ydHMsST1uZXcgTWFwO2Z1bmN0aW9uIGcoQSxlKXtBcnJheS5pc0FycmF5KEEpfHwoQT1bQV0pLEEuZm9yRWFjaCgoZnVuY3Rpb24oQSl7cmV0dXJuIEkuc2V0KEEsZSl9KSl9ZnVuY3Rpb24gbihBKXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gYSgpe3JldHVybihhPWUoci5tYXJrKChmdW5jdGlvbiBBKGUpe3ZhciB0LGk7cmV0dXJuIHIud3JhcCgoZnVuY3Rpb24oQSl7Zm9yKDs7KXN3aXRjaChBLnByZXY9QS5uZXh0KXtjYXNlIDA6aWYodD1JLmdldChlLkNvbXByZXNzaW9uKSl7QS5uZXh0PTM7YnJlYWt9dGhyb3cgbmV3IEVycm9yKFxcXCJVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiBcXFwiLmNvbmNhdChlLkNvbXByZXNzaW9uKSk7Y2FzZSAzOnJldHVybiBBLm5leHQ9NSx0KCk7Y2FzZSA1OnJldHVybiBpPUEuc2VudCxBLmFicnVwdChcXFwicmV0dXJuXFxcIixuZXcgaShlKSk7Y2FzZSA3OmNhc2VcXFwiZW5kXFxcIjpyZXR1cm4gQS5zdG9wKCl9fSksQSl9KSkpKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Zyhbdm9pZCAwLDFdLChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB5fSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmRlZmF1bHR9KSl9KSksZyg1LChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBGfSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBBLmRlZmF1bHR9KSl9KSksZyg2LChmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcXFwib2xkIHN0eWxlIEpQRUcgY29tcHJlc3Npb24gaXMgbm90IHN1cHBvcnRlZC5cXFwiKX0pKSxnKDcsKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIE59KSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZGVmYXVsdH0pKX0pKSxnKFs4LDMyOTQ2XSwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gT0F9KSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZGVmYXVsdH0pKX0pKSxnKDMyNzczLChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBfQX0pKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gQS5kZWZhdWx0fSkpfSkpLGcoMzQ4ODcsKGZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGxlfSkpLnRoZW4oZnVuY3Rpb24oKXt2YXIgQT1lKHIubWFyaygoZnVuY3Rpb24gQShlKXtyZXR1cm4gci53cmFwKChmdW5jdGlvbihBKXtmb3IoOzspc3dpdGNoKEEucHJldj1BLm5leHQpe2Nhc2UgMDpyZXR1cm4gQS5uZXh0PTIsZS56c3RkLmluaXQoKTtjYXNlIDI6cmV0dXJuIEEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLGUpO2Nhc2UgMzpjYXNlXFxcImVuZFxcXCI6cmV0dXJuIEEuc3RvcCgpfX0pLEEpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIEEuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuZGVmYXVsdH0pKX0pKSxnKDUwMDAxLChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBkZX0pKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gQS5kZWZhdWx0fSkpfSkpO3ZhciBvPWdsb2JhbFRoaXM7ZnVuY3Rpb24gQihBLGUpe2lmKCEoQSBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpfWZ1bmN0aW9uIEMoQSxlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrKyl7dmFyIGk9ZVt0XTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGkua2V5LGkpfX1mdW5jdGlvbiBRKEEsZSx0KXtyZXR1cm4gZSYmQyhBLnByb3RvdHlwZSxlKSx0JiZDKEEsdCksQX1mdW5jdGlvbiBFKEEsZSl7cmV0dXJuIEU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihBLGUpe3JldHVybiBBLl9fcHJvdG9fXz1lLEF9LEUoQSxlKX1mdW5jdGlvbiBzKEEsZSl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7QS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOkEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJkUoQSxlKX1mdW5jdGlvbiBmKEEsZSl7aWYoZSYmKFxcXCJvYmplY3RcXFwiPT09dChlKXx8XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUpKXJldHVybiBlO2lmKHZvaWQgMCE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcXFwiKTtyZXR1cm4gZnVuY3Rpb24oQSl7aWYodm9pZCAwPT09QSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpO3JldHVybiBBfShBKX1mdW5jdGlvbiBjKEEpe3JldHVybiBjPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oQSl7cmV0dXJuIEEuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoQSl9LGMoQSl9ZnVuY3Rpb24gaChBLGUpe3ZhciB0PUEubGVuZ3RoLWUsaT0wO2Rve2Zvcih2YXIgcj1lO3I+MDtyLS0pQVtpK2VdKz1BW2ldLGkrKzt0LT1lfXdoaWxlKHQ+MCl9ZnVuY3Rpb24gbChBLGUsdCl7Zm9yKHZhciBpPTAscj1BLmxlbmd0aCxJPXIvdDtyPmU7KXtmb3IodmFyIGc9ZTtnPjA7LS1nKUFbaStlXSs9QVtpXSwrK2k7ci09ZX1mb3IodmFyIG49QS5zbGljZSgpLGE9MDthPEk7KythKWZvcih2YXIgbz0wO288dDsrK28pQVt0KmErb109blsodC1vLTEpKkkrYV19ZnVuY3Rpb24gdShBLGUsdCxpLHIsSSl7aWYoIWV8fDE9PT1lKXJldHVybiBBO2Zvcih2YXIgZz0wO2c8ci5sZW5ndGg7KytnKXtpZihyW2ddJTghPTApdGhyb3cgbmV3IEVycm9yKFxcXCJXaGVuIGRlY29kaW5nIHdpdGggcHJlZGljdG9yLCBvbmx5IG11bHRpcGxlIG9mIDggYml0cyBhcmUgc3VwcG9ydGVkLlxcXCIpO2lmKHJbZ10hPT1yWzBdKXRocm93IG5ldyBFcnJvcihcXFwiV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3RvciwgYWxsIHNhbXBsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUuXFxcIil9Zm9yKHZhciBuPXJbMF0vOCxhPTI9PT1JPzE6ci5sZW5ndGgsbz0wO288aSYmIShvKmEqdCpuPj1BLmJ5dGVMZW5ndGgpOysrbyl7dmFyIEI9dm9pZCAwO2lmKDI9PT1lKXtzd2l0Y2goclswXSl7Y2FzZSA4OkI9bmV3IFVpbnQ4QXJyYXkoQSxvKmEqdCpuLGEqdCpuKTticmVhaztjYXNlIDE2OkI9bmV3IFVpbnQxNkFycmF5KEEsbyphKnQqbixhKnQqbi8yKTticmVhaztjYXNlIDMyOkI9bmV3IFVpbnQzMkFycmF5KEEsbyphKnQqbixhKnQqbi80KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcXFwiUHJlZGljdG9yIDIgbm90IGFsbG93ZWQgd2l0aCBcXFwiLmNvbmNhdChyWzBdLFxcXCIgYml0cyBwZXIgc2FtcGxlLlxcXCIpKX1oKEIsYSl9ZWxzZSAzPT09ZSYmbChCPW5ldyBVaW50OEFycmF5KEEsbyphKnQqbixhKnQqbiksYSxuKX1yZXR1cm4gQX1vLmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1lc3NhZ2VcXFwiLGZ1bmN0aW9uKCl7dmFyIEE9ZShyLm1hcmsoKGZ1bmN0aW9uIEEoZSl7dmFyIHQsaSxJLGcsYSxCO3JldHVybiByLndyYXAoKGZ1bmN0aW9uKEEpe2Zvcig7Oylzd2l0Y2goQS5wcmV2PUEubmV4dCl7Y2FzZSAwOnJldHVybiB0PWUuZGF0YSxpPXQuaWQsST10LmZpbGVEaXJlY3RvcnksZz10LmJ1ZmZlcixBLm5leHQ9MyxuKEkpO2Nhc2UgMzpyZXR1cm4gYT1BLnNlbnQsQS5uZXh0PTYsYS5kZWNvZGUoSSxnKTtjYXNlIDY6Qj1BLnNlbnQsby5wb3N0TWVzc2FnZSh7ZGVjb2RlZDpCLGlkOml9LFtCXSk7Y2FzZSA4OmNhc2VcXFwiZW5kXFxcIjpyZXR1cm4gQS5zdG9wKCl9fSksQSl9KSkpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gQS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpKTt2YXIgdz1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoKXtCKHRoaXMsQSl9dmFyIHQ7cmV0dXJuIFEoQSxbe2tleTpcXFwiZGVjb2RlXFxcIix2YWx1ZToodD1lKHIubWFyaygoZnVuY3Rpb24gQShlLHQpe3ZhciBpLEksZyxuLGE7cmV0dXJuIHIud3JhcCgoZnVuY3Rpb24oQSl7Zm9yKDs7KXN3aXRjaChBLnByZXY9QS5uZXh0KXtjYXNlIDA6cmV0dXJuIEEubmV4dD0yLHRoaXMuZGVjb2RlQmxvY2sodCk7Y2FzZSAyOmlmKGk9QS5zZW50LDE9PT0oST1lLlByZWRpY3Rvcnx8MSkpe0EubmV4dD05O2JyZWFrfXJldHVybiBnPSFlLlN0cmlwT2Zmc2V0cyxuPWc/ZS5UaWxlV2lkdGg6ZS5JbWFnZVdpZHRoLGE9Zz9lLlRpbGVMZW5ndGg6ZS5Sb3dzUGVyU3RyaXB8fGUuSW1hZ2VMZW5ndGgsQS5hYnJ1cHQoXFxcInJldHVyblxcXCIsdShpLEksbixhLGUuQml0c1BlclNhbXBsZSxlLlBsYW5hckNvbmZpZ3VyYXRpb24pKTtjYXNlIDk6cmV0dXJuIEEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLGkpO2Nhc2UgMTA6Y2FzZVxcXCJlbmRcXFwiOnJldHVybiBBLnN0b3AoKX19KSxBLHRoaXMpfSkpKSxmdW5jdGlvbihBLGUpe3JldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfV0pLEF9KCk7ZnVuY3Rpb24gZChBKXt2YXIgZT1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChBKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsaT1jKEEpO2lmKGUpe3ZhciByPWModGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChpLGFyZ3VtZW50cyxyKX1lbHNlIHQ9aS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGYodGhpcyx0KX19dmFyIEQ9ZnVuY3Rpb24oQSl7cyh0LHcpO3ZhciBlPWQodCk7ZnVuY3Rpb24gdCgpe3JldHVybiBCKHRoaXMsdCksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3JldHVybiBBfX1dKSx0fSgpLHk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDpEfSk7ZnVuY3Rpb24gayhBKXt2YXIgZT1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChBKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsaT1jKEEpO2lmKGUpe3ZhciByPWModGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChpLGFyZ3VtZW50cyxyKX1lbHNlIHQ9aS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGYodGhpcyx0KX19ZnVuY3Rpb24gcChBLGUpe2Zvcih2YXIgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKUEucHVzaChlW3RdKTtyZXR1cm4gQX1mdW5jdGlvbiBtKEEpe2Zvcih2YXIgZT1uZXcgVWludDE2QXJyYXkoNDA5MyksdD1uZXcgVWludDhBcnJheSg0MDkzKSxpPTA7aTw9MjU3O2krKyllW2ldPTQwOTYsdFtpXT1pO3ZhciByPTI1OCxJPTksZz0wO2Z1bmN0aW9uIG4oKXtyPTI1OCxJPTl9ZnVuY3Rpb24gYShBKXt2YXIgZT1mdW5jdGlvbihBLGUsdCl7dmFyIGk9ZSU4LHI9TWF0aC5mbG9vcihlLzgpLEk9OC1pLGc9ZSt0LTgqKHIrMSksbj04KihyKzIpLShlK3QpLGE9OCoocisyKS1lO2lmKG49TWF0aC5tYXgoMCxuKSxyPj1BLmxlbmd0aClyZXR1cm4gY29uc29sZS53YXJuKFxcXCJyYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBiZWZvcmUgZmluZGluZyBFT0lfQ09ERSAoZW5kIG9uIGlucHV0IGNvZGUpXFxcIiksMjU3O3ZhciBvPUFbcl0mTWF0aC5wb3coMiw4LWkpLTEsQj1vPDw9dC1JO2lmKHIrMTxBLmxlbmd0aCl7dmFyIEM9QVtyKzFdPj4+bjtCKz1DPDw9TWF0aC5tYXgoMCx0LWEpfWlmKGc+OCYmcisyPEEubGVuZ3RoKXt2YXIgUT04KihyKzMpLShlK3QpO0IrPUFbcisyXT4+PlF9cmV0dXJuIEJ9KEEsZyxJKTtyZXR1cm4gZys9SSxlfWZ1bmN0aW9uIG8oQSxpKXtyZXR1cm4gdFtyXT1pLGVbcl09QSwrK3ItMX1mdW5jdGlvbiBCKEEpe2Zvcih2YXIgaT1bXSxyPUE7NDA5NiE9PXI7cj1lW3JdKWkucHVzaCh0W3JdKTtyZXR1cm4gaX12YXIgQz1bXTtuKCk7Zm9yKHZhciBRLEU9bmV3IFVpbnQ4QXJyYXkoQSkscz1hKEUpOzI1NyE9PXM7KXtpZigyNTY9PT1zKXtmb3IobigpLHM9YShFKTsyNTY9PT1zOylzPWEoRSk7aWYoMjU3PT09cylicmVhaztpZihzPjI1Nil0aHJvdyBuZXcgRXJyb3IoXFxcImNvcnJ1cHRlZCBjb2RlIGF0IHNjYW5saW5lIFxcXCIuY29uY2F0KHMpKTtwKEMsQihzKSksUT1zfWVsc2UgaWYoczxyKXt2YXIgZj1CKHMpO3AoQyxmKSxvKFEsZltmLmxlbmd0aC0xXSksUT1zfWVsc2V7dmFyIGM9QihRKTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXFxcIkJvZ3VzIGVudHJ5LiBOb3QgaW4gZGljdGlvbmFyeSwgXFxcIi5jb25jYXQoUSxcXFwiIC8gXFxcIikuY29uY2F0KHIsXFxcIiwgcG9zaXRpb246IFxcXCIpLmNvbmNhdChnKSk7cChDLGMpLEMucHVzaChjW2MubGVuZ3RoLTFdKSxvKFEsY1tjLmxlbmd0aC0xXSksUT1zfXIrMT49TWF0aC5wb3coMixJKSYmKDEyPT09ST9RPXZvaWQgMDpJKyspLHM9YShFKX1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQyl9dmFyIEc9ZnVuY3Rpb24oQSl7cyh0LHcpO3ZhciBlPWsodCk7ZnVuY3Rpb24gdCgpe3JldHVybiBCKHRoaXMsdCksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3JldHVybiBtKEEpLmJ1ZmZlcn19XSksdH0oKSxGPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6R30pO2Z1bmN0aW9uIFMoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciB2PW5ldyBJbnQzMkFycmF5KFswLDEsOCwxNiw5LDIsMywxMCwxNywyNCwzMiwyNSwxOCwxMSw0LDUsMTIsMTksMjYsMzMsNDAsNDgsNDEsMzQsMjcsMjAsMTMsNiw3LDE0LDIxLDI4LDM1LDQyLDQ5LDU2LDU3LDUwLDQzLDM2LDI5LDIyLDE1LDIzLDMwLDM3LDQ0LDUxLDU4LDU5LDUyLDQ1LDM4LDMxLDM5LDQ2LDUzLDYwLDYxLDU0LDQ3LDU1LDYyLDYzXSk7ZnVuY3Rpb24gUihBLGUpe2Zvcih2YXIgdD0wLGk9W10scj0xNjtyPjAmJiFBW3ItMV07KS0tcjtpLnB1c2goe2NoaWxkcmVuOltdLGluZGV4OjB9KTtmb3IodmFyIEksZz1pWzBdLG49MDtuPHI7bisrKXtmb3IodmFyIGE9MDthPEFbbl07YSsrKXtmb3IoKGc9aS5wb3AoKSkuY2hpbGRyZW5bZy5pbmRleF09ZVt0XTtnLmluZGV4PjA7KWc9aS5wb3AoKTtmb3IoZy5pbmRleCsrLGkucHVzaChnKTtpLmxlbmd0aDw9bjspaS5wdXNoKEk9e2NoaWxkcmVuOltdLGluZGV4OjB9KSxnLmNoaWxkcmVuW2cuaW5kZXhdPUkuY2hpbGRyZW4sZz1JO3QrK31uKzE8ciYmKGkucHVzaChJPXtjaGlsZHJlbjpbXSxpbmRleDowfSksZy5jaGlsZHJlbltnLmluZGV4XT1JLmNoaWxkcmVuLGc9SSl9cmV0dXJuIGlbMF0uY2hpbGRyZW59ZnVuY3Rpb24gVShBLGUsaSxyLEksZyxuLGEsbyl7dmFyIEI9aS5tY3VzUGVyTGluZSxDPWkucHJvZ3Jlc3NpdmUsUT1lLEU9ZSxzPTAsZj0wO2Z1bmN0aW9uIGMoKXtpZihmPjApcmV0dXJuIGYtLSxzPj5mJjE7aWYoMjU1PT09KHM9QVtFKytdKSl7dmFyIGU9QVtFKytdO2lmKGUpdGhyb3cgbmV3IEVycm9yKFxcXCJ1bmV4cGVjdGVkIG1hcmtlcjogXFxcIi5jb25jYXQoKHM8PDh8ZSkudG9TdHJpbmcoMTYpKSl9cmV0dXJuIGY9NyxzPj4+N31mdW5jdGlvbiBoKEEpe2Zvcih2YXIgZSxpPUE7bnVsbCE9PShlPWMoKSk7KXtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mKGk9aVtlXSkpcmV0dXJuIGk7aWYoXFxcIm9iamVjdFxcXCIhPT10KGkpKXRocm93IG5ldyBFcnJvcihcXFwiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlXFxcIil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbChBKXtmb3IodmFyIGU9QSx0PTA7ZT4wOyl7dmFyIGk9YygpO2lmKG51bGw9PT1pKXJldHVybjt0PXQ8PDF8aSwtLWV9cmV0dXJuIHR9ZnVuY3Rpb24gdShBKXt2YXIgZT1sKEEpO3JldHVybiBlPj0xPDxBLTE/ZTplKygtMTw8QSkrMX12YXIgdz0wO3ZhciBkLEQ9MDtmdW5jdGlvbiB5KEEsZSx0LGkscil7dmFyIEk9dCVCLGc9KHQvQnwwKSpBLnYraSxuPUkqQS5oK3I7ZShBLEEuYmxvY2tzW2ddW25dKX1mdW5jdGlvbiBrKEEsZSx0KXt2YXIgaT10L0EuYmxvY2tzUGVyTGluZXwwLHI9dCVBLmJsb2Nrc1BlckxpbmU7ZShBLEEuYmxvY2tzW2ldW3JdKX12YXIgcCxtLEcsRixTLFIsVT1yLmxlbmd0aDtSPUM/MD09PWc/MD09PWE/ZnVuY3Rpb24oQSxlKXt2YXIgdD1oKEEuaHVmZm1hblRhYmxlREMpLGk9MD09PXQ/MDp1KHQpPDxvO0EucHJlZCs9aSxlWzBdPUEucHJlZH06ZnVuY3Rpb24oQSxlKXtlWzBdfD1jKCk8PG99OjA9PT1hP2Z1bmN0aW9uKEEsZSl7aWYodz4wKXctLTtlbHNlIGZvcih2YXIgdD1nLGk9bjt0PD1pOyl7dmFyIHI9aChBLmh1ZmZtYW5UYWJsZUFDKSxJPTE1JnIsYT1yPj40O2lmKDA9PT1JKXtpZihhPDE1KXt3PWwoYSkrKDE8PGEpLTE7YnJlYWt9dCs9MTZ9ZWxzZSBlW3ZbdCs9YV1dPXUoSSkqKDE8PG8pLHQrK319OmZ1bmN0aW9uKEEsZSl7Zm9yKHZhciB0PWcsaT1uLHI9MDt0PD1pOyl7dmFyIEk9dlt0XSxhPWVbSV08MD8tMToxO3N3aXRjaChEKXtjYXNlIDA6dmFyIEI9aChBLmh1ZmZtYW5UYWJsZUFDKSxDPTE1JkI7aWYocj1CPj40LDA9PT1DKXI8MTU/KHc9bChyKSsoMTw8ciksRD00KToocj0xNixEPTEpO2Vsc2V7aWYoMSE9PUMpdGhyb3cgbmV3IEVycm9yKFxcXCJpbnZhbGlkIEFDbiBlbmNvZGluZ1xcXCIpO2Q9dShDKSxEPXI/MjozfWNvbnRpbnVlO2Nhc2UgMTpjYXNlIDI6ZVtJXT9lW0ldKz0oYygpPDxvKSphOjA9PS0tciYmKEQ9Mj09PUQ/MzowKTticmVhaztjYXNlIDM6ZVtJXT9lW0ldKz0oYygpPDxvKSphOihlW0ldPWQ8PG8sRD0wKTticmVhaztjYXNlIDQ6ZVtJXSYmKGVbSV0rPShjKCk8PG8pKmEpfXQrK300PT09RCYmMD09LS13JiYoRD0wKX06ZnVuY3Rpb24oQSxlKXt2YXIgdD1oKEEuaHVmZm1hblRhYmxlREMpLGk9MD09PXQ/MDp1KHQpO0EucHJlZCs9aSxlWzBdPUEucHJlZDtmb3IodmFyIHI9MTtyPDY0Oyl7dmFyIEk9aChBLmh1ZmZtYW5UYWJsZUFDKSxnPTE1Jkksbj1JPj40O2lmKDA9PT1nKXtpZihuPDE1KWJyZWFrO3IrPTE2fWVsc2UgZVt2W3IrPW5dXT11KGcpLHIrK319O3ZhciBMLGIsTT0wO2I9MT09PVU/clswXS5ibG9ja3NQZXJMaW5lKnJbMF0uYmxvY2tzUGVyQ29sdW1uOkIqaS5tY3VzUGVyQ29sdW1uO2Zvcih2YXIgTj1JfHxiO008Yjspe2ZvcihtPTA7bTxVO20rKylyW21dLnByZWQ9MDtpZih3PTAsMT09PVUpZm9yKHA9clswXSxTPTA7UzxOO1MrKylrKHAsUixNKSxNKys7ZWxzZSBmb3IoUz0wO1M8TjtTKyspe2ZvcihtPTA7bTxVO20rKyl7dmFyIHg9cD1yW21dLEo9eC5oLHE9eC52O2ZvcihHPTA7RzxxO0crKylmb3IoRj0wO0Y8SjtGKyspeShwLFIsTSxHLEYpfWlmKCsrTT09PWIpYnJlYWt9aWYoZj0wLChMPUFbRV08PDh8QVtFKzFdKTw2NTI4MCl0aHJvdyBuZXcgRXJyb3IoXFxcIm1hcmtlciB3YXMgbm90IGZvdW5kXFxcIik7aWYoIShMPj02NTQ4OCYmTDw9NjU0OTUpKWJyZWFrO0UrPTJ9cmV0dXJuIEUtUX1mdW5jdGlvbiBMKEEsZSl7dmFyIHQ9W10saT1lLmJsb2Nrc1BlckxpbmUscj1lLmJsb2Nrc1BlckNvbHVtbixJPWk8PDMsZz1uZXcgSW50MzJBcnJheSg2NCksbj1uZXcgVWludDhBcnJheSg2NCk7ZnVuY3Rpb24gYShBLHQsaSl7dmFyIHIsSSxnLG4sYSxvLEIsQyxRLEUscz1lLnF1YW50aXphdGlvblRhYmxlLGY9aTtmb3IoRT0wO0U8NjQ7RSsrKWZbRV09QVtFXSpzW0VdO2ZvcihFPTA7RTw4OysrRSl7dmFyIGM9OCpFOzAhPT1mWzErY118fDAhPT1mWzIrY118fDAhPT1mWzMrY118fDAhPT1mWzQrY118fDAhPT1mWzUrY118fDAhPT1mWzYrY118fDAhPT1mWzcrY10/KHI9NTc5MypmWzArY10rMTI4Pj44LEk9NTc5MypmWzQrY10rMTI4Pj44LGc9ZlsyK2NdLG49Zls2K2NdLGE9Mjg5NiooZlsxK2NdLWZbNytjXSkrMTI4Pj44LEM9Mjg5NiooZlsxK2NdK2ZbNytjXSkrMTI4Pj44LG89ZlszK2NdPDw0LFE9ci1JKzE+PjEscj1yK0krMT4+MSxJPVEsUT0zNzg0KmcrMTU2NypuKzEyOD4+OCxnPTE1NjcqZy0zNzg0Km4rMTI4Pj44LG49USxRPWEtKEI9Zls1K2NdPDw0KSsxPj4xLGE9YStCKzE+PjEsQj1RLFE9QytvKzE+PjEsbz1DLW8rMT4+MSxDPVEsUT1yLW4rMT4+MSxyPXIrbisxPj4xLG49USxRPUktZysxPj4xLEk9SStnKzE+PjEsZz1RLFE9MjI3NiphKzM0MDYqQysyMDQ4Pj4xMixhPTM0MDYqYS0yMjc2KkMrMjA0OD4+MTIsQz1RLFE9Nzk5Km8rNDAxNypCKzIwNDg+PjEyLG89NDAxNypvLTc5OSpCKzIwNDg+PjEyLEI9USxmWzArY109citDLGZbNytjXT1yLUMsZlsxK2NdPUkrQixmWzYrY109SS1CLGZbMitjXT1nK28sZls1K2NdPWctbyxmWzMrY109bithLGZbNCtjXT1uLWEpOihRPTU3OTMqZlswK2NdKzUxMj4+MTAsZlswK2NdPVEsZlsxK2NdPVEsZlsyK2NdPVEsZlszK2NdPVEsZls0K2NdPVEsZls1K2NdPVEsZls2K2NdPVEsZls3K2NdPVEpfWZvcihFPTA7RTw4OysrRSl7dmFyIGg9RTswIT09Zls4K2hdfHwwIT09ZlsxNitoXXx8MCE9PWZbMjQraF18fDAhPT1mWzMyK2hdfHwwIT09Zls0MCtoXXx8MCE9PWZbNDgraF18fDAhPT1mWzU2K2hdPyhyPTU3OTMqZlswK2hdKzIwNDg+PjEyLEk9NTc5MypmWzMyK2hdKzIwNDg+PjEyLGc9ZlsxNitoXSxuPWZbNDgraF0sYT0yODk2KihmWzgraF0tZls1NitoXSkrMjA0OD4+MTIsQz0yODk2KihmWzgraF0rZls1NitoXSkrMjA0OD4+MTIsbz1mWzI0K2hdLFE9ci1JKzE+PjEscj1yK0krMT4+MSxJPVEsUT0zNzg0KmcrMTU2NypuKzIwNDg+PjEyLGc9MTU2NypnLTM3ODQqbisyMDQ4Pj4xMixuPVEsUT1hLShCPWZbNDAraF0pKzE+PjEsYT1hK0IrMT4+MSxCPVEsUT1DK28rMT4+MSxvPUMtbysxPj4xLEM9USxRPXItbisxPj4xLHI9cituKzE+PjEsbj1RLFE9SS1nKzE+PjEsST1JK2crMT4+MSxnPVEsUT0yMjc2KmErMzQwNipDKzIwNDg+PjEyLGE9MzQwNiphLTIyNzYqQysyMDQ4Pj4xMixDPVEsUT03OTkqbys0MDE3KkIrMjA0OD4+MTIsbz00MDE3Km8tNzk5KkIrMjA0OD4+MTIsQj1RLGZbMCtoXT1yK0MsZls1NitoXT1yLUMsZls4K2hdPUkrQixmWzQ4K2hdPUktQixmWzE2K2hdPWcrbyxmWzQwK2hdPWctbyxmWzI0K2hdPW4rYSxmWzMyK2hdPW4tYSk6KFE9NTc5MyppW0UrMF0rODE5Mj4+MTQsZlswK2hdPVEsZls4K2hdPVEsZlsxNitoXT1RLGZbMjQraF09USxmWzMyK2hdPVEsZls0MCtoXT1RLGZbNDgraF09USxmWzU2K2hdPVEpfWZvcihFPTA7RTw2NDsrK0Upe3ZhciBsPTEyOCsoZltFXSs4Pj40KTt0W0VdPWw8MD8wOmw+MjU1PzI1NTpsfX1mb3IodmFyIG89MDtvPHI7bysrKXtmb3IodmFyIEI9bzw8MyxDPTA7Qzw4O0MrKyl0LnB1c2gobmV3IFVpbnQ4QXJyYXkoSSkpO2Zvcih2YXIgUT0wO1E8aTtRKyspe2EoZS5ibG9ja3Nbb11bUV0sbixnKTtmb3IodmFyIEU9MCxzPVE8PDMsZj0wO2Y8ODtmKyspZm9yKHZhciBjPXRbQitmXSxoPTA7aDw4O2grKyljW3MraF09bltFKytdfX1yZXR1cm4gdH12YXIgYj1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoKXtCKHRoaXMsQSksdGhpcy5qZmlmPW51bGwsdGhpcy5hZG9iZT1udWxsLHRoaXMucXVhbnRpemF0aW9uVGFibGVzPVtdLHRoaXMuaHVmZm1hblRhYmxlc0FDPVtdLHRoaXMuaHVmZm1hblRhYmxlc0RDPVtdLHRoaXMucmVzZXRGcmFtZXMoKX1yZXR1cm4gUShBLFt7a2V5OlxcXCJyZXNldEZyYW1lc1xcXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmZyYW1lcz1bXX19LHtrZXk6XFxcInBhcnNlXFxcIix2YWx1ZTpmdW5jdGlvbihBKXt2YXIgZT0wO2Z1bmN0aW9uIHQoKXt2YXIgdD1BW2VdPDw4fEFbZSsxXTtyZXR1cm4gZSs9Mix0fWZ1bmN0aW9uIGkoQSl7dmFyIGUsdCxpPTAscj0wO2Zvcih0IGluIEEuY29tcG9uZW50cylBLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkodCkmJihpPChlPUEuY29tcG9uZW50c1t0XSkuaCYmKGk9ZS5oKSxyPGUudiYmKHI9ZS52KSk7dmFyIEk9TWF0aC5jZWlsKEEuc2FtcGxlc1BlckxpbmUvOC9pKSxnPU1hdGguY2VpbChBLnNjYW5MaW5lcy84L3IpO2Zvcih0IGluIEEuY29tcG9uZW50cylpZihBLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkodCkpe2U9QS5jb21wb25lbnRzW3RdO2Zvcih2YXIgbj1NYXRoLmNlaWwoTWF0aC5jZWlsKEEuc2FtcGxlc1BlckxpbmUvOCkqZS5oL2kpLGE9TWF0aC5jZWlsKE1hdGguY2VpbChBLnNjYW5MaW5lcy84KSplLnYvciksbz1JKmUuaCxCPWcqZS52LEM9W10sUT0wO1E8QjtRKyspe2Zvcih2YXIgRT1bXSxzPTA7czxvO3MrKylFLnB1c2gobmV3IEludDMyQXJyYXkoNjQpKTtDLnB1c2goRSl9ZS5ibG9ja3NQZXJMaW5lPW4sZS5ibG9ja3NQZXJDb2x1bW49YSxlLmJsb2Nrcz1DfUEubWF4SD1pLEEubWF4Vj1yLEEubWN1c1BlckxpbmU9SSxBLm1jdXNQZXJDb2x1bW49Z312YXIgcixJLGc9dCgpO2lmKDY1NDk2IT09Zyl0aHJvdyBuZXcgRXJyb3IoXFxcIlNPSSBub3QgZm91bmRcXFwiKTtmb3IoZz10KCk7NjU0OTchPT1nOyl7c3dpdGNoKGcpe2Nhc2UgNjUyODA6YnJlYWs7Y2FzZSA2NTUwNDpjYXNlIDY1NTA1OmNhc2UgNjU1MDY6Y2FzZSA2NTUwNzpjYXNlIDY1NTA4OmNhc2UgNjU1MDk6Y2FzZSA2NTUxMDpjYXNlIDY1NTExOmNhc2UgNjU1MTI6Y2FzZSA2NTUxMzpjYXNlIDY1NTE0OmNhc2UgNjU1MTU6Y2FzZSA2NTUxNjpjYXNlIDY1NTE3OmNhc2UgNjU1MTg6Y2FzZSA2NTUxOTpjYXNlIDY1NTM0OnZhciBuPShyPXZvaWQgMCxJPXZvaWQgMCxyPXQoKSxJPUEuc3ViYXJyYXkoZSxlK3ItMiksZSs9SS5sZW5ndGgsSSk7NjU1MDQ9PT1nJiY3ND09PW5bMF0mJjcwPT09blsxXSYmNzM9PT1uWzJdJiY3MD09PW5bM10mJjA9PT1uWzRdJiYodGhpcy5qZmlmPXt2ZXJzaW9uOnttYWpvcjpuWzVdLG1pbm9yOm5bNl19LGRlbnNpdHlVbml0czpuWzddLHhEZW5zaXR5Om5bOF08PDh8bls5XSx5RGVuc2l0eTpuWzEwXTw8OHxuWzExXSx0aHVtYldpZHRoOm5bMTJdLHRodW1iSGVpZ2h0Om5bMTNdLHRodW1iRGF0YTpuLnN1YmFycmF5KDE0LDE0KzMqblsxMl0qblsxM10pfSksNjU1MTg9PT1nJiY2NT09PW5bMF0mJjEwMD09PW5bMV0mJjExMT09PW5bMl0mJjk4PT09blszXSYmMTAxPT09bls0XSYmMD09PW5bNV0mJih0aGlzLmFkb2JlPXt2ZXJzaW9uOm5bNl0sZmxhZ3MwOm5bN108PDh8bls4XSxmbGFnczE6bls5XTw8OHxuWzEwXSx0cmFuc2Zvcm1Db2RlOm5bMTFdfSk7YnJlYWs7Y2FzZSA2NTQ5OTpmb3IodmFyIGE9dCgpK2UtMjtlPGE7KXt2YXIgbz1BW2UrK10sQj1uZXcgSW50MzJBcnJheSg2NCk7aWYobz4+ND09MClmb3IodmFyIEM9MDtDPDY0O0MrKyl7Qlt2W0NdXT1BW2UrK119ZWxzZXtpZihvPj40IT0xKXRocm93IG5ldyBFcnJvcihcXFwiRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWNcXFwiKTtmb3IodmFyIFE9MDtRPDY0O1ErKyl7Qlt2W1FdXT10KCl9fXRoaXMucXVhbnRpemF0aW9uVGFibGVzWzE1Jm9dPUJ9YnJlYWs7Y2FzZSA2NTQ3MjpjYXNlIDY1NDczOmNhc2UgNjU0NzQ6dCgpO2Zvcih2YXIgRT17ZXh0ZW5kZWQ6NjU0NzM9PT1nLHByb2dyZXNzaXZlOjY1NDc0PT09ZyxwcmVjaXNpb246QVtlKytdLHNjYW5MaW5lczp0KCksc2FtcGxlc1BlckxpbmU6dCgpLGNvbXBvbmVudHM6e30sY29tcG9uZW50c09yZGVyOltdfSxzPUFbZSsrXSxmPXZvaWQgMCxjPTA7YzxzO2MrKyl7Zj1BW2VdO3ZhciBoPUFbZSsxXT4+NCxsPTE1JkFbZSsxXSx1PUFbZSsyXTtFLmNvbXBvbmVudHNPcmRlci5wdXNoKGYpLEUuY29tcG9uZW50c1tmXT17aDpoLHY6bCxxdWFudGl6YXRpb25JZHg6dX0sZSs9M31pKEUpLHRoaXMuZnJhbWVzLnB1c2goRSk7YnJlYWs7Y2FzZSA2NTQ3Njpmb3IodmFyIHc9dCgpLGQ9MjtkPHc7KXtmb3IodmFyIEQ9QVtlKytdLHk9bmV3IFVpbnQ4QXJyYXkoMTYpLGs9MCxwPTA7cDwxNjtwKyssZSsrKXlbcF09QVtlXSxrKz15W3BdO2Zvcih2YXIgbT1uZXcgVWludDhBcnJheShrKSxHPTA7RzxrO0crKyxlKyspbVtHXT1BW2VdO2QrPTE3K2ssRD4+ND09MD90aGlzLmh1ZmZtYW5UYWJsZXNEQ1sxNSZEXT1SKHksbSk6dGhpcy5odWZmbWFuVGFibGVzQUNbMTUmRF09Uih5LG0pfWJyZWFrO2Nhc2UgNjU1MDE6dCgpLHRoaXMucmVzZXRJbnRlcnZhbD10KCk7YnJlYWs7Y2FzZSA2NTQ5ODp0KCk7Zm9yKHZhciBGPUFbZSsrXSxTPVtdLEw9dGhpcy5mcmFtZXNbMF0sYj0wO2I8RjtiKyspe3ZhciBNPUwuY29tcG9uZW50c1tBW2UrK11dLE49QVtlKytdO00uaHVmZm1hblRhYmxlREM9dGhpcy5odWZmbWFuVGFibGVzRENbTj4+NF0sTS5odWZmbWFuVGFibGVBQz10aGlzLmh1ZmZtYW5UYWJsZXNBQ1sxNSZOXSxTLnB1c2goTSl9dmFyIHg9QVtlKytdLEo9QVtlKytdLHE9QVtlKytdLFk9VShBLGUsTCxTLHRoaXMucmVzZXRJbnRlcnZhbCx4LEoscT4+NCwxNSZxKTtlKz1ZO2JyZWFrO2Nhc2UgNjU1MzU6MjU1IT09QVtlXSYmZS0tO2JyZWFrO2RlZmF1bHQ6aWYoMjU1PT09QVtlLTNdJiZBW2UtMl0+PTE5MiYmQVtlLTJdPD0yNTQpe2UtPTM7YnJlYWt9dGhyb3cgbmV3IEVycm9yKFxcXCJ1bmtub3duIEpQRUcgbWFya2VyIFxcXCIuY29uY2F0KGcudG9TdHJpbmcoMTYpKSl9Zz10KCl9fX0se2tleTpcXFwiZ2V0UmVzdWx0XFxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBBPXRoaXMuZnJhbWVzO2lmKDA9PT10aGlzLmZyYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFxcXCJubyBmcmFtZXMgd2VyZSBkZWNvZGVkXFxcIik7dGhpcy5mcmFtZXMubGVuZ3RoPjEmJmNvbnNvbGUud2FybihcXFwibW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkXFxcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLmZyYW1lcy5sZW5ndGg7ZSsrKWZvcih2YXIgdD10aGlzLmZyYW1lc1tlXS5jb21wb25lbnRzLGk9MCxyPU9iamVjdC5rZXlzKHQpO2k8ci5sZW5ndGg7aSsrKXt2YXIgST1yW2ldO3RbSV0ucXVhbnRpemF0aW9uVGFibGU9dGhpcy5xdWFudGl6YXRpb25UYWJsZXNbdFtJXS5xdWFudGl6YXRpb25JZHhdLGRlbGV0ZSB0W0ldLnF1YW50aXphdGlvbklkeH1mb3IodmFyIGc9QVswXSxuPWcuY29tcG9uZW50cyxhPWcuY29tcG9uZW50c09yZGVyLG89W10sQj1nLnNhbXBsZXNQZXJMaW5lLEM9Zy5zY2FuTGluZXMsUT0wO1E8YS5sZW5ndGg7USsrKXt2YXIgRT1uW2FbUV1dO28ucHVzaCh7bGluZXM6TCgwLEUpLHNjYWxlWDpFLmgvZy5tYXhILHNjYWxlWTpFLnYvZy5tYXhWfSl9Zm9yKHZhciBzPW5ldyBVaW50OEFycmF5KEIqQypvLmxlbmd0aCksZj0wLGM9MDtjPEM7KytjKWZvcih2YXIgaD0wO2g8QjsrK2gpZm9yKHZhciBsPTA7bDxvLmxlbmd0aDsrK2wpe3ZhciB1PW9bbF07c1tmXT11LmxpbmVzWzB8Yyp1LnNjYWxlWV1bMHxoKnUuc2NhbGVYXSwrK2Z9cmV0dXJuIHN9fV0pLEF9KCksTT1mdW5jdGlvbihBKXtzKHQsdyk7dmFyIGU9Uyh0KTtmdW5jdGlvbiB0KEEpe3ZhciBpO3JldHVybiBCKHRoaXMsdCksKGk9ZS5jYWxsKHRoaXMpKS5yZWFkZXI9bmV3IGIsQS5KUEVHVGFibGVzJiZpLnJlYWRlci5wYXJzZShBLkpQRUdUYWJsZXMpLGl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3JldHVybiB0aGlzLnJlYWRlci5yZXNldEZyYW1lcygpLHRoaXMucmVhZGVyLnBhcnNlKG5ldyBVaW50OEFycmF5KEEpKSx0aGlzLnJlYWRlci5nZXRSZXN1bHQoKS5idWZmZXJ9fV0pLHR9KCksTj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0Ok19KTtmdW5jdGlvbiB4KEEpe2Zvcih2YXIgZT1BLmxlbmd0aDstLWU+PTA7KUFbZV09MH14KG5ldyBBcnJheSg1NzYpKSx4KG5ldyBBcnJheSg2MCkpLHgobmV3IEFycmF5KDUxMikpLHgobmV3IEFycmF5KDI1NikpLHgobmV3IEFycmF5KDI5KSkseChuZXcgQXJyYXkoMzApKTt2YXIgSj1mdW5jdGlvbihBLGUsdCxpKXtmb3IodmFyIHI9NjU1MzUmQXwwLEk9QT4+PjE2JjY1NTM1fDAsZz0wOzAhPT10Oyl7dC09Zz10PjJlMz8yZTM6dDtkb3tJPUkrKHI9citlW2krK118MCl8MH13aGlsZSgtLWcpO3IlPTY1NTIxLEklPTY1NTIxfXJldHVybiByfEk8PDE2fDB9LHE9bmV3IFVpbnQzMkFycmF5KGZ1bmN0aW9uKCl7Zm9yKHZhciBBLGU9W10sdD0wO3Q8MjU2O3QrKyl7QT10O2Zvcih2YXIgaT0wO2k8ODtpKyspQT0xJkE/Mzk4ODI5MjM4NF5BPj4+MTpBPj4+MTtlW3RdPUF9cmV0dXJuIGV9KCkpLFk9ZnVuY3Rpb24oQSxlLHQsaSl7dmFyIHI9cSxJPWkrdDtBXj0tMTtmb3IodmFyIGc9aTtnPEk7ZysrKUE9QT4+PjheclsyNTUmKEFeZVtnXSldO3JldHVybi0xXkF9LEs9ezI6XFxcIm5lZWQgZGljdGlvbmFyeVxcXCIsMTpcXFwic3RyZWFtIGVuZFxcXCIsMDpcXFwiXFxcIixcXFwiLTFcXFwiOlxcXCJmaWxlIGVycm9yXFxcIixcXFwiLTJcXFwiOlxcXCJzdHJlYW0gZXJyb3JcXFwiLFxcXCItM1xcXCI6XFxcImRhdGEgZXJyb3JcXFwiLFxcXCItNFxcXCI6XFxcImluc3VmZmljaWVudCBtZW1vcnlcXFwiLFxcXCItNVxcXCI6XFxcImJ1ZmZlciBlcnJvclxcXCIsXFxcIi02XFxcIjpcXFwiaW5jb21wYXRpYmxlIHZlcnNpb25cXFwifSxIPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfTUVNX0VSUk9SOi00LFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9LE89ZnVuY3Rpb24oQSxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsZSl9LFA9ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtlLmxlbmd0aDspe3ZhciBpPWUuc2hpZnQoKTtpZihpKXtpZihcXFwib2JqZWN0XFxcIiE9PXQoaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihpK1xcXCJtdXN0IGJlIG5vbi1vYmplY3RcXFwiKTtmb3IodmFyIHIgaW4gaSlPKGkscikmJihBW3JdPWlbcl0pfX1yZXR1cm4gQX0sVD1mdW5jdGlvbihBKXtmb3IodmFyIGU9MCx0PTAsaT1BLmxlbmd0aDt0PGk7dCsrKWUrPUFbdF0ubGVuZ3RoO2Zvcih2YXIgcj1uZXcgVWludDhBcnJheShlKSxJPTAsZz0wLG49QS5sZW5ndGg7STxuO0krKyl7dmFyIGE9QVtJXTtyLnNldChhLGcpLGcrPWEubGVuZ3RofXJldHVybiByfSxWPSEwO3RyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpfWNhdGNoKEEpe1Y9ITF9Zm9yKHZhciBfPW5ldyBVaW50OEFycmF5KDI1NiksWD0wO1g8MjU2O1grKylfW1hdPVg+PTI1Mj82Olg+PTI0OD81Olg+PTI0MD80Olg+PTIyND8zOlg+PTE5Mj8yOjE7X1syNTRdPV9bMjU0XT0xO3ZhciBaPWZ1bmN0aW9uKEEpe2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBUZXh0RW5jb2RlciYmVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZSlyZXR1cm4obmV3IFRleHRFbmNvZGVyKS5lbmNvZGUoQSk7dmFyIGUsdCxpLHIsSSxnPUEubGVuZ3RoLG49MDtmb3Iocj0wO3I8ZztyKyspNTUyOTY9PSg2NDUxMiYodD1BLmNoYXJDb2RlQXQocikpKSYmcisxPGcmJjU2MzIwPT0oNjQ1MTImKGk9QS5jaGFyQ29kZUF0KHIrMSkpKSYmKHQ9NjU1MzYrKHQtNTUyOTY8PDEwKSsoaS01NjMyMCkscisrKSxuKz10PDEyOD8xOnQ8MjA0OD8yOnQ8NjU1MzY/Mzo0O2ZvcihlPW5ldyBVaW50OEFycmF5KG4pLEk9MCxyPTA7STxuO3IrKyk1NTI5Nj09KDY0NTEyJih0PUEuY2hhckNvZGVBdChyKSkpJiZyKzE8ZyYmNTYzMjA9PSg2NDUxMiYoaT1BLmNoYXJDb2RlQXQocisxKSkpJiYodD02NTUzNisodC01NTI5Njw8MTApKyhpLTU2MzIwKSxyKyspLHQ8MTI4P2VbSSsrXT10OnQ8MjA0OD8oZVtJKytdPTE5Mnx0Pj4+NixlW0krK109MTI4fDYzJnQpOnQ8NjU1MzY/KGVbSSsrXT0yMjR8dD4+PjEyLGVbSSsrXT0xMjh8dD4+PjYmNjMsZVtJKytdPTEyOHw2MyZ0KTooZVtJKytdPTI0MHx0Pj4+MTgsZVtJKytdPTEyOHx0Pj4+MTImNjMsZVtJKytdPTEyOHx0Pj4+NiY2MyxlW0krK109MTI4fDYzJnQpO3JldHVybiBlfSxqPWZ1bmN0aW9uKEEsZSl7dmFyIHQsaSxyPWV8fEEubGVuZ3RoO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBUZXh0RGVjb2RlciYmVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSlyZXR1cm4obmV3IFRleHREZWNvZGVyKS5kZWNvZGUoQS5zdWJhcnJheSgwLGUpKTt2YXIgST1uZXcgQXJyYXkoMipyKTtmb3IoaT0wLHQ9MDt0PHI7KXt2YXIgZz1BW3QrK107aWYoZzwxMjgpSVtpKytdPWc7ZWxzZXt2YXIgbj1fW2ddO2lmKG4+NClJW2krK109NjU1MzMsdCs9bi0xO2Vsc2V7Zm9yKGcmPTI9PT1uPzMxOjM9PT1uPzE1Ojc7bj4xJiZ0PHI7KWc9Zzw8Nnw2MyZBW3QrK10sbi0tO24+MT9JW2krK109NjU1MzM6Zzw2NTUzNj9JW2krK109ZzooZy09NjU1MzYsSVtpKytdPTU1Mjk2fGc+PjEwJjEwMjMsSVtpKytdPTU2MzIwfDEwMjMmZyl9fX1yZXR1cm4gZnVuY3Rpb24oQSxlKXtpZihlPDY1NTM0JiZBLnN1YmFycmF5JiZWKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsQS5sZW5ndGg9PT1lP0E6QS5zdWJhcnJheSgwLGUpKTtmb3IodmFyIHQ9XFxcIlxcXCIsaT0wO2k8ZTtpKyspdCs9U3RyaW5nLmZyb21DaGFyQ29kZShBW2ldKTtyZXR1cm4gdH0oSSxpKX0sVz1mdW5jdGlvbihBLGUpeyhlPWV8fEEubGVuZ3RoKT5BLmxlbmd0aCYmKGU9QS5sZW5ndGgpO2Zvcih2YXIgdD1lLTE7dD49MCYmMTI4PT0oMTkyJkFbdF0pOyl0LS07cmV0dXJuIHQ8MHx8MD09PXQ/ZTp0K19bQVt0XV0+ZT90OmV9O3ZhciB6PWZ1bmN0aW9uKCl7dGhpcy5pbnB1dD1udWxsLHRoaXMubmV4dF9pbj0wLHRoaXMuYXZhaWxfaW49MCx0aGlzLnRvdGFsX2luPTAsdGhpcy5vdXRwdXQ9bnVsbCx0aGlzLm5leHRfb3V0PTAsdGhpcy5hdmFpbF9vdXQ9MCx0aGlzLnRvdGFsX291dD0wLHRoaXMubXNnPVxcXCJcXFwiLHRoaXMuc3RhdGU9bnVsbCx0aGlzLmRhdGFfdHlwZT0yLHRoaXMuYWRsZXI9MH0sJD1mdW5jdGlvbihBLGUpe3ZhciB0LGkscixJLGcsbixhLG8sQixDLFEsRSxzLGYsYyxoLGwsdSx3LGQsRCx5LGsscCxtPUEuc3RhdGU7dD1BLm5leHRfaW4saz1BLmlucHV0LGk9dCsoQS5hdmFpbF9pbi01KSxyPUEubmV4dF9vdXQscD1BLm91dHB1dCxJPXItKGUtQS5hdmFpbF9vdXQpLGc9cisoQS5hdmFpbF9vdXQtMjU3KSxuPW0uZG1heCxhPW0ud3NpemUsbz1tLndoYXZlLEI9bS53bmV4dCxDPW0ud2luZG93LFE9bS5ob2xkLEU9bS5iaXRzLHM9bS5sZW5jb2RlLGY9bS5kaXN0Y29kZSxjPSgxPDxtLmxlbmJpdHMpLTEsaD0oMTw8bS5kaXN0Yml0cyktMTtBOmRve0U8MTUmJihRKz1rW3QrK108PEUsRSs9OCxRKz1rW3QrK108PEUsRSs9OCksbD1zW1EmY107ZTpmb3IoOzspe2lmKFE+Pj49dT1sPj4+MjQsRS09dSwwPT09KHU9bD4+PjE2JjI1NSkpcFtyKytdPTY1NTM1Jmw7ZWxzZXtpZighKDE2JnUpKXtpZigwPT0oNjQmdSkpe2w9c1soNjU1MzUmbCkrKFEmKDE8PHUpLTEpXTtjb250aW51ZSBlfWlmKDMyJnUpe20ubW9kZT0xMjticmVhayBBfUEubXNnPVxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcXFwiLG0ubW9kZT0zMDticmVhayBBfXc9NjU1MzUmbCwodSY9MTUpJiYoRTx1JiYoUSs9a1t0KytdPDxFLEUrPTgpLHcrPVEmKDE8PHUpLTEsUT4+Pj11LEUtPXUpLEU8MTUmJihRKz1rW3QrK108PEUsRSs9OCxRKz1rW3QrK108PEUsRSs9OCksbD1mW1EmaF07dDpmb3IoOzspe2lmKFE+Pj49dT1sPj4+MjQsRS09dSwhKDE2Jih1PWw+Pj4xNiYyNTUpKSl7aWYoMD09KDY0JnUpKXtsPWZbKDY1NTM1JmwpKyhRJigxPDx1KS0xKV07Y29udGludWUgdH1BLm1zZz1cXFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXFxcIixtLm1vZGU9MzA7YnJlYWsgQX1pZihkPTY1NTM1JmwsRTwodSY9MTUpJiYoUSs9a1t0KytdPDxFLChFKz04KTx1JiYoUSs9a1t0KytdPDxFLEUrPTgpKSwoZCs9USYoMTw8dSktMSk+bil7QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXFxcIixtLm1vZGU9MzA7YnJlYWsgQX1pZihRPj4+PXUsRS09dSxkPih1PXItSSkpe2lmKCh1PWQtdSk+byYmbS5zYW5lKXtBLm1zZz1cXFwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcXFwiLG0ubW9kZT0zMDticmVhayBBfWlmKEQ9MCx5PUMsMD09PUIpe2lmKEQrPWEtdSx1PHcpe3ctPXU7ZG97cFtyKytdPUNbRCsrXX13aGlsZSgtLXUpO0Q9ci1kLHk9cH19ZWxzZSBpZihCPHUpe2lmKEQrPWErQi11LCh1LT1CKTx3KXt3LT11O2Rve3BbcisrXT1DW0QrK119d2hpbGUoLS11KTtpZihEPTAsQjx3KXt3LT11PUI7ZG97cFtyKytdPUNbRCsrXX13aGlsZSgtLXUpO0Q9ci1kLHk9cH19fWVsc2UgaWYoRCs9Qi11LHU8dyl7dy09dTtkb3twW3IrK109Q1tEKytdfXdoaWxlKC0tdSk7RD1yLWQseT1wfWZvcig7dz4yOylwW3IrK109eVtEKytdLHBbcisrXT15W0QrK10scFtyKytdPXlbRCsrXSx3LT0zO3cmJihwW3IrK109eVtEKytdLHc+MSYmKHBbcisrXT15W0QrK10pKX1lbHNle0Q9ci1kO2Rve3BbcisrXT1wW0QrK10scFtyKytdPXBbRCsrXSxwW3IrK109cFtEKytdLHctPTN9d2hpbGUodz4yKTt3JiYocFtyKytdPXBbRCsrXSx3PjEmJihwW3IrK109cFtEKytdKSl9YnJlYWt9fWJyZWFrfX13aGlsZSh0PGkmJnI8Zyk7dC09dz1FPj4zLFEmPSgxPDwoRS09dzw8MykpLTEsQS5uZXh0X2luPXQsQS5uZXh0X291dD1yLEEuYXZhaWxfaW49dDxpP2ktdCs1OjUtKHQtaSksQS5hdmFpbF9vdXQ9cjxnP2ctcisyNTc6MjU3LShyLWcpLG0uaG9sZD1RLG0uYml0cz1FfSxBQT1uZXcgVWludDE2QXJyYXkoWzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsMCwwXSksZUE9bmV3IFVpbnQ4QXJyYXkoWzE2LDE2LDE2LDE2LDE2LDE2LDE2LDE2LDE3LDE3LDE3LDE3LDE4LDE4LDE4LDE4LDE5LDE5LDE5LDE5LDIwLDIwLDIwLDIwLDIxLDIxLDIxLDIxLDE2LDcyLDc4XSksdEE9bmV3IFVpbnQxNkFycmF5KFsxLDIsMyw0LDUsNyw5LDEzLDE3LDI1LDMzLDQ5LDY1LDk3LDEyOSwxOTMsMjU3LDM4NSw1MTMsNzY5LDEwMjUsMTUzNywyMDQ5LDMwNzMsNDA5Nyw2MTQ1LDgxOTMsMTIyODksMTYzODUsMjQ1NzcsMCwwXSksaUE9bmV3IFVpbnQ4QXJyYXkoWzE2LDE2LDE2LDE2LDE3LDE3LDE4LDE4LDE5LDE5LDIwLDIwLDIxLDIxLDIyLDIyLDIzLDIzLDI0LDI0LDI1LDI1LDI2LDI2LDI3LDI3LDI4LDI4LDI5LDI5LDY0LDY0XSksckE9ZnVuY3Rpb24oQSxlLHQsaSxyLEksZyxuKXt2YXIgYSxvLEIsQyxRLEUscyxmLGMsaD1uLmJpdHMsbD0wLHU9MCx3PTAsZD0wLEQ9MCx5PTAsaz0wLHA9MCxtPTAsRz0wLEY9bnVsbCxTPTAsdj1uZXcgVWludDE2QXJyYXkoMTYpLFI9bmV3IFVpbnQxNkFycmF5KDE2KSxVPW51bGwsTD0wO2ZvcihsPTA7bDw9MTU7bCsrKXZbbF09MDtmb3IodT0wO3U8aTt1KyspdltlW3QrdV1dKys7Zm9yKEQ9aCxkPTE1O2Q+PTEmJjA9PT12W2RdO2QtLSk7aWYoRD5kJiYoRD1kKSwwPT09ZClyZXR1cm4gcltJKytdPTIwOTcxNTIwLHJbSSsrXT0yMDk3MTUyMCxuLmJpdHM9MSwwO2Zvcih3PTE7dzxkJiYwPT09dlt3XTt3KyspO2ZvcihEPHcmJihEPXcpLHA9MSxsPTE7bDw9MTU7bCsrKWlmKHA8PD0xLChwLT12W2xdKTwwKXJldHVybi0xO2lmKHA+MCYmKDA9PT1BfHwxIT09ZCkpcmV0dXJuLTE7Zm9yKFJbMV09MCxsPTE7bDwxNTtsKyspUltsKzFdPVJbbF0rdltsXTtmb3IodT0wO3U8aTt1KyspMCE9PWVbdCt1XSYmKGdbUltlW3QrdV1dKytdPXUpO2lmKDA9PT1BPyhGPVU9ZyxFPTE5KToxPT09QT8oRj1BQSxTLT0yNTcsVT1lQSxMLT0yNTcsRT0yNTYpOihGPXRBLFU9aUEsRT0tMSksRz0wLHU9MCxsPXcsUT1JLHk9RCxrPTAsQj0tMSxDPShtPTE8PEQpLTEsMT09PUEmJm0+ODUyfHwyPT09QSYmbT41OTIpcmV0dXJuIDE7Zm9yKDs7KXtzPWwtayxnW3VdPEU/KGY9MCxjPWdbdV0pOmdbdV0+RT8oZj1VW0wrZ1t1XV0sYz1GW1MrZ1t1XV0pOihmPTk2LGM9MCksYT0xPDxsLWssdz1vPTE8PHk7ZG97cltRKyhHPj5rKSsoby09YSldPXM8PDI0fGY8PDE2fGN8MH13aGlsZSgwIT09byk7Zm9yKGE9MTw8bC0xO0cmYTspYT4+PTE7aWYoMCE9PWE/KEcmPWEtMSxHKz1hKTpHPTAsdSsrLDA9PS0tdltsXSl7aWYobD09PWQpYnJlYWs7bD1lW3QrZ1t1XV19aWYobD5EJiYoRyZDKSE9PUIpe2ZvcigwPT09ayYmKGs9RCksUSs9dyxwPTE8PCh5PWwtayk7eStrPGQmJiEoKHAtPXZbeStrXSk8PTApOyl5KysscDw8PTE7aWYobSs9MTw8eSwxPT09QSYmbT44NTJ8fDI9PT1BJiZtPjU5MilyZXR1cm4gMTtyW0I9RyZDXT1EPDwyNHx5PDwxNnxRLUl8MH19cmV0dXJuIDAhPT1HJiYocltRK0ddPWwtazw8MjR8NjQ8PDE2fDApLG4uYml0cz1ELDB9LElBPUguWl9GSU5JU0gsZ0E9SC5aX0JMT0NLLG5BPUguWl9UUkVFUyxhQT1ILlpfT0ssb0E9SC5aX1NUUkVBTV9FTkQsQkE9SC5aX05FRURfRElDVCxDQT1ILlpfU1RSRUFNX0VSUk9SLFFBPUguWl9EQVRBX0VSUk9SLEVBPUguWl9NRU1fRVJST1Isc0E9SC5aX0JVRl9FUlJPUixmQT1ILlpfREVGTEFURUQsY0E9ZnVuY3Rpb24oQSl7cmV0dXJuKEE+Pj4yNCYyNTUpKyhBPj4+OCY2NTI4MCkrKCg2NTI4MCZBKTw8OCkrKCgyNTUmQSk8PDI0KX07ZnVuY3Rpb24gaEEoKXt0aGlzLm1vZGU9MCx0aGlzLmxhc3Q9ITEsdGhpcy53cmFwPTAsdGhpcy5oYXZlZGljdD0hMSx0aGlzLmZsYWdzPTAsdGhpcy5kbWF4PTAsdGhpcy5jaGVjaz0wLHRoaXMudG90YWw9MCx0aGlzLmhlYWQ9bnVsbCx0aGlzLndiaXRzPTAsdGhpcy53c2l6ZT0wLHRoaXMud2hhdmU9MCx0aGlzLnduZXh0PTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLmhvbGQ9MCx0aGlzLmJpdHM9MCx0aGlzLmxlbmd0aD0wLHRoaXMub2Zmc2V0PTAsdGhpcy5leHRyYT0wLHRoaXMubGVuY29kZT1udWxsLHRoaXMuZGlzdGNvZGU9bnVsbCx0aGlzLmxlbmJpdHM9MCx0aGlzLmRpc3RiaXRzPTAsdGhpcy5uY29kZT0wLHRoaXMubmxlbj0wLHRoaXMubmRpc3Q9MCx0aGlzLmhhdmU9MCx0aGlzLm5leHQ9bnVsbCx0aGlzLmxlbnM9bmV3IFVpbnQxNkFycmF5KDMyMCksdGhpcy53b3JrPW5ldyBVaW50MTZBcnJheSgyODgpLHRoaXMubGVuZHluPW51bGwsdGhpcy5kaXN0ZHluPW51bGwsdGhpcy5zYW5lPTAsdGhpcy5iYWNrPTAsdGhpcy53YXM9MH12YXIgbEEsdUEsd0E9ZnVuY3Rpb24oQSl7aWYoIUF8fCFBLnN0YXRlKXJldHVybiBDQTt2YXIgZT1BLnN0YXRlO3JldHVybiBBLnRvdGFsX2luPUEudG90YWxfb3V0PWUudG90YWw9MCxBLm1zZz1cXFwiXFxcIixlLndyYXAmJihBLmFkbGVyPTEmZS53cmFwKSxlLm1vZGU9MSxlLmxhc3Q9MCxlLmhhdmVkaWN0PTAsZS5kbWF4PTMyNzY4LGUuaGVhZD1udWxsLGUuaG9sZD0wLGUuYml0cz0wLGUubGVuY29kZT1lLmxlbmR5bj1uZXcgSW50MzJBcnJheSg4NTIpLGUuZGlzdGNvZGU9ZS5kaXN0ZHluPW5ldyBJbnQzMkFycmF5KDU5MiksZS5zYW5lPTEsZS5iYWNrPS0xLGFBfSxkQT1mdW5jdGlvbihBKXtpZighQXx8IUEuc3RhdGUpcmV0dXJuIENBO3ZhciBlPUEuc3RhdGU7cmV0dXJuIGUud3NpemU9MCxlLndoYXZlPTAsZS53bmV4dD0wLHdBKEEpfSxEQT1mdW5jdGlvbihBLGUpe3ZhciB0O2lmKCFBfHwhQS5zdGF0ZSlyZXR1cm4gQ0E7dmFyIGk9QS5zdGF0ZTtyZXR1cm4gZTwwPyh0PTAsZT0tZSk6KHQ9MSsoZT4+NCksZTw0OCYmKGUmPTE1KSksZSYmKGU8OHx8ZT4xNSk/Q0E6KG51bGwhPT1pLndpbmRvdyYmaS53Yml0cyE9PWUmJihpLndpbmRvdz1udWxsKSxpLndyYXA9dCxpLndiaXRzPWUsZEEoQSkpfSx5QT1mdW5jdGlvbihBLGUpe2lmKCFBKXJldHVybiBDQTt2YXIgdD1uZXcgaEE7QS5zdGF0ZT10LHQud2luZG93PW51bGw7dmFyIGk9REEoQSxlKTtyZXR1cm4gaSE9PWFBJiYoQS5zdGF0ZT1udWxsKSxpfSxrQT0hMCxwQT1mdW5jdGlvbihBKXtpZihrQSl7bEE9bmV3IEludDMyQXJyYXkoNTEyKSx1QT1uZXcgSW50MzJBcnJheSgzMik7Zm9yKHZhciBlPTA7ZTwxNDQ7KUEubGVuc1tlKytdPTg7Zm9yKDtlPDI1NjspQS5sZW5zW2UrK109OTtmb3IoO2U8MjgwOylBLmxlbnNbZSsrXT03O2Zvcig7ZTwyODg7KUEubGVuc1tlKytdPTg7Zm9yKHJBKDEsQS5sZW5zLDAsMjg4LGxBLDAsQS53b3JrLHtiaXRzOjl9KSxlPTA7ZTwzMjspQS5sZW5zW2UrK109NTtyQSgyLEEubGVucywwLDMyLHVBLDAsQS53b3JrLHtiaXRzOjV9KSxrQT0hMX1BLmxlbmNvZGU9bEEsQS5sZW5iaXRzPTksQS5kaXN0Y29kZT11QSxBLmRpc3RiaXRzPTV9LG1BPWZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByLEk9QS5zdGF0ZTtyZXR1cm4gbnVsbD09PUkud2luZG93JiYoSS53c2l6ZT0xPDxJLndiaXRzLEkud25leHQ9MCxJLndoYXZlPTAsSS53aW5kb3c9bmV3IFVpbnQ4QXJyYXkoSS53c2l6ZSkpLGk+PUkud3NpemU/KEkud2luZG93LnNldChlLnN1YmFycmF5KHQtSS53c2l6ZSx0KSwwKSxJLnduZXh0PTAsSS53aGF2ZT1JLndzaXplKTooKHI9SS53c2l6ZS1JLnduZXh0KT5pJiYocj1pKSxJLndpbmRvdy5zZXQoZS5zdWJhcnJheSh0LWksdC1pK3IpLEkud25leHQpLChpLT1yKT8oSS53aW5kb3cuc2V0KGUuc3ViYXJyYXkodC1pLHQpLDApLEkud25leHQ9aSxJLndoYXZlPUkud3NpemUpOihJLnduZXh0Kz1yLEkud25leHQ9PT1JLndzaXplJiYoSS53bmV4dD0wKSxJLndoYXZlPEkud3NpemUmJihJLndoYXZlKz1yKSkpLDB9LEdBPXtpbmZsYXRlUmVzZXQ6ZEEsaW5mbGF0ZVJlc2V0MjpEQSxpbmZsYXRlUmVzZXRLZWVwOndBLGluZmxhdGVJbml0OmZ1bmN0aW9uKEEpe3JldHVybiB5QShBLDE1KX0saW5mbGF0ZUluaXQyOnlBLGluZmxhdGU6ZnVuY3Rpb24oQSxlKXt2YXIgdCxpLHIsSSxnLG4sYSxvLEIsQyxRLEUscyxmLGMsaCxsLHUsdyxkLEQseSxrLHAsbT0wLEc9bmV3IFVpbnQ4QXJyYXkoNCksRj1uZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO2lmKCFBfHwhQS5zdGF0ZXx8IUEub3V0cHV0fHwhQS5pbnB1dCYmMCE9PUEuYXZhaWxfaW4pcmV0dXJuIENBOzEyPT09KHQ9QS5zdGF0ZSkubW9kZSYmKHQubW9kZT0xMyksZz1BLm5leHRfb3V0LHI9QS5vdXRwdXQsYT1BLmF2YWlsX291dCxJPUEubmV4dF9pbixpPUEuaW5wdXQsbj1BLmF2YWlsX2luLG89dC5ob2xkLEI9dC5iaXRzLEM9bixRPWEseT1hQTtBOmZvcig7Oylzd2l0Y2godC5tb2RlKXtjYXNlIDE6aWYoMD09PXQud3JhcCl7dC5tb2RlPTEzO2JyZWFrfWZvcig7QjwxNjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKDImdC53cmFwJiYzNTYxNT09PW8pe3QuY2hlY2s9MCxHWzBdPTI1NSZvLEdbMV09bz4+PjgmMjU1LHQuY2hlY2s9WSh0LmNoZWNrLEcsMiwwKSxvPTAsQj0wLHQubW9kZT0yO2JyZWFrfWlmKHQuZmxhZ3M9MCx0LmhlYWQmJih0LmhlYWQuZG9uZT0hMSksISgxJnQud3JhcCl8fCgoKDI1NSZvKTw8OCkrKG8+PjgpKSUzMSl7QS5tc2c9XFxcImluY29ycmVjdCBoZWFkZXIgY2hlY2tcXFwiLHQubW9kZT0zMDticmVha31pZigoMTUmbykhPT1mQSl7QS5tc2c9XFxcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXFxcIix0Lm1vZGU9MzA7YnJlYWt9aWYoQi09NCxEPTgrKDE1JihvPj4+PTQpKSwwPT09dC53Yml0cyl0LndiaXRzPUQ7ZWxzZSBpZihEPnQud2JpdHMpe0EubXNnPVxcXCJpbnZhbGlkIHdpbmRvdyBzaXplXFxcIix0Lm1vZGU9MzA7YnJlYWt9dC5kbWF4PTE8PHQud2JpdHMsQS5hZGxlcj10LmNoZWNrPTEsdC5tb2RlPTUxMiZvPzEwOjEyLG89MCxCPTA7YnJlYWs7Y2FzZSAyOmZvcig7QjwxNjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKHQuZmxhZ3M9bywoMjU1JnQuZmxhZ3MpIT09ZkEpe0EubXNnPVxcXCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFxcXCIsdC5tb2RlPTMwO2JyZWFrfWlmKDU3MzQ0JnQuZmxhZ3Mpe0EubXNnPVxcXCJ1bmtub3duIGhlYWRlciBmbGFncyBzZXRcXFwiLHQubW9kZT0zMDticmVha310LmhlYWQmJih0LmhlYWQudGV4dD1vPj44JjEpLDUxMiZ0LmZsYWdzJiYoR1swXT0yNTUmbyxHWzFdPW8+Pj44JjI1NSx0LmNoZWNrPVkodC5jaGVjayxHLDIsMCkpLG89MCxCPTAsdC5tb2RlPTM7Y2FzZSAzOmZvcig7QjwzMjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXQuaGVhZCYmKHQuaGVhZC50aW1lPW8pLDUxMiZ0LmZsYWdzJiYoR1swXT0yNTUmbyxHWzFdPW8+Pj44JjI1NSxHWzJdPW8+Pj4xNiYyNTUsR1szXT1vPj4+MjQmMjU1LHQuY2hlY2s9WSh0LmNoZWNrLEcsNCwwKSksbz0wLEI9MCx0Lm1vZGU9NDtjYXNlIDQ6Zm9yKDtCPDE2Oyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9dC5oZWFkJiYodC5oZWFkLnhmbGFncz0yNTUmbyx0LmhlYWQub3M9bz4+OCksNTEyJnQuZmxhZ3MmJihHWzBdPTI1NSZvLEdbMV09bz4+PjgmMjU1LHQuY2hlY2s9WSh0LmNoZWNrLEcsMiwwKSksbz0wLEI9MCx0Lm1vZGU9NTtjYXNlIDU6aWYoMTAyNCZ0LmZsYWdzKXtmb3IoO0I8MTY7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH10Lmxlbmd0aD1vLHQuaGVhZCYmKHQuaGVhZC5leHRyYV9sZW49byksNTEyJnQuZmxhZ3MmJihHWzBdPTI1NSZvLEdbMV09bz4+PjgmMjU1LHQuY2hlY2s9WSh0LmNoZWNrLEcsMiwwKSksbz0wLEI9MH1lbHNlIHQuaGVhZCYmKHQuaGVhZC5leHRyYT1udWxsKTt0Lm1vZGU9NjtjYXNlIDY6aWYoMTAyNCZ0LmZsYWdzJiYoKEU9dC5sZW5ndGgpPm4mJihFPW4pLEUmJih0LmhlYWQmJihEPXQuaGVhZC5leHRyYV9sZW4tdC5sZW5ndGgsdC5oZWFkLmV4dHJhfHwodC5oZWFkLmV4dHJhPW5ldyBVaW50OEFycmF5KHQuaGVhZC5leHRyYV9sZW4pKSx0LmhlYWQuZXh0cmEuc2V0KGkuc3ViYXJyYXkoSSxJK0UpLEQpKSw1MTImdC5mbGFncyYmKHQuY2hlY2s9WSh0LmNoZWNrLGksRSxJKSksbi09RSxJKz1FLHQubGVuZ3RoLT1FKSx0Lmxlbmd0aCkpYnJlYWsgQTt0Lmxlbmd0aD0wLHQubW9kZT03O2Nhc2UgNzppZigyMDQ4JnQuZmxhZ3Mpe2lmKDA9PT1uKWJyZWFrIEE7RT0wO2Rve0Q9aVtJK0UrK10sdC5oZWFkJiZEJiZ0Lmxlbmd0aDw2NTUzNiYmKHQuaGVhZC5uYW1lKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEQpKX13aGlsZShEJiZFPG4pO2lmKDUxMiZ0LmZsYWdzJiYodC5jaGVjaz1ZKHQuY2hlY2ssaSxFLEkpKSxuLT1FLEkrPUUsRClicmVhayBBfWVsc2UgdC5oZWFkJiYodC5oZWFkLm5hbWU9bnVsbCk7dC5sZW5ndGg9MCx0Lm1vZGU9ODtjYXNlIDg6aWYoNDA5NiZ0LmZsYWdzKXtpZigwPT09bilicmVhayBBO0U9MDtkb3tEPWlbSStFKytdLHQuaGVhZCYmRCYmdC5sZW5ndGg8NjU1MzYmJih0LmhlYWQuY29tbWVudCs9U3RyaW5nLmZyb21DaGFyQ29kZShEKSl9d2hpbGUoRCYmRTxuKTtpZig1MTImdC5mbGFncyYmKHQuY2hlY2s9WSh0LmNoZWNrLGksRSxJKSksbi09RSxJKz1FLEQpYnJlYWsgQX1lbHNlIHQuaGVhZCYmKHQuaGVhZC5jb21tZW50PW51bGwpO3QubW9kZT05O2Nhc2UgOTppZig1MTImdC5mbGFncyl7Zm9yKDtCPDE2Oyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9aWYobyE9PSg2NTUzNSZ0LmNoZWNrKSl7QS5tc2c9XFxcImhlYWRlciBjcmMgbWlzbWF0Y2hcXFwiLHQubW9kZT0zMDticmVha31vPTAsQj0wfXQuaGVhZCYmKHQuaGVhZC5oY3JjPXQuZmxhZ3M+PjkmMSx0LmhlYWQuZG9uZT0hMCksQS5hZGxlcj10LmNoZWNrPTAsdC5tb2RlPTEyO2JyZWFrO2Nhc2UgMTA6Zm9yKDtCPDMyOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9QS5hZGxlcj10LmNoZWNrPWNBKG8pLG89MCxCPTAsdC5tb2RlPTExO2Nhc2UgMTE6aWYoMD09PXQuaGF2ZWRpY3QpcmV0dXJuIEEubmV4dF9vdXQ9ZyxBLmF2YWlsX291dD1hLEEubmV4dF9pbj1JLEEuYXZhaWxfaW49bix0LmhvbGQ9byx0LmJpdHM9QixCQTtBLmFkbGVyPXQuY2hlY2s9MSx0Lm1vZGU9MTI7Y2FzZSAxMjppZihlPT09Z0F8fGU9PT1uQSlicmVhayBBO2Nhc2UgMTM6aWYodC5sYXN0KXtvPj4+PTcmQixCLT03JkIsdC5tb2RlPTI3O2JyZWFrfWZvcig7QjwzOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9c3dpdGNoKHQubGFzdD0xJm8sQi09MSwzJihvPj4+PTEpKXtjYXNlIDA6dC5tb2RlPTE0O2JyZWFrO2Nhc2UgMTppZihwQSh0KSx0Lm1vZGU9MjAsZT09PW5BKXtvPj4+PTIsQi09MjticmVhayBBfWJyZWFrO2Nhc2UgMjp0Lm1vZGU9MTc7YnJlYWs7Y2FzZSAzOkEubXNnPVxcXCJpbnZhbGlkIGJsb2NrIHR5cGVcXFwiLHQubW9kZT0zMH1vPj4+PTIsQi09MjticmVhaztjYXNlIDE0OmZvcihvPj4+PTcmQixCLT03JkI7QjwzMjspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKCg2NTUzNSZvKSE9KG8+Pj4xNl42NTUzNSkpe0EubXNnPVxcXCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXFxcIix0Lm1vZGU9MzA7YnJlYWt9aWYodC5sZW5ndGg9NjU1MzUmbyxvPTAsQj0wLHQubW9kZT0xNSxlPT09bkEpYnJlYWsgQTtjYXNlIDE1OnQubW9kZT0xNjtjYXNlIDE2OmlmKEU9dC5sZW5ndGgpe2lmKEU+biYmKEU9biksRT5hJiYoRT1hKSwwPT09RSlicmVhayBBO3Iuc2V0KGkuc3ViYXJyYXkoSSxJK0UpLGcpLG4tPUUsSSs9RSxhLT1FLGcrPUUsdC5sZW5ndGgtPUU7YnJlYWt9dC5tb2RlPTEyO2JyZWFrO2Nhc2UgMTc6Zm9yKDtCPDE0Oyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9aWYodC5ubGVuPTI1NysoMzEmbyksbz4+Pj01LEItPTUsdC5uZGlzdD0xKygzMSZvKSxvPj4+PTUsQi09NSx0Lm5jb2RlPTQrKDE1Jm8pLG8+Pj49NCxCLT00LHQubmxlbj4yODZ8fHQubmRpc3Q+MzApe0EubXNnPVxcXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1xcXCIsdC5tb2RlPTMwO2JyZWFrfXQuaGF2ZT0wLHQubW9kZT0xODtjYXNlIDE4OmZvcig7dC5oYXZlPHQubmNvZGU7KXtmb3IoO0I8Mzspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fXQubGVuc1tGW3QuaGF2ZSsrXV09NyZvLG8+Pj49MyxCLT0zfWZvcig7dC5oYXZlPDE5Oyl0LmxlbnNbRlt0LmhhdmUrK11dPTA7aWYodC5sZW5jb2RlPXQubGVuZHluLHQubGVuYml0cz03LGs9e2JpdHM6dC5sZW5iaXRzfSx5PXJBKDAsdC5sZW5zLDAsMTksdC5sZW5jb2RlLDAsdC53b3JrLGspLHQubGVuYml0cz1rLmJpdHMseSl7QS5tc2c9XFxcImludmFsaWQgY29kZSBsZW5ndGhzIHNldFxcXCIsdC5tb2RlPTMwO2JyZWFrfXQuaGF2ZT0wLHQubW9kZT0xOTtjYXNlIDE5OmZvcig7dC5oYXZlPHQubmxlbit0Lm5kaXN0Oyl7Zm9yKDtoPShtPXQubGVuY29kZVtvJigxPDx0LmxlbmJpdHMpLTFdKT4+PjE2JjI1NSxsPTY1NTM1Jm0sISgoYz1tPj4+MjQpPD1CKTspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKGw8MTYpbz4+Pj1jLEItPWMsdC5sZW5zW3QuaGF2ZSsrXT1sO2Vsc2V7aWYoMTY9PT1sKXtmb3IocD1jKzI7QjxwOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9aWYobz4+Pj1jLEItPWMsMD09PXQuaGF2ZSl7QS5tc2c9XFxcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcXFwiLHQubW9kZT0zMDticmVha31EPXQubGVuc1t0LmhhdmUtMV0sRT0zKygzJm8pLG8+Pj49MixCLT0yfWVsc2UgaWYoMTc9PT1sKXtmb3IocD1jKzM7QjxwOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9Qi09YyxEPTAsRT0zKyg3JihvPj4+PWMpKSxvPj4+PTMsQi09M31lbHNle2ZvcihwPWMrNztCPHA7KXtpZigwPT09bilicmVhayBBO24tLSxvKz1pW0krK108PEIsQis9OH1CLT1jLEQ9MCxFPTExKygxMjcmKG8+Pj49YykpLG8+Pj49NyxCLT03fWlmKHQuaGF2ZStFPnQubmxlbit0Lm5kaXN0KXtBLm1zZz1cXFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFxcXCIsdC5tb2RlPTMwO2JyZWFrfWZvcig7RS0tOyl0LmxlbnNbdC5oYXZlKytdPUR9fWlmKDMwPT09dC5tb2RlKWJyZWFrO2lmKDA9PT10LmxlbnNbMjU2XSl7QS5tc2c9XFxcImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9ja1xcXCIsdC5tb2RlPTMwO2JyZWFrfWlmKHQubGVuYml0cz05LGs9e2JpdHM6dC5sZW5iaXRzfSx5PXJBKDEsdC5sZW5zLDAsdC5ubGVuLHQubGVuY29kZSwwLHQud29yayxrKSx0LmxlbmJpdHM9ay5iaXRzLHkpe0EubXNnPVxcXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXRcXFwiLHQubW9kZT0zMDticmVha31pZih0LmRpc3RiaXRzPTYsdC5kaXN0Y29kZT10LmRpc3RkeW4saz17Yml0czp0LmRpc3RiaXRzfSx5PXJBKDIsdC5sZW5zLHQubmxlbix0Lm5kaXN0LHQuZGlzdGNvZGUsMCx0LndvcmssayksdC5kaXN0Yml0cz1rLmJpdHMseSl7QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2VzIHNldFxcXCIsdC5tb2RlPTMwO2JyZWFrfWlmKHQubW9kZT0yMCxlPT09bkEpYnJlYWsgQTtjYXNlIDIwOnQubW9kZT0yMTtjYXNlIDIxOmlmKG4+PTYmJmE+PTI1OCl7QS5uZXh0X291dD1nLEEuYXZhaWxfb3V0PWEsQS5uZXh0X2luPUksQS5hdmFpbF9pbj1uLHQuaG9sZD1vLHQuYml0cz1CLCQoQSxRKSxnPUEubmV4dF9vdXQscj1BLm91dHB1dCxhPUEuYXZhaWxfb3V0LEk9QS5uZXh0X2luLGk9QS5pbnB1dCxuPUEuYXZhaWxfaW4sbz10LmhvbGQsQj10LmJpdHMsMTI9PT10Lm1vZGUmJih0LmJhY2s9LTEpO2JyZWFrfWZvcih0LmJhY2s9MDtoPShtPXQubGVuY29kZVtvJigxPDx0LmxlbmJpdHMpLTFdKT4+PjE2JjI1NSxsPTY1NTM1Jm0sISgoYz1tPj4+MjQpPD1CKTspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKGgmJjA9PSgyNDAmaCkpe2Zvcih1PWMsdz1oLGQ9bDtoPShtPXQubGVuY29kZVtkKygobyYoMTw8dSt3KS0xKT4+dSldKT4+PjE2JjI1NSxsPTY1NTM1Jm0sISh1KyhjPW0+Pj4yNCk8PUIpOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9bz4+Pj11LEItPXUsdC5iYWNrKz11fWlmKG8+Pj49YyxCLT1jLHQuYmFjays9Yyx0Lmxlbmd0aD1sLDA9PT1oKXt0Lm1vZGU9MjY7YnJlYWt9aWYoMzImaCl7dC5iYWNrPS0xLHQubW9kZT0xMjticmVha31pZig2NCZoKXtBLm1zZz1cXFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXFxcIix0Lm1vZGU9MzA7YnJlYWt9dC5leHRyYT0xNSZoLHQubW9kZT0yMjtjYXNlIDIyOmlmKHQuZXh0cmEpe2ZvcihwPXQuZXh0cmE7QjxwOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9dC5sZW5ndGgrPW8mKDE8PHQuZXh0cmEpLTEsbz4+Pj10LmV4dHJhLEItPXQuZXh0cmEsdC5iYWNrKz10LmV4dHJhfXQud2FzPXQubGVuZ3RoLHQubW9kZT0yMztjYXNlIDIzOmZvcig7aD0obT10LmRpc3Rjb2RlW28mKDE8PHQuZGlzdGJpdHMpLTFdKT4+PjE2JjI1NSxsPTY1NTM1Jm0sISgoYz1tPj4+MjQpPD1CKTspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fWlmKDA9PSgyNDAmaCkpe2Zvcih1PWMsdz1oLGQ9bDtoPShtPXQuZGlzdGNvZGVbZCsoKG8mKDE8PHUrdyktMSk+PnUpXSk+Pj4xNiYyNTUsbD02NTUzNSZtLCEodSsoYz1tPj4+MjQpPD1CKTspe2lmKDA9PT1uKWJyZWFrIEE7bi0tLG8rPWlbSSsrXTw8QixCKz04fW8+Pj49dSxCLT11LHQuYmFjays9dX1pZihvPj4+PWMsQi09Yyx0LmJhY2srPWMsNjQmaCl7QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2UgY29kZVxcXCIsdC5tb2RlPTMwO2JyZWFrfXQub2Zmc2V0PWwsdC5leHRyYT0xNSZoLHQubW9kZT0yNDtjYXNlIDI0OmlmKHQuZXh0cmEpe2ZvcihwPXQuZXh0cmE7QjxwOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9dC5vZmZzZXQrPW8mKDE8PHQuZXh0cmEpLTEsbz4+Pj10LmV4dHJhLEItPXQuZXh0cmEsdC5iYWNrKz10LmV4dHJhfWlmKHQub2Zmc2V0PnQuZG1heCl7QS5tc2c9XFxcImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXFxcIix0Lm1vZGU9MzA7YnJlYWt9dC5tb2RlPTI1O2Nhc2UgMjU6aWYoMD09PWEpYnJlYWsgQTtpZihFPVEtYSx0Lm9mZnNldD5FKXtpZigoRT10Lm9mZnNldC1FKT50LndoYXZlJiZ0LnNhbmUpe0EubXNnPVxcXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1xcXCIsdC5tb2RlPTMwO2JyZWFrfUU+dC53bmV4dD8oRS09dC53bmV4dCxzPXQud3NpemUtRSk6cz10LnduZXh0LUUsRT50Lmxlbmd0aCYmKEU9dC5sZW5ndGgpLGY9dC53aW5kb3d9ZWxzZSBmPXIscz1nLXQub2Zmc2V0LEU9dC5sZW5ndGg7RT5hJiYoRT1hKSxhLT1FLHQubGVuZ3RoLT1FO2Rve3JbZysrXT1mW3MrK119d2hpbGUoLS1FKTswPT09dC5sZW5ndGgmJih0Lm1vZGU9MjEpO2JyZWFrO2Nhc2UgMjY6aWYoMD09PWEpYnJlYWsgQTtyW2crK109dC5sZW5ndGgsYS0tLHQubW9kZT0yMTticmVhaztjYXNlIDI3OmlmKHQud3JhcCl7Zm9yKDtCPDMyOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sb3w9aVtJKytdPDxCLEIrPTh9aWYoUS09YSxBLnRvdGFsX291dCs9USx0LnRvdGFsKz1RLFEmJihBLmFkbGVyPXQuY2hlY2s9dC5mbGFncz9ZKHQuY2hlY2sscixRLGctUSk6Sih0LmNoZWNrLHIsUSxnLVEpKSxRPWEsKHQuZmxhZ3M/bzpjQShvKSkhPT10LmNoZWNrKXtBLm1zZz1cXFwiaW5jb3JyZWN0IGRhdGEgY2hlY2tcXFwiLHQubW9kZT0zMDticmVha31vPTAsQj0wfXQubW9kZT0yODtjYXNlIDI4OmlmKHQud3JhcCYmdC5mbGFncyl7Zm9yKDtCPDMyOyl7aWYoMD09PW4pYnJlYWsgQTtuLS0sbys9aVtJKytdPDxCLEIrPTh9aWYobyE9PSg0Mjk0OTY3Mjk1JnQudG90YWwpKXtBLm1zZz1cXFwiaW5jb3JyZWN0IGxlbmd0aCBjaGVja1xcXCIsdC5tb2RlPTMwO2JyZWFrfW89MCxCPTB9dC5tb2RlPTI5O2Nhc2UgMjk6eT1vQTticmVhayBBO2Nhc2UgMzA6eT1RQTticmVhayBBO2Nhc2UgMzE6cmV0dXJuIEVBO2RlZmF1bHQ6cmV0dXJuIENBfXJldHVybiBBLm5leHRfb3V0PWcsQS5hdmFpbF9vdXQ9YSxBLm5leHRfaW49SSxBLmF2YWlsX2luPW4sdC5ob2xkPW8sdC5iaXRzPUIsKHQud3NpemV8fFEhPT1BLmF2YWlsX291dCYmdC5tb2RlPDMwJiYodC5tb2RlPDI3fHxlIT09SUEpKSYmbUEoQSxBLm91dHB1dCxBLm5leHRfb3V0LFEtQS5hdmFpbF9vdXQpLEMtPUEuYXZhaWxfaW4sUS09QS5hdmFpbF9vdXQsQS50b3RhbF9pbis9QyxBLnRvdGFsX291dCs9USx0LnRvdGFsKz1RLHQud3JhcCYmUSYmKEEuYWRsZXI9dC5jaGVjaz10LmZsYWdzP1kodC5jaGVjayxyLFEsQS5uZXh0X291dC1RKTpKKHQuY2hlY2sscixRLEEubmV4dF9vdXQtUSkpLEEuZGF0YV90eXBlPXQuYml0cysodC5sYXN0PzY0OjApKygxMj09PXQubW9kZT8xMjg6MCkrKDIwPT09dC5tb2RlfHwxNT09PXQubW9kZT8yNTY6MCksKDA9PT1DJiYwPT09UXx8ZT09PUlBKSYmeT09PWFBJiYoeT1zQSkseX0saW5mbGF0ZUVuZDpmdW5jdGlvbihBKXtpZighQXx8IUEuc3RhdGUpcmV0dXJuIENBO3ZhciBlPUEuc3RhdGU7cmV0dXJuIGUud2luZG93JiYoZS53aW5kb3c9bnVsbCksQS5zdGF0ZT1udWxsLGFBfSxpbmZsYXRlR2V0SGVhZGVyOmZ1bmN0aW9uKEEsZSl7aWYoIUF8fCFBLnN0YXRlKXJldHVybiBDQTt2YXIgdD1BLnN0YXRlO3JldHVybiAwPT0oMiZ0LndyYXApP0NBOih0LmhlYWQ9ZSxlLmRvbmU9ITEsYUEpfSxpbmZsYXRlU2V0RGljdGlvbmFyeTpmdW5jdGlvbihBLGUpe3ZhciB0LGk9ZS5sZW5ndGg7cmV0dXJuIEEmJkEuc3RhdGU/MCE9PSh0PUEuc3RhdGUpLndyYXAmJjExIT09dC5tb2RlP0NBOjExPT09dC5tb2RlJiZKKDEsZSxpLDApIT09dC5jaGVjaz9RQTptQShBLGUsaSxpKT8odC5tb2RlPTMxLEVBKToodC5oYXZlZGljdD0xLGFBKTpDQX0saW5mbGF0ZUluZm86XFxcInBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdClcXFwifTt2YXIgRkE9ZnVuY3Rpb24oKXt0aGlzLnRleHQ9MCx0aGlzLnRpbWU9MCx0aGlzLnhmbGFncz0wLHRoaXMub3M9MCx0aGlzLmV4dHJhPW51bGwsdGhpcy5leHRyYV9sZW49MCx0aGlzLm5hbWU9XFxcIlxcXCIsdGhpcy5jb21tZW50PVxcXCJcXFwiLHRoaXMuaGNyYz0wLHRoaXMuZG9uZT0hMX0sU0E9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyx2QT1ILlpfTk9fRkxVU0gsUkE9SC5aX0ZJTklTSCxVQT1ILlpfT0ssTEE9SC5aX1NUUkVBTV9FTkQsYkE9SC5aX05FRURfRElDVCxNQT1ILlpfU1RSRUFNX0VSUk9SLE5BPUguWl9EQVRBX0VSUk9SLHhBPUguWl9NRU1fRVJST1I7ZnVuY3Rpb24gSkEoQSl7dGhpcy5vcHRpb25zPVAoe2NodW5rU2l6ZTo2NTUzNix3aW5kb3dCaXRzOjE1LHRvOlxcXCJcXFwifSxBfHx7fSk7dmFyIGU9dGhpcy5vcHRpb25zO2UucmF3JiZlLndpbmRvd0JpdHM+PTAmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cz0tZS53aW5kb3dCaXRzLDA9PT1lLndpbmRvd0JpdHMmJihlLndpbmRvd0JpdHM9LTE1KSksIShlLndpbmRvd0JpdHM+PTAmJmUud2luZG93Qml0czwxNil8fEEmJkEud2luZG93Qml0c3x8KGUud2luZG93Qml0cys9MzIpLGUud2luZG93Qml0cz4xNSYmZS53aW5kb3dCaXRzPDQ4JiYwPT0oMTUmZS53aW5kb3dCaXRzKSYmKGUud2luZG93Qml0c3w9MTUpLHRoaXMuZXJyPTAsdGhpcy5tc2c9XFxcIlxcXCIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IHosdGhpcy5zdHJtLmF2YWlsX291dD0wO3ZhciB0PUdBLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sZS53aW5kb3dCaXRzKTtpZih0IT09VUEpdGhyb3cgbmV3IEVycm9yKEtbdF0pO2lmKHRoaXMuaGVhZGVyPW5ldyBGQSxHQS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSx0aGlzLmhlYWRlciksZS5kaWN0aW9uYXJ5JiYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlLmRpY3Rpb25hcnk/ZS5kaWN0aW9uYXJ5PVooZS5kaWN0aW9uYXJ5KTpcXFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cXFwiPT09U0EuY2FsbChlLmRpY3Rpb25hcnkpJiYoZS5kaWN0aW9uYXJ5PW5ldyBVaW50OEFycmF5KGUuZGljdGlvbmFyeSkpLGUucmF3JiYodD1HQS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sZS5kaWN0aW9uYXJ5KSkhPT1VQSkpdGhyb3cgbmV3IEVycm9yKEtbdF0pfWZ1bmN0aW9uIHFBKEEsZSl7dmFyIHQ9bmV3IEpBKGUpO2lmKHQucHVzaChBKSx0LmVycil0aHJvdyB0Lm1zZ3x8S1t0LmVycl07cmV0dXJuIHQucmVzdWx0fUpBLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKEEsZSl7dmFyIHQsaSxyLEk9dGhpcy5zdHJtLGc9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxuPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7Zm9yKGk9ZT09PX5+ZT9lOiEwPT09ZT9SQTp2QSxcXFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cXFwiPT09U0EuY2FsbChBKT9JLmlucHV0PW5ldyBVaW50OEFycmF5KEEpOkkuaW5wdXQ9QSxJLm5leHRfaW49MCxJLmF2YWlsX2luPUkuaW5wdXQubGVuZ3RoOzspe2ZvcigwPT09SS5hdmFpbF9vdXQmJihJLm91dHB1dD1uZXcgVWludDhBcnJheShnKSxJLm5leHRfb3V0PTAsSS5hdmFpbF9vdXQ9ZyksKHQ9R0EuaW5mbGF0ZShJLGkpKT09PWJBJiZuJiYoKHQ9R0EuaW5mbGF0ZVNldERpY3Rpb25hcnkoSSxuKSk9PT1VQT90PUdBLmluZmxhdGUoSSxpKTp0PT09TkEmJih0PWJBKSk7SS5hdmFpbF9pbj4wJiZ0PT09TEEmJkkuc3RhdGUud3JhcD4wJiYwIT09QVtJLm5leHRfaW5dOylHQS5pbmZsYXRlUmVzZXQoSSksdD1HQS5pbmZsYXRlKEksaSk7c3dpdGNoKHQpe2Nhc2UgTUE6Y2FzZSBOQTpjYXNlIGJBOmNhc2UgeEE6cmV0dXJuIHRoaXMub25FbmQodCksdGhpcy5lbmRlZD0hMCwhMX1pZihyPUkuYXZhaWxfb3V0LEkubmV4dF9vdXQmJigwPT09SS5hdmFpbF9vdXR8fHQ9PT1MQSkpaWYoXFxcInN0cmluZ1xcXCI9PT10aGlzLm9wdGlvbnMudG8pe3ZhciBhPVcoSS5vdXRwdXQsSS5uZXh0X291dCksbz1JLm5leHRfb3V0LWEsQj1qKEkub3V0cHV0LGEpO0kubmV4dF9vdXQ9byxJLmF2YWlsX291dD1nLW8sbyYmSS5vdXRwdXQuc2V0KEkub3V0cHV0LnN1YmFycmF5KGEsYStvKSwwKSx0aGlzLm9uRGF0YShCKX1lbHNlIHRoaXMub25EYXRhKEkub3V0cHV0Lmxlbmd0aD09PUkubmV4dF9vdXQ/SS5vdXRwdXQ6SS5vdXRwdXQuc3ViYXJyYXkoMCxJLm5leHRfb3V0KSk7aWYodCE9PVVBfHwwIT09cil7aWYodD09PUxBKXJldHVybiB0PUdBLmluZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKHQpLHRoaXMuZW5kZWQ9ITAsITA7aWYoMD09PUkuYXZhaWxfaW4pYnJlYWt9fXJldHVybiEwfSxKQS5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKEEpe3RoaXMuY2h1bmtzLnB1c2goQSl9LEpBLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbihBKXtBPT09VUEmJihcXFwic3RyaW5nXFxcIj09PXRoaXMub3B0aW9ucy50bz90aGlzLnJlc3VsdD10aGlzLmNodW5rcy5qb2luKFxcXCJcXFwiKTp0aGlzLnJlc3VsdD1UKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9QSx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfTt2YXIgWUE9e0luZmxhdGU6SkEsaW5mbGF0ZTpxQSxpbmZsYXRlUmF3OmZ1bmN0aW9uKEEsZSl7cmV0dXJuKGU9ZXx8e30pLnJhdz0hMCxxQShBLGUpfSx1bmd6aXA6cUEsY29uc3RhbnRzOkh9LmluZmxhdGU7ZnVuY3Rpb24gS0EoQSl7dmFyIGU9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goQSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciB0LGk9YyhBKTtpZihlKXt2YXIgcj1jKHRoaXMpLmNvbnN0cnVjdG9yO3Q9UmVmbGVjdC5jb25zdHJ1Y3QoaSxhcmd1bWVudHMscil9ZWxzZSB0PWkuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmKHRoaXMsdCl9fXZhciBIQT1mdW5jdGlvbihBKXtzKHQsdyk7dmFyIGU9S0EodCk7ZnVuY3Rpb24gdCgpe3JldHVybiBCKHRoaXMsdCksZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3JldHVybiBZQShuZXcgVWludDhBcnJheShBKSkuYnVmZmVyfX1dKSx0fSgpLE9BPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6SEF9KTtmdW5jdGlvbiBQQShBKXt2YXIgZT1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChBKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsaT1jKEEpO2lmKGUpe3ZhciByPWModGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChpLGFyZ3VtZW50cyxyKX1lbHNlIHQ9aS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGYodGhpcyx0KX19dmFyIFRBLFZBPWZ1bmN0aW9uKEEpe3ModCx3KTt2YXIgZT1QQSh0KTtmdW5jdGlvbiB0KCl7cmV0dXJuIEIodGhpcyx0KSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gUSh0LFt7a2V5OlxcXCJkZWNvZGVCbG9ja1xcXCIsdmFsdWU6ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPW5ldyBEYXRhVmlldyhBKSx0PVtdLGk9MDtpPEEuYnl0ZUxlbmd0aDsrK2kpe3ZhciByPWUuZ2V0SW50OChpKTtpZihyPDApe3ZhciBJPWUuZ2V0VWludDgoaSsxKTtyPS1yO2Zvcih2YXIgZz0wO2c8PXI7KytnKXQucHVzaChJKTtpKz0xfWVsc2V7Zm9yKHZhciBuPTA7bjw9cjsrK24pdC5wdXNoKGUuZ2V0VWludDgoaStuKzEpKTtpKz1yKzF9fXJldHVybiBuZXcgVWludDhBcnJheSh0KS5idWZmZXJ9fV0pLHR9KCksX0E9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDpWQX0pLFhBPXtleHBvcnRzOnt9fTtUQT1YQSxcXG4vKiBDb3B5cmlnaHQgMjAxNS0yMDIxIEVzcmkuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgQHByZXNlcnZlICovXFxuZnVuY3Rpb24oKXt2YXIgQSxlLHQsaSxyLEksZyxuLGEsbyxCLEMsUSxFLHMsZixjPShBPXtkZWZhdWx0Tm9EYXRhVmFsdWU6LTM0MDI3OTk5Mzg3OTAxNDg0ZTIyLGRlY29kZTpmdW5jdGlvbihJLGcpe3ZhciBuPShnPWd8fHt9KS5lbmNvZGVkTWFza0RhdGF8fG51bGw9PT1nLmVuY29kZWRNYXNrRGF0YSxhPXIoSSxnLmlucHV0T2Zmc2V0fHwwLG4pLG89bnVsbCE9PWcubm9EYXRhVmFsdWU/Zy5ub0RhdGFWYWx1ZTpBLmRlZmF1bHROb0RhdGFWYWx1ZSxCPWUoYSxnLnBpeGVsVHlwZXx8RmxvYXQzMkFycmF5LGcuZW5jb2RlZE1hc2tEYXRhLG8sZy5yZXR1cm5NYXNrKSxDPXt3aWR0aDphLndpZHRoLGhlaWdodDphLmhlaWdodCxwaXhlbERhdGE6Qi5yZXN1bHRQaXhlbHMsbWluVmFsdWU6Qi5taW5WYWx1ZSxtYXhWYWx1ZTphLnBpeGVscy5tYXhWYWx1ZSxub0RhdGFWYWx1ZTpvfTtyZXR1cm4gQi5yZXN1bHRNYXNrJiYoQy5tYXNrRGF0YT1CLnJlc3VsdE1hc2spLGcucmV0dXJuRW5jb2RlZE1hc2smJmEubWFzayYmKEMuZW5jb2RlZE1hc2tEYXRhPWEubWFzay5iaXRzZXQ/YS5tYXNrLmJpdHNldDpudWxsKSxnLnJldHVybkZpbGVJbmZvJiYoQy5maWxlSW5mbz10KGEpLGcuY29tcHV0ZVVzZWRCaXREZXB0aHMmJihDLmZpbGVJbmZvLmJpdERlcHRocz1pKGEpKSksQ319LGU9ZnVuY3Rpb24oQSxlLHQsaSxyKXt2YXIgZyxuLGEsbz0wLEI9QS5waXhlbHMubnVtQmxvY2tzWCxDPUEucGl4ZWxzLm51bUJsb2Nrc1ksUT1NYXRoLmZsb29yKEEud2lkdGgvQiksRT1NYXRoLmZsb29yKEEuaGVpZ2h0L0MpLHM9MipBLm1heFpFcnJvcixmPU51bWJlci5NQVhfVkFMVUU7dD10fHwoQS5tYXNrP0EubWFzay5iaXRzZXQ6bnVsbCksbj1uZXcgZShBLndpZHRoKkEuaGVpZ2h0KSxyJiZ0JiYoYT1uZXcgVWludDhBcnJheShBLndpZHRoKkEuaGVpZ2h0KSk7Zm9yKHZhciBjLGgsbD1uZXcgRmxvYXQzMkFycmF5KFEqRSksdT0wO3U8PUM7dSsrKXt2YXIgdz11IT09Qz9FOkEuaGVpZ2h0JUM7aWYoMCE9PXcpZm9yKHZhciBkPTA7ZDw9QjtkKyspe3ZhciBEPWQhPT1CP1E6QS53aWR0aCVCO2lmKDAhPT1EKXt2YXIgeSxrLHAsbSxHPXUqQS53aWR0aCpFK2QqUSxGPUEud2lkdGgtRCxTPUEucGl4ZWxzLmJsb2Nrc1tvXTtpZihTLmVuY29kaW5nPDI/KDA9PT1TLmVuY29kaW5nP3k9Uy5yYXdEYXRhOihJKFMuc3R1ZmZlZERhdGEsUy5iaXRzUGVyUGl4ZWwsUy5udW1WYWxpZFBpeGVscyxTLm9mZnNldCxzLGwsQS5waXhlbHMubWF4VmFsdWUpLHk9bCksaz0wKTpwPTI9PT1TLmVuY29kaW5nPzA6Uy5vZmZzZXQsdClmb3IoaD0wO2g8dztoKyspe2Zvcig3JkcmJihtPXRbRz4+M10sbTw8PTcmRyksYz0wO2M8RDtjKyspNyZHfHwobT10W0c+PjNdKSwxMjgmbT8oYSYmKGFbR109MSksZj1mPihnPVMuZW5jb2Rpbmc8Mj95W2srK106cCk/ZzpmLG5bRysrXT1nKTooYSYmKGFbR109MCksbltHKytdPWkpLG08PD0xO0crPUZ9ZWxzZSBpZihTLmVuY29kaW5nPDIpZm9yKGg9MDtoPHc7aCsrKXtmb3IoYz0wO2M8RDtjKyspZj1mPihnPXlbaysrXSk/ZzpmLG5bRysrXT1nO0crPUZ9ZWxzZSBmb3IoZj1mPnA/cDpmLGg9MDtoPHc7aCsrKXtmb3IoYz0wO2M8RDtjKyspbltHKytdPXA7Rys9Rn1pZigxPT09Uy5lbmNvZGluZyYmayE9PVMubnVtVmFsaWRQaXhlbHMpdGhyb3dcXFwiQmxvY2sgYW5kIE1hc2sgZG8gbm90IG1hdGNoXFxcIjtvKyt9fX1yZXR1cm57cmVzdWx0UGl4ZWxzOm4scmVzdWx0TWFzazphLG1pblZhbHVlOmZ9fSx0PWZ1bmN0aW9uKEEpe3JldHVybntmaWxlSWRlbnRpZmllclN0cmluZzpBLmZpbGVJZGVudGlmaWVyU3RyaW5nLGZpbGVWZXJzaW9uOkEuZmlsZVZlcnNpb24saW1hZ2VUeXBlOkEuaW1hZ2VUeXBlLGhlaWdodDpBLmhlaWdodCx3aWR0aDpBLndpZHRoLG1heFpFcnJvcjpBLm1heFpFcnJvcixlb2ZPZmZzZXQ6QS5lb2ZPZmZzZXQsbWFzazpBLm1hc2s/e251bUJsb2Nrc1g6QS5tYXNrLm51bUJsb2Nrc1gsbnVtQmxvY2tzWTpBLm1hc2subnVtQmxvY2tzWSxudW1CeXRlczpBLm1hc2subnVtQnl0ZXMsbWF4VmFsdWU6QS5tYXNrLm1heFZhbHVlfTpudWxsLHBpeGVsczp7bnVtQmxvY2tzWDpBLnBpeGVscy5udW1CbG9ja3NYLG51bUJsb2Nrc1k6QS5waXhlbHMubnVtQmxvY2tzWSxudW1CeXRlczpBLnBpeGVscy5udW1CeXRlcyxtYXhWYWx1ZTpBLnBpeGVscy5tYXhWYWx1ZSxub0RhdGFWYWx1ZTpBLm5vRGF0YVZhbHVlfX19LGk9ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPUEucGl4ZWxzLm51bUJsb2Nrc1gqQS5waXhlbHMubnVtQmxvY2tzWSx0PXt9LGk9MDtpPGU7aSsrKXt2YXIgcj1BLnBpeGVscy5ibG9ja3NbaV07MD09PXIuZW5jb2Rpbmc/dC5mbG9hdDMyPSEwOjE9PT1yLmVuY29kaW5nP3Rbci5iaXRzUGVyUGl4ZWxdPSEwOnRbMF09ITB9cmV0dXJuIE9iamVjdC5rZXlzKHQpfSxyPWZ1bmN0aW9uKEEsZSx0KXt2YXIgaT17fSxyPW5ldyBVaW50OEFycmF5KEEsZSwxMCk7aWYoaS5maWxlSWRlbnRpZmllclN0cmluZz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsciksXFxcIkNudFpJbWFnZVxcXCIhPT1pLmZpbGVJZGVudGlmaWVyU3RyaW5nLnRyaW0oKSl0aHJvd1xcXCJVbmV4cGVjdGVkIGZpbGUgaWRlbnRpZmllciBzdHJpbmc6IFxcXCIraS5maWxlSWRlbnRpZmllclN0cmluZztlKz0xMDt2YXIgST1uZXcgRGF0YVZpZXcoQSxlLDI0KTtpZihpLmZpbGVWZXJzaW9uPUkuZ2V0SW50MzIoMCwhMCksaS5pbWFnZVR5cGU9SS5nZXRJbnQzMig0LCEwKSxpLmhlaWdodD1JLmdldFVpbnQzMig4LCEwKSxpLndpZHRoPUkuZ2V0VWludDMyKDEyLCEwKSxpLm1heFpFcnJvcj1JLmdldEZsb2F0NjQoMTYsITApLGUrPTI0LCF0KWlmKEk9bmV3IERhdGFWaWV3KEEsZSwxNiksaS5tYXNrPXt9LGkubWFzay5udW1CbG9ja3NZPUkuZ2V0VWludDMyKDAsITApLGkubWFzay5udW1CbG9ja3NYPUkuZ2V0VWludDMyKDQsITApLGkubWFzay5udW1CeXRlcz1JLmdldFVpbnQzMig4LCEwKSxpLm1hc2subWF4VmFsdWU9SS5nZXRGbG9hdDMyKDEyLCEwKSxlKz0xNixpLm1hc2subnVtQnl0ZXM+MCl7dmFyIGc9bmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGkud2lkdGgqaS5oZWlnaHQvOCkpLG49KEk9bmV3IERhdGFWaWV3KEEsZSxpLm1hc2subnVtQnl0ZXMpKS5nZXRJbnQxNigwLCEwKSxhPTIsbz0wO2Rve2lmKG4+MClmb3IoO24tLTspZ1tvKytdPUkuZ2V0VWludDgoYSsrKTtlbHNle3ZhciBCPUkuZ2V0VWludDgoYSsrKTtmb3Iobj0tbjtuLS07KWdbbysrXT1CfW49SS5nZXRJbnQxNihhLCEwKSxhKz0yfXdoaWxlKGE8aS5tYXNrLm51bUJ5dGVzKTtpZigtMzI3NjghPT1ufHxvPGcubGVuZ3RoKXRocm93XFxcIlVuZXhwZWN0ZWQgZW5kIG9mIG1hc2sgUkxFIGVuY29kaW5nXFxcIjtpLm1hc2suYml0c2V0PWcsZSs9aS5tYXNrLm51bUJ5dGVzfWVsc2UgMD09KGkubWFzay5udW1CeXRlc3xpLm1hc2subnVtQmxvY2tzWXxpLm1hc2subWF4VmFsdWUpJiYoaS5tYXNrLmJpdHNldD1uZXcgVWludDhBcnJheShNYXRoLmNlaWwoaS53aWR0aCppLmhlaWdodC84KSkpO0k9bmV3IERhdGFWaWV3KEEsZSwxNiksaS5waXhlbHM9e30saS5waXhlbHMubnVtQmxvY2tzWT1JLmdldFVpbnQzMigwLCEwKSxpLnBpeGVscy5udW1CbG9ja3NYPUkuZ2V0VWludDMyKDQsITApLGkucGl4ZWxzLm51bUJ5dGVzPUkuZ2V0VWludDMyKDgsITApLGkucGl4ZWxzLm1heFZhbHVlPUkuZ2V0RmxvYXQzMigxMiwhMCksZSs9MTY7dmFyIEM9aS5waXhlbHMubnVtQmxvY2tzWCxRPWkucGl4ZWxzLm51bUJsb2Nrc1ksRT1DKyhpLndpZHRoJUM+MD8xOjApLHM9USsoaS5oZWlnaHQlUT4wPzE6MCk7aS5waXhlbHMuYmxvY2tzPW5ldyBBcnJheShFKnMpO2Zvcih2YXIgZj0wLGM9MDtjPHM7YysrKWZvcih2YXIgaD0wO2g8RTtoKyspe3ZhciBsPTAsdT1BLmJ5dGVMZW5ndGgtZTtJPW5ldyBEYXRhVmlldyhBLGUsTWF0aC5taW4oMTAsdSkpO3ZhciB3PXt9O2kucGl4ZWxzLmJsb2Nrc1tmKytdPXc7dmFyIGQ9SS5nZXRVaW50OCgwKTtpZihsKyssdy5lbmNvZGluZz02MyZkLHcuZW5jb2Rpbmc+Myl0aHJvd1xcXCJJbnZhbGlkIGJsb2NrIGVuY29kaW5nIChcXFwiK3cuZW5jb2RpbmcrXFxcIilcXFwiO2lmKDIhPT13LmVuY29kaW5nKXtpZigwIT09ZCYmMiE9PWQpe2lmKGQ+Pj02LHcub2Zmc2V0VHlwZT1kLDI9PT1kKXcub2Zmc2V0PUkuZ2V0SW50OCgxKSxsKys7ZWxzZSBpZigxPT09ZCl3Lm9mZnNldD1JLmdldEludDE2KDEsITApLGwrPTI7ZWxzZXtpZigwIT09ZCl0aHJvd1xcXCJJbnZhbGlkIGJsb2NrIG9mZnNldCB0eXBlXFxcIjt3Lm9mZnNldD1JLmdldEZsb2F0MzIoMSwhMCksbCs9NH1pZigxPT09dy5lbmNvZGluZylpZihkPUkuZ2V0VWludDgobCksbCsrLHcuYml0c1BlclBpeGVsPTYzJmQsZD4+PTYsdy5udW1WYWxpZFBpeGVsc1R5cGU9ZCwyPT09ZCl3Lm51bVZhbGlkUGl4ZWxzPUkuZ2V0VWludDgobCksbCsrO2Vsc2UgaWYoMT09PWQpdy5udW1WYWxpZFBpeGVscz1JLmdldFVpbnQxNihsLCEwKSxsKz0yO2Vsc2V7aWYoMCE9PWQpdGhyb3dcXFwiSW52YWxpZCB2YWxpZCBwaXhlbCBjb3VudCB0eXBlXFxcIjt3Lm51bVZhbGlkUGl4ZWxzPUkuZ2V0VWludDMyKGwsITApLGwrPTR9fXZhciBEO2lmKGUrPWwsMyE9PXcuZW5jb2RpbmcpaWYoMD09PXcuZW5jb2Rpbmcpe3ZhciB5PShpLnBpeGVscy5udW1CeXRlcy0xKS80O2lmKHkhPT1NYXRoLmZsb29yKHkpKXRocm93XFxcInVuY29tcHJlc3NlZCBibG9jayBoYXMgaW52YWxpZCBsZW5ndGhcXFwiO0Q9bmV3IEFycmF5QnVmZmVyKDQqeSksbmV3IFVpbnQ4QXJyYXkoRCkuc2V0KG5ldyBVaW50OEFycmF5KEEsZSw0KnkpKTt2YXIgaz1uZXcgRmxvYXQzMkFycmF5KEQpO3cucmF3RGF0YT1rLGUrPTQqeX1lbHNlIGlmKDE9PT13LmVuY29kaW5nKXt2YXIgcD1NYXRoLmNlaWwody5udW1WYWxpZFBpeGVscyp3LmJpdHNQZXJQaXhlbC84KSxtPU1hdGguY2VpbChwLzQpO0Q9bmV3IEFycmF5QnVmZmVyKDQqbSksbmV3IFVpbnQ4QXJyYXkoRCkuc2V0KG5ldyBVaW50OEFycmF5KEEsZSxwKSksdy5zdHVmZmVkRGF0YT1uZXcgVWludDMyQXJyYXkoRCksZSs9cH19ZWxzZSBlKyt9cmV0dXJuIGkuZW9mT2Zmc2V0PWUsaX0sST1mdW5jdGlvbihBLGUsdCxpLHIsSSxnKXt2YXIgbixhLG8sQj0oMTw8ZSktMSxDPTAsUT0wLEU9TWF0aC5jZWlsKChnLWkpL3IpLHM9NCpBLmxlbmd0aC1NYXRoLmNlaWwoZSp0LzgpO2ZvcihBW0EubGVuZ3RoLTFdPDw9OCpzLG49MDtuPHQ7bisrKXtpZigwPT09USYmKG89QVtDKytdLFE9MzIpLFE+PWUpYT1vPj4+US1lJkIsUS09ZTtlbHNle3ZhciBmPWUtUTthPShvJkIpPDxmJkIsYSs9KG89QVtDKytdKT4+PihRPTMyLWYpfUlbbl09YTxFP2krYSpyOmd9cmV0dXJuIEl9LEEpLGg9KGc9ZnVuY3Rpb24oQSxlLHQsaSxyLEksZyxuKXt2YXIgYSxvLEIsQyxRLEU9KDE8PHQpLTEscz0wLGY9MCxjPTQqQS5sZW5ndGgtTWF0aC5jZWlsKHQqaS84KTtpZihBW0EubGVuZ3RoLTFdPDw9OCpjLHIpZm9yKGE9MDthPGk7YSsrKTA9PT1mJiYoQj1BW3MrK10sZj0zMiksZj49dD8obz1CPj4+Zi10JkUsZi09dCk6KG89KEImRSk8PChDPXQtZikmRSxvKz0oQj1BW3MrK10pPj4+KGY9MzItQykpLGVbYV09cltvXTtlbHNlIGZvcihRPU1hdGguY2VpbCgobi1JKS9nKSxhPTA7YTxpO2ErKykwPT09ZiYmKEI9QVtzKytdLGY9MzIpLGY+PXQ/KG89Qj4+PmYtdCZFLGYtPXQpOihvPShCJkUpPDwoQz10LWYpJkUsbys9KEI9QVtzKytdKT4+PihmPTMyLUMpKSxlW2FdPW88UT9JK28qZzpufSxuPWZ1bmN0aW9uKEEsZSx0LGkscixJKXt2YXIgZyxuPSgxPDxlKS0xLGE9MCxvPTAsQj0wLEM9MCxRPTAsRT1bXSxzPTQqQS5sZW5ndGgtTWF0aC5jZWlsKGUqdC84KTtBW0EubGVuZ3RoLTFdPDw9OCpzO3ZhciBmPU1hdGguY2VpbCgoSS1pKS9yKTtmb3Iobz0wO288dDtvKyspMD09PUMmJihnPUFbYSsrXSxDPTMyKSxDPj1lPyhRPWc+Pj5DLWUmbixDLT1lKTooUT0oZyZuKTw8KEI9ZS1DKSZuLFErPShnPUFbYSsrXSk+Pj4oQz0zMi1CKSksRVtvXT1RPGY/aStRKnI6STtyZXR1cm4gRS51bnNoaWZ0KGkpLEV9LGE9ZnVuY3Rpb24oQSxlLHQsaSxyLEksZyxuKXt2YXIgYSxvLEIsQyxRPSgxPDx0KS0xLEU9MCxzPTAsZj0wO2lmKHIpZm9yKGE9MDthPGk7YSsrKTA9PT1zJiYoQj1BW0UrK10scz0zMixmPTApLHM+PXQ/KG89Qj4+PmYmUSxzLT10LGYrPXQpOihvPUI+Pj5mJlEscz0zMi0oQz10LXMpLG98PSgoQj1BW0UrK10pJigxPDxDKS0xKTw8dC1DLGY9QyksZVthXT1yW29dO2Vsc2V7dmFyIGM9TWF0aC5jZWlsKChuLUkpL2cpO2ZvcihhPTA7YTxpO2ErKykwPT09cyYmKEI9QVtFKytdLHM9MzIsZj0wKSxzPj10PyhvPUI+Pj5mJlEscy09dCxmKz10KToobz1CPj4+ZiZRLHM9MzItKEM9dC1zKSxvfD0oKEI9QVtFKytdKSYoMTw8QyktMSk8PHQtQyxmPUMpLGVbYV09bzxjP0krbypnOm59cmV0dXJuIGV9LG89ZnVuY3Rpb24oQSxlLHQsaSxyLEkpe3ZhciBnLG49KDE8PGUpLTEsYT0wLG89MCxCPTAsQz0wLFE9MCxFPTAscz1bXSxmPU1hdGguY2VpbCgoSS1pKS9yKTtmb3Iobz0wO288dDtvKyspMD09PUMmJihnPUFbYSsrXSxDPTMyLEU9MCksQz49ZT8oUT1nPj4+RSZuLEMtPWUsRSs9ZSk6KFE9Zz4+PkUmbixDPTMyLShCPWUtQyksUXw9KChnPUFbYSsrXSkmKDE8PEIpLTEpPDxlLUIsRT1CKSxzW29dPVE8Zj9pK1EqcjpJO3JldHVybiBzLnVuc2hpZnQoaSksc30sQj1mdW5jdGlvbihBLGUsdCxpKXt2YXIgcixJLGcsbixhPSgxPDx0KS0xLG89MCxCPTAsQz00KkEubGVuZ3RoLU1hdGguY2VpbCh0KmkvOCk7Zm9yKEFbQS5sZW5ndGgtMV08PD04KkMscj0wO3I8aTtyKyspMD09PUImJihnPUFbbysrXSxCPTMyKSxCPj10PyhJPWc+Pj5CLXQmYSxCLT10KTooST0oZyZhKTw8KG49dC1CKSZhLEkrPShnPUFbbysrXSk+Pj4oQj0zMi1uKSksZVtyXT1JO3JldHVybiBlfSxDPWZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByLEksZyxuLGE9KDE8PHQpLTEsbz0wLEI9MCxDPTA7Zm9yKHI9MDtyPGk7cisrKTA9PT1CJiYoZz1BW28rK10sQj0zMixDPTApLEI+PXQ/KEk9Zz4+PkMmYSxCLT10LEMrPXQpOihJPWc+Pj5DJmEsQj0zMi0obj10LUIpLEl8PSgoZz1BW28rK10pJigxPDxuKS0xKTw8dC1uLEM9biksZVtyXT1JO3JldHVybiBlfSxRPXtIVUZGTUFOX0xVVF9CSVRTX01BWDoxMixjb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyOmZ1bmN0aW9uKEEpe2Zvcih2YXIgZT02NTUzNSx0PTY1NTM1LGk9QS5sZW5ndGgscj1NYXRoLmZsb29yKGkvMiksST0wO3I7KXt2YXIgZz1yPj0zNTk/MzU5OnI7ci09Zztkb3tlKz1BW0krK108PDgsdCs9ZSs9QVtJKytdfXdoaWxlKC0tZyk7ZT0oNjU1MzUmZSkrKGU+Pj4xNiksdD0oNjU1MzUmdCkrKHQ+Pj4xNil9cmV0dXJuIDEmaSYmKHQrPWUrPUFbSV08PDgpLCgodD0oNjU1MzUmdCkrKHQ+Pj4xNikpPDwxNnwoZT0oNjU1MzUmZSkrKGU+Pj4xNikpKT4+PjB9LHJlYWRIZWFkZXJJbmZvOmZ1bmN0aW9uKEEsZSl7dmFyIHQ9ZS5wdHIsaT1uZXcgVWludDhBcnJheShBLHQsNikscj17fTtpZihyLmZpbGVJZGVudGlmaWVyU3RyaW5nPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxpKSwwIT09ci5maWxlSWRlbnRpZmllclN0cmluZy5sYXN0SW5kZXhPZihcXFwiTGVyYzJcXFwiLDApKXRocm93XFxcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZyAoZXhwZWN0IExlcmMyICk6IFxcXCIrci5maWxlSWRlbnRpZmllclN0cmluZzt0Kz02O3ZhciBJLGc9bmV3IERhdGFWaWV3KEEsdCw4KSxuPWcuZ2V0SW50MzIoMCwhMCk7aWYoci5maWxlVmVyc2lvbj1uLHQrPTQsbj49MyYmKHIuY2hlY2tzdW09Zy5nZXRVaW50MzIoNCwhMCksdCs9NCksZz1uZXcgRGF0YVZpZXcoQSx0LDEyKSxyLmhlaWdodD1nLmdldFVpbnQzMigwLCEwKSxyLndpZHRoPWcuZ2V0VWludDMyKDQsITApLHQrPTgsbj49ND8oci5udW1EaW1zPWcuZ2V0VWludDMyKDgsITApLHQrPTQpOnIubnVtRGltcz0xLGc9bmV3IERhdGFWaWV3KEEsdCw0MCksci5udW1WYWxpZFBpeGVsPWcuZ2V0VWludDMyKDAsITApLHIubWljcm9CbG9ja1NpemU9Zy5nZXRJbnQzMig0LCEwKSxyLmJsb2JTaXplPWcuZ2V0SW50MzIoOCwhMCksci5pbWFnZVR5cGU9Zy5nZXRJbnQzMigxMiwhMCksci5tYXhaRXJyb3I9Zy5nZXRGbG9hdDY0KDE2LCEwKSxyLnpNaW49Zy5nZXRGbG9hdDY0KDI0LCEwKSxyLnpNYXg9Zy5nZXRGbG9hdDY0KDMyLCEwKSx0Kz00MCxlLmhlYWRlckluZm89cixlLnB0cj10LG4+PTMmJihJPW4+PTQ/NTI6NDgsdGhpcy5jb21wdXRlQ2hlY2tzdW1GbGV0Y2hlcjMyKG5ldyBVaW50OEFycmF5KEEsdC1JLHIuYmxvYlNpemUtMTQpKSE9PXIuY2hlY2tzdW0pKXRocm93XFxcIkNoZWNrc3VtIGZhaWxlZC5cXFwiO3JldHVybiEwfSxjaGVja01pbk1heFJhbmdlczpmdW5jdGlvbihBLGUpe3ZhciB0PWUuaGVhZGVySW5mbyxpPXRoaXMuZ2V0RGF0YVR5cGVBcnJheSh0LmltYWdlVHlwZSkscj10Lm51bURpbXMqdGhpcy5nZXREYXRhVHlwZVNpemUodC5pbWFnZVR5cGUpLEk9dGhpcy5yZWFkU3ViQXJyYXkoQSxlLnB0cixpLHIpLGc9dGhpcy5yZWFkU3ViQXJyYXkoQSxlLnB0cityLGkscik7ZS5wdHIrPTIqcjt2YXIgbixhPSEwO2ZvcihuPTA7bjx0Lm51bURpbXM7bisrKWlmKElbbl0hPT1nW25dKXthPSExO2JyZWFrfXJldHVybiB0Lm1pblZhbHVlcz1JLHQubWF4VmFsdWVzPWcsYX0scmVhZFN1YkFycmF5OmZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByO2lmKHQ9PT1VaW50OEFycmF5KXI9bmV3IFVpbnQ4QXJyYXkoQSxlLGkpO2Vsc2V7dmFyIEk9bmV3IEFycmF5QnVmZmVyKGkpO25ldyBVaW50OEFycmF5KEkpLnNldChuZXcgVWludDhBcnJheShBLGUsaSkpLHI9bmV3IHQoSSl9cmV0dXJuIHJ9LHJlYWRNYXNrOmZ1bmN0aW9uKEEsZSl7dmFyIHQsaSxyPWUucHRyLEk9ZS5oZWFkZXJJbmZvLGc9SS53aWR0aCpJLmhlaWdodCxuPUkubnVtVmFsaWRQaXhlbCxhPW5ldyBEYXRhVmlldyhBLHIsNCksbz17fTtpZihvLm51bUJ5dGVzPWEuZ2V0VWludDMyKDAsITApLHIrPTQsKDA9PT1ufHxnPT09bikmJjAhPT1vLm51bUJ5dGVzKXRocm93XFxcImludmFsaWQgbWFza1xcXCI7aWYoMD09PW4pdD1uZXcgVWludDhBcnJheShNYXRoLmNlaWwoZy84KSksby5iaXRzZXQ9dCxpPW5ldyBVaW50OEFycmF5KGcpLGUucGl4ZWxzLnJlc3VsdE1hc2s9aSxyKz1vLm51bUJ5dGVzO2Vsc2UgaWYoby5udW1CeXRlcz4wKXt0PW5ldyBVaW50OEFycmF5KE1hdGguY2VpbChnLzgpKTt2YXIgQj0oYT1uZXcgRGF0YVZpZXcoQSxyLG8ubnVtQnl0ZXMpKS5nZXRJbnQxNigwLCEwKSxDPTIsUT0wLEU9MDtkb3tpZihCPjApZm9yKDtCLS07KXRbUSsrXT1hLmdldFVpbnQ4KEMrKyk7ZWxzZSBmb3IoRT1hLmdldFVpbnQ4KEMrKyksQj0tQjtCLS07KXRbUSsrXT1FO0I9YS5nZXRJbnQxNihDLCEwKSxDKz0yfXdoaWxlKEM8by5udW1CeXRlcyk7aWYoLTMyNzY4IT09Qnx8UTx0Lmxlbmd0aCl0aHJvd1xcXCJVbmV4cGVjdGVkIGVuZCBvZiBtYXNrIFJMRSBlbmNvZGluZ1xcXCI7aT1uZXcgVWludDhBcnJheShnKTt2YXIgcz0wLGY9MDtmb3IoZj0wO2Y8ZztmKyspNyZmPyhzPXRbZj4+M10sczw8PTcmZik6cz10W2Y+PjNdLDEyOCZzJiYoaVtmXT0xKTtlLnBpeGVscy5yZXN1bHRNYXNrPWksby5iaXRzZXQ9dCxyKz1vLm51bUJ5dGVzfXJldHVybiBlLnB0cj1yLGUubWFzaz1vLCEwfSxyZWFkRGF0YU9uZVN3ZWVwOmZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByLEk9ZS5wdHIsZz1lLmhlYWRlckluZm8sbj1nLm51bURpbXMsYT1nLndpZHRoKmcuaGVpZ2h0LG89Zy5pbWFnZVR5cGUsQj1nLm51bVZhbGlkUGl4ZWwqUS5nZXREYXRhVHlwZVNpemUobykqbixDPWUucGl4ZWxzLnJlc3VsdE1hc2s7aWYodD09PVVpbnQ4QXJyYXkpcj1uZXcgVWludDhBcnJheShBLEksQik7ZWxzZXt2YXIgRT1uZXcgQXJyYXlCdWZmZXIoQik7bmV3IFVpbnQ4QXJyYXkoRSkuc2V0KG5ldyBVaW50OEFycmF5KEEsSSxCKSkscj1uZXcgdChFKX1pZihyLmxlbmd0aD09PWEqbillLnBpeGVscy5yZXN1bHRQaXhlbHM9aT9RLnN3YXBEaW1lbnNpb25PcmRlcihyLGEsbix0LCEwKTpyO2Vsc2V7ZS5waXhlbHMucmVzdWx0UGl4ZWxzPW5ldyB0KGEqbik7dmFyIHM9MCxmPTAsYz0wLGg9MDtpZihuPjEpe2lmKGkpe2ZvcihmPTA7ZjxhO2YrKylpZihDW2ZdKWZvcihoPWYsYz0wO2M8bjtjKyssaCs9YSllLnBpeGVscy5yZXN1bHRQaXhlbHNbaF09cltzKytdfWVsc2UgZm9yKGY9MDtmPGE7ZisrKWlmKENbZl0pZm9yKGg9ZipuLGM9MDtjPG47YysrKWUucGl4ZWxzLnJlc3VsdFBpeGVsc1toK2NdPXJbcysrXX1lbHNlIGZvcihmPTA7ZjxhO2YrKylDW2ZdJiYoZS5waXhlbHMucmVzdWx0UGl4ZWxzW2ZdPXJbcysrXSl9cmV0dXJuIEkrPUIsZS5wdHI9SSwhMH0scmVhZEh1ZmZtYW5UcmVlOmZ1bmN0aW9uKEEsZSl7dmFyIHQ9dGhpcy5IVUZGTUFOX0xVVF9CSVRTX01BWCxpPW5ldyBEYXRhVmlldyhBLGUucHRyLDE2KTtpZihlLnB0cis9MTYsaS5nZXRJbnQzMigwLCEwKTwyKXRocm93XFxcInVuc3VwcG9ydGVkIEh1ZmZtYW4gdmVyc2lvblxcXCI7dmFyIHI9aS5nZXRJbnQzMig0LCEwKSxJPWkuZ2V0SW50MzIoOCwhMCksZz1pLmdldEludDMyKDEyLCEwKTtpZihJPj1nKXJldHVybiExO3ZhciBuPW5ldyBVaW50MzJBcnJheShnLUkpO1EuZGVjb2RlQml0cyhBLGUsbik7dmFyIGEsbyxCLEMscz1bXTtmb3IoYT1JO2E8ZzthKyspc1tvPWEtKGE8cj8wOnIpXT17Zmlyc3Q6blthLUldLHNlY29uZDpudWxsfTt2YXIgZj1BLmJ5dGVMZW5ndGgtZS5wdHIsYz1NYXRoLmNlaWwoZi80KSxoPW5ldyBBcnJheUJ1ZmZlcig0KmMpO25ldyBVaW50OEFycmF5KGgpLnNldChuZXcgVWludDhBcnJheShBLGUucHRyLGYpKTt2YXIgbCx1PW5ldyBVaW50MzJBcnJheShoKSx3PTAsZD0wO2ZvcihsPXVbMF0sYT1JO2E8ZzthKyspKEM9c1tvPWEtKGE8cj8wOnIpXS5maXJzdCk+MCYmKHNbb10uc2Vjb25kPWw8PHc+Pj4zMi1DLDMyLXc+PUM/MzI9PT0odys9QykmJih3PTAsbD11WysrZF0pOih3Kz1DLTMyLGw9dVsrK2RdLHNbb10uc2Vjb25kfD1sPj4+MzItdykpO3ZhciBEPTAseT0wLGs9bmV3IEU7Zm9yKGE9MDthPHMubGVuZ3RoO2ErKyl2b2lkIDAhPT1zW2FdJiYoRD1NYXRoLm1heChELHNbYV0uZmlyc3QpKTt5PUQ+PXQ/dDpEO3ZhciBwLG0sRyxGLFMsdj1bXTtmb3IoYT1JO2E8ZzthKyspaWYoKEM9c1tvPWEtKGE8cj8wOnIpXS5maXJzdCk+MClpZihwPVtDLG9dLEM8PXkpZm9yKG09c1tvXS5zZWNvbmQ8PHktQyxHPTE8PHktQyxCPTA7QjxHO0IrKyl2W218Ql09cDtlbHNlIGZvcihtPXNbb10uc2Vjb25kLFM9ayxGPUMtMTtGPj0wO0YtLSltPj4+RiYxPyhTLnJpZ2h0fHwoUy5yaWdodD1uZXcgRSksUz1TLnJpZ2h0KTooUy5sZWZ0fHwoUy5sZWZ0PW5ldyBFKSxTPVMubGVmdCksMCE9PUZ8fFMudmFsfHwoUy52YWw9cFsxXSk7cmV0dXJue2RlY29kZUx1dDp2LG51bUJpdHNMVVRRaWNrOnksbnVtQml0c0xVVDpELHRyZWU6ayxzdHVmZmVkRGF0YTp1LHNyY1B0cjpkLGJpdFBvczp3fX0scmVhZEh1ZmZtYW46ZnVuY3Rpb24oQSxlLHQsaSl7dmFyIHIsSSxnLG4sYSxvLEIsQyxFLHM9ZS5oZWFkZXJJbmZvLm51bURpbXMsZj1lLmhlYWRlckluZm8uaGVpZ2h0LGM9ZS5oZWFkZXJJbmZvLndpZHRoLGg9YypmLGw9dGhpcy5yZWFkSHVmZm1hblRyZWUoQSxlKSx1PWwuZGVjb2RlTHV0LHc9bC50cmVlLGQ9bC5zdHVmZmVkRGF0YSxEPWwuc3JjUHRyLHk9bC5iaXRQb3Msaz1sLm51bUJpdHNMVVRRaWNrLHA9bC5udW1CaXRzTFVULG09MD09PWUuaGVhZGVySW5mby5pbWFnZVR5cGU/MTI4OjAsRz1lLnBpeGVscy5yZXN1bHRNYXNrLEY9MDt5PjAmJihEKysseT0wKTt2YXIgUyx2PWRbRF0sUj0xPT09ZS5lbmNvZGVNb2RlLFU9bmV3IHQoaCpzKSxMPVU7aWYoczwyfHxSKXtmb3IoUz0wO1M8cztTKyspaWYocz4xJiYoTD1uZXcgdChVLmJ1ZmZlcixoKlMsaCksRj0wKSxlLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbD09PWMqZilmb3IoQz0wLG89MDtvPGY7bysrKWZvcihCPTA7QjxjO0IrKyxDKyspe2lmKEk9MCxhPW49djw8eT4+PjMyLWssMzIteTxrJiYoYT1ufD1kW0QrMV0+Pj42NC15LWspLHVbYV0pST11W2FdWzFdLHkrPXVbYV1bMF07ZWxzZSBmb3IoYT1uPXY8PHk+Pj4zMi1wLDMyLXk8cCYmKGE9bnw9ZFtEKzFdPj4+NjQteS1wKSxyPXcsRT0wO0U8cDtFKyspaWYoIShyPW4+Pj5wLUUtMSYxP3IucmlnaHQ6ci5sZWZ0KS5sZWZ0JiYhci5yaWdodCl7ST1yLnZhbCx5PXkrRSsxO2JyZWFrfXk+PTMyJiYoeS09MzIsdj1kWysrRF0pLGc9SS1tLFI/KGcrPUI+MD9GOm8+MD9MW0MtY106RixnJj0yNTUsTFtDXT1nLEY9Zyk6TFtDXT1nfWVsc2UgZm9yKEM9MCxvPTA7bzxmO28rKylmb3IoQj0wO0I8YztCKyssQysrKWlmKEdbQ10pe2lmKEk9MCxhPW49djw8eT4+PjMyLWssMzIteTxrJiYoYT1ufD1kW0QrMV0+Pj42NC15LWspLHVbYV0pST11W2FdWzFdLHkrPXVbYV1bMF07ZWxzZSBmb3IoYT1uPXY8PHk+Pj4zMi1wLDMyLXk8cCYmKGE9bnw9ZFtEKzFdPj4+NjQteS1wKSxyPXcsRT0wO0U8cDtFKyspaWYoIShyPW4+Pj5wLUUtMSYxP3IucmlnaHQ6ci5sZWZ0KS5sZWZ0JiYhci5yaWdodCl7ST1yLnZhbCx5PXkrRSsxO2JyZWFrfXk+PTMyJiYoeS09MzIsdj1kWysrRF0pLGc9SS1tLFI/KEI+MCYmR1tDLTFdP2crPUY6bz4wJiZHW0MtY10/Zys9TFtDLWNdOmcrPUYsZyY9MjU1LExbQ109ZyxGPWcpOkxbQ109Z319ZWxzZSBmb3IoQz0wLG89MDtvPGY7bysrKWZvcihCPTA7QjxjO0IrKylpZihDPW8qYytCLCFHfHxHW0NdKWZvcihTPTA7UzxzO1MrKyxDKz1oKXtpZihJPTAsYT1uPXY8PHk+Pj4zMi1rLDMyLXk8ayYmKGE9bnw9ZFtEKzFdPj4+NjQteS1rKSx1W2FdKUk9dVthXVsxXSx5Kz11W2FdWzBdO2Vsc2UgZm9yKGE9bj12PDx5Pj4+MzItcCwzMi15PHAmJihhPW58PWRbRCsxXT4+PjY0LXktcCkscj13LEU9MDtFPHA7RSsrKWlmKCEocj1uPj4+cC1FLTEmMT9yLnJpZ2h0OnIubGVmdCkubGVmdCYmIXIucmlnaHQpe0k9ci52YWwseT15K0UrMTticmVha315Pj0zMiYmKHktPTMyLHY9ZFsrK0RdKSxnPUktbSxMW0NdPWd9ZS5wdHI9ZS5wdHIrNCooRCsxKSsoeT4wPzQ6MCksZS5waXhlbHMucmVzdWx0UGl4ZWxzPVUscz4xJiYhaSYmKGUucGl4ZWxzLnJlc3VsdFBpeGVscz1RLnN3YXBEaW1lbnNpb25PcmRlcihVLGgscyx0KSl9LGRlY29kZUJpdHM6ZnVuY3Rpb24oQSxlLHQsaSxyKXt2YXIgST1lLmhlYWRlckluZm8sUT1JLmZpbGVWZXJzaW9uLEU9MCxzPUEuYnl0ZUxlbmd0aC1lLnB0cj49NT81OkEuYnl0ZUxlbmd0aC1lLnB0cixmPW5ldyBEYXRhVmlldyhBLGUucHRyLHMpLGM9Zi5nZXRVaW50OCgwKTtFKys7dmFyIGg9Yz4+NixsPTA9PT1oPzQ6My1oLHU9KDMyJmMpPjAsdz0zMSZjLGQ9MDtpZigxPT09bClkPWYuZ2V0VWludDgoRSksRSsrO2Vsc2UgaWYoMj09PWwpZD1mLmdldFVpbnQxNihFLCEwKSxFKz0yO2Vsc2V7aWYoNCE9PWwpdGhyb3dcXFwiSW52YWxpZCB2YWxpZCBwaXhlbCBjb3VudCB0eXBlXFxcIjtkPWYuZ2V0VWludDMyKEUsITApLEUrPTR9dmFyIEQseSxrLHAsbSxHLEYsUyx2LFI9MipJLm1heFpFcnJvcixVPUkubnVtRGltcz4xP0kubWF4VmFsdWVzW3JdOkkuek1heDtpZih1KXtmb3IoZS5jb3VudGVyLmx1dCsrLFM9Zi5nZXRVaW50OChFKSxFKysscD1NYXRoLmNlaWwoKFMtMSkqdy84KSxtPU1hdGguY2VpbChwLzQpLHk9bmV3IEFycmF5QnVmZmVyKDQqbSksaz1uZXcgVWludDhBcnJheSh5KSxlLnB0cis9RSxrLnNldChuZXcgVWludDhBcnJheShBLGUucHRyLHApKSxGPW5ldyBVaW50MzJBcnJheSh5KSxlLnB0cis9cCx2PTA7Uy0xPj4+djspdisrO3A9TWF0aC5jZWlsKGQqdi84KSxtPU1hdGguY2VpbChwLzQpLHk9bmV3IEFycmF5QnVmZmVyKDQqbSksKGs9bmV3IFVpbnQ4QXJyYXkoeSkpLnNldChuZXcgVWludDhBcnJheShBLGUucHRyLHApKSxEPW5ldyBVaW50MzJBcnJheSh5KSxlLnB0cis9cCxHPVE+PTM/byhGLHcsUy0xLGksUixVKTpuKEYsdyxTLTEsaSxSLFUpLFE+PTM/YShELHQsdixkLEcpOmcoRCx0LHYsZCxHKX1lbHNlIGUuY291bnRlci5iaXRzdHVmZmVyKyssdj13LGUucHRyKz1FLHY+MCYmKHA9TWF0aC5jZWlsKGQqdi84KSxtPU1hdGguY2VpbChwLzQpLHk9bmV3IEFycmF5QnVmZmVyKDQqbSksKGs9bmV3IFVpbnQ4QXJyYXkoeSkpLnNldChuZXcgVWludDhBcnJheShBLGUucHRyLHApKSxEPW5ldyBVaW50MzJBcnJheSh5KSxlLnB0cis9cCxRPj0zP251bGw9PWk/QyhELHQsdixkKTphKEQsdCx2LGQsITEsaSxSLFUpOm51bGw9PWk/QihELHQsdixkKTpnKEQsdCx2LGQsITEsaSxSLFUpKX0scmVhZFRpbGVzOmZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByPWUuaGVhZGVySW5mbyxJPXIud2lkdGgsZz1yLmhlaWdodCxuPUkqZyxhPXIubWljcm9CbG9ja1NpemUsbz1yLmltYWdlVHlwZSxCPVEuZ2V0RGF0YVR5cGVTaXplKG8pLEM9TWF0aC5jZWlsKEkvYSksRT1NYXRoLmNlaWwoZy9hKTtlLnBpeGVscy5udW1CbG9ja3NZPUUsZS5waXhlbHMubnVtQmxvY2tzWD1DLGUucGl4ZWxzLnB0cj0wO3ZhciBzLGYsYyxoLGwsdSx3LGQsRCx5LGs9MCxwPTAsbT0wLEc9MCxGPTAsUz0wLHY9MCxSPTAsVT0wLEw9MCxiPTAsTT0wLE49MCx4PTAsSj0wLHE9bmV3IHQoYSphKSxZPWclYXx8YSxLPUklYXx8YSxIPXIubnVtRGltcyxPPWUucGl4ZWxzLnJlc3VsdE1hc2ssUD1lLnBpeGVscy5yZXN1bHRQaXhlbHMsVD1yLmZpbGVWZXJzaW9uPj01PzE0OjE1LFY9ci56TWF4O2ZvcihtPTA7bTxFO20rKylmb3IoRj1tIT09RS0xP2E6WSxHPTA7RzxDO0crKylmb3IoTD1tKkkqYStHKmEsYj1JLShTPUchPT1DLTE/YTpLKSxkPTA7ZDxIO2QrKyl7aWYoSD4xPyh5PVAsTD1tKkkqYStHKmEsUD1uZXcgdChlLnBpeGVscy5yZXN1bHRQaXhlbHMuYnVmZmVyLG4qZCpCLG4pLFY9ci5tYXhWYWx1ZXNbZF0pOnk9bnVsbCx2PUEuYnl0ZUxlbmd0aC1lLnB0cixmPXt9LEo9MCxSPShzPW5ldyBEYXRhVmlldyhBLGUucHRyLE1hdGgubWluKDEwLHYpKSkuZ2V0VWludDgoMCksSisrLEQ9ci5maWxlVmVyc2lvbj49NT80JlI6MCxVPVI+PjYmMjU1LChSPj4yJlQpIT0oRyphPj4zJlQpKXRocm93XFxcImludGVncml0eSBpc3N1ZVxcXCI7aWYoRCYmMD09PWQpdGhyb3dcXFwiaW50ZWdyaXR5IGlzc3VlXFxcIjtpZigobD0zJlIpPjMpdGhyb3cgZS5wdHIrPUosXFxcIkludmFsaWQgYmxvY2sgZW5jb2RpbmcgKFxcXCIrbCtcXFwiKVxcXCI7aWYoMiE9PWwpaWYoMD09PWwpe2lmKEQpdGhyb3dcXFwiaW50ZWdyaXR5IGlzc3VlXFxcIjtpZihlLmNvdW50ZXIudW5jb21wcmVzc2VkKyssZS5wdHIrPUosTT0oTT1GKlMqQik8KE49QS5ieXRlTGVuZ3RoLWUucHRyKT9NOk4sYz1uZXcgQXJyYXlCdWZmZXIoTSVCPT0wP006TStCLU0lQiksbmV3IFVpbnQ4QXJyYXkoYykuc2V0KG5ldyBVaW50OEFycmF5KEEsZS5wdHIsTSkpLGg9bmV3IHQoYykseD0wLE8pZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspT1tMXSYmKFBbTF09aFt4KytdKSxMKys7TCs9Yn1lbHNlIGZvcihrPTA7azxGO2srKyl7Zm9yKHA9MDtwPFM7cCsrKVBbTCsrXT1oW3grK107TCs9Yn1lLnB0cis9eCpCfWVsc2UgaWYodT1RLmdldERhdGFUeXBlVXNlZChEJiZvPDY/NDpvLFUpLHc9US5nZXRPbmVQaXhlbChmLEosdSxzKSxKKz1RLmdldERhdGFUeXBlU2l6ZSh1KSwzPT09bClpZihlLnB0cis9SixlLmNvdW50ZXIuY29uc3RhbnRvZmZzZXQrKyxPKWZvcihrPTA7azxGO2srKyl7Zm9yKHA9MDtwPFM7cCsrKU9bTF0mJihQW0xdPUQ/TWF0aC5taW4oVix5W0xdK3cpOncpLEwrKztMKz1ifWVsc2UgZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspUFtMXT1EP01hdGgubWluKFYseVtMXSt3KTp3LEwrKztMKz1ifWVsc2UgaWYoZS5wdHIrPUosUS5kZWNvZGVCaXRzKEEsZSxxLHcsZCksSj0wLEQpaWYoTylmb3Ioaz0wO2s8RjtrKyspe2ZvcihwPTA7cDxTO3ArKylPW0xdJiYoUFtMXT1xW0orK10reVtMXSksTCsrO0wrPWJ9ZWxzZSBmb3Ioaz0wO2s8RjtrKyspe2ZvcihwPTA7cDxTO3ArKylQW0xdPXFbSisrXSt5W0xdLEwrKztMKz1ifWVsc2UgaWYoTylmb3Ioaz0wO2s8RjtrKyspe2ZvcihwPTA7cDxTO3ArKylPW0xdJiYoUFtMXT1xW0orK10pLEwrKztMKz1ifWVsc2UgZm9yKGs9MDtrPEY7aysrKXtmb3IocD0wO3A8UztwKyspUFtMKytdPXFbSisrXTtMKz1ifWVsc2V7aWYoRClpZihPKWZvcihrPTA7azxGO2srKylmb3IocD0wO3A8UztwKyspT1tMXSYmKFBbTF09eVtMXSksTCsrO2Vsc2UgZm9yKGs9MDtrPEY7aysrKWZvcihwPTA7cDxTO3ArKylQW0xdPXlbTF0sTCsrO2UuY291bnRlci5jb25zdGFudCsrLGUucHRyKz1KfX1IPjEmJiFpJiYoZS5waXhlbHMucmVzdWx0UGl4ZWxzPVEuc3dhcERpbWVuc2lvbk9yZGVyKGUucGl4ZWxzLnJlc3VsdFBpeGVscyxuLEgsdCkpfSxmb3JtYXRGaWxlSW5mbzpmdW5jdGlvbihBKXtyZXR1cm57ZmlsZUlkZW50aWZpZXJTdHJpbmc6QS5oZWFkZXJJbmZvLmZpbGVJZGVudGlmaWVyU3RyaW5nLGZpbGVWZXJzaW9uOkEuaGVhZGVySW5mby5maWxlVmVyc2lvbixpbWFnZVR5cGU6QS5oZWFkZXJJbmZvLmltYWdlVHlwZSxoZWlnaHQ6QS5oZWFkZXJJbmZvLmhlaWdodCx3aWR0aDpBLmhlYWRlckluZm8ud2lkdGgsbnVtVmFsaWRQaXhlbDpBLmhlYWRlckluZm8ubnVtVmFsaWRQaXhlbCxtaWNyb0Jsb2NrU2l6ZTpBLmhlYWRlckluZm8ubWljcm9CbG9ja1NpemUsYmxvYlNpemU6QS5oZWFkZXJJbmZvLmJsb2JTaXplLG1heFpFcnJvcjpBLmhlYWRlckluZm8ubWF4WkVycm9yLHBpeGVsVHlwZTpRLmdldFBpeGVsVHlwZShBLmhlYWRlckluZm8uaW1hZ2VUeXBlKSxlb2ZPZmZzZXQ6QS5lb2ZPZmZzZXQsbWFzazpBLm1hc2s/e251bUJ5dGVzOkEubWFzay5udW1CeXRlc306bnVsbCxwaXhlbHM6e251bUJsb2Nrc1g6QS5waXhlbHMubnVtQmxvY2tzWCxudW1CbG9ja3NZOkEucGl4ZWxzLm51bUJsb2Nrc1ksbWF4VmFsdWU6QS5oZWFkZXJJbmZvLnpNYXgsbWluVmFsdWU6QS5oZWFkZXJJbmZvLnpNaW4sbm9EYXRhVmFsdWU6QS5ub0RhdGFWYWx1ZX19fSxjb25zdHJ1Y3RDb25zdGFudFN1cmZhY2U6ZnVuY3Rpb24oQSxlKXt2YXIgdD1BLmhlYWRlckluZm8uek1heCxpPUEuaGVhZGVySW5mby56TWluLHI9QS5oZWFkZXJJbmZvLm1heFZhbHVlcyxJPUEuaGVhZGVySW5mby5udW1EaW1zLGc9QS5oZWFkZXJJbmZvLmhlaWdodCpBLmhlYWRlckluZm8ud2lkdGgsbj0wLGE9MCxvPTAsQj1BLnBpeGVscy5yZXN1bHRNYXNrLEM9QS5waXhlbHMucmVzdWx0UGl4ZWxzO2lmKEIpaWYoST4xKXtpZihlKWZvcihuPTA7bjxJO24rKylmb3Iobz1uKmcsdD1yW25dLGE9MDthPGc7YSsrKUJbYV0mJihDW28rYV09dCk7ZWxzZSBmb3IoYT0wO2E8ZzthKyspaWYoQlthXSlmb3Iobz1hKkksbj0wO248STtuKyspQ1tvK0ldPXJbbl19ZWxzZSBmb3IoYT0wO2E8ZzthKyspQlthXSYmKENbYV09dCk7ZWxzZSBpZihJPjEmJmkhPT10KWlmKGUpZm9yKG49MDtuPEk7bisrKWZvcihvPW4qZyx0PXJbbl0sYT0wO2E8ZzthKyspQ1tvK2FdPXQ7ZWxzZSBmb3IoYT0wO2E8ZzthKyspZm9yKG89YSpJLG49MDtuPEk7bisrKUNbbytuXT1yW25dO2Vsc2UgZm9yKGE9MDthPGcqSTthKyspQ1thXT10fSxnZXREYXRhVHlwZUFycmF5OmZ1bmN0aW9uKEEpe3ZhciBlO3N3aXRjaChBKXtjYXNlIDA6ZT1JbnQ4QXJyYXk7YnJlYWs7Y2FzZSAxOmU9VWludDhBcnJheTticmVhaztjYXNlIDI6ZT1JbnQxNkFycmF5O2JyZWFrO2Nhc2UgMzplPVVpbnQxNkFycmF5O2JyZWFrO2Nhc2UgNDplPUludDMyQXJyYXk7YnJlYWs7Y2FzZSA1OmU9VWludDMyQXJyYXk7YnJlYWs7Y2FzZSA2OmRlZmF1bHQ6ZT1GbG9hdDMyQXJyYXk7YnJlYWs7Y2FzZSA3OmU9RmxvYXQ2NEFycmF5fXJldHVybiBlfSxnZXRQaXhlbFR5cGU6ZnVuY3Rpb24oQSl7dmFyIGU7c3dpdGNoKEEpe2Nhc2UgMDplPVxcXCJTOFxcXCI7YnJlYWs7Y2FzZSAxOmU9XFxcIlU4XFxcIjticmVhaztjYXNlIDI6ZT1cXFwiUzE2XFxcIjticmVhaztjYXNlIDM6ZT1cXFwiVTE2XFxcIjticmVhaztjYXNlIDQ6ZT1cXFwiUzMyXFxcIjticmVhaztjYXNlIDU6ZT1cXFwiVTMyXFxcIjticmVhaztjYXNlIDY6ZGVmYXVsdDplPVxcXCJGMzJcXFwiO2JyZWFrO2Nhc2UgNzplPVxcXCJGNjRcXFwifXJldHVybiBlfSxpc1ZhbGlkUGl4ZWxWYWx1ZTpmdW5jdGlvbihBLGUpe2lmKG51bGw9PWUpcmV0dXJuITE7dmFyIHQ7c3dpdGNoKEEpe2Nhc2UgMDp0PWU+PS0xMjgmJmU8PTEyNzticmVhaztjYXNlIDE6dD1lPj0wJiZlPD0yNTU7YnJlYWs7Y2FzZSAyOnQ9ZT49LTMyNzY4JiZlPD0zMjc2NzticmVhaztjYXNlIDM6dD1lPj0wJiZlPD02NTUzNjticmVhaztjYXNlIDQ6dD1lPj0tMjE0NzQ4MzY0OCYmZTw9MjE0NzQ4MzY0NzticmVhaztjYXNlIDU6dD1lPj0wJiZlPD00Mjk0OTY3Mjk2O2JyZWFrO2Nhc2UgNjp0PWU+PS0zNDAyNzk5OTM4NzkwMTQ4NGUyMiYmZTw9MzQwMjc5OTkzODc5MDE0ODRlMjI7YnJlYWs7Y2FzZSA3OnQ9ZT49LTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiYmZTw9MTc5NzY5MzEzNDg2MjMxNTdlMjkyO2JyZWFrO2RlZmF1bHQ6dD0hMX1yZXR1cm4gdH0sZ2V0RGF0YVR5cGVTaXplOmZ1bmN0aW9uKEEpe3ZhciBlPTA7c3dpdGNoKEEpe2Nhc2UgMDpjYXNlIDE6ZT0xO2JyZWFrO2Nhc2UgMjpjYXNlIDM6ZT0yO2JyZWFrO2Nhc2UgNDpjYXNlIDU6Y2FzZSA2OmU9NDticmVhaztjYXNlIDc6ZT04O2JyZWFrO2RlZmF1bHQ6ZT1BfXJldHVybiBlfSxnZXREYXRhVHlwZVVzZWQ6ZnVuY3Rpb24oQSxlKXt2YXIgdD1BO3N3aXRjaChBKXtjYXNlIDI6Y2FzZSA0OnQ9QS1lO2JyZWFrO2Nhc2UgMzpjYXNlIDU6dD1BLTIqZTticmVhaztjYXNlIDY6dD0wPT09ZT9BOjE9PT1lPzI6MTticmVhaztjYXNlIDc6dD0wPT09ZT9BOkEtMiplKzE7YnJlYWs7ZGVmYXVsdDp0PUF9cmV0dXJuIHR9LGdldE9uZVBpeGVsOmZ1bmN0aW9uKEEsZSx0LGkpe3ZhciByPTA7c3dpdGNoKHQpe2Nhc2UgMDpyPWkuZ2V0SW50OChlKTticmVhaztjYXNlIDE6cj1pLmdldFVpbnQ4KGUpO2JyZWFrO2Nhc2UgMjpyPWkuZ2V0SW50MTYoZSwhMCk7YnJlYWs7Y2FzZSAzOnI9aS5nZXRVaW50MTYoZSwhMCk7YnJlYWs7Y2FzZSA0OnI9aS5nZXRJbnQzMihlLCEwKTticmVhaztjYXNlIDU6cj1pLmdldFVJbnQzMihlLCEwKTticmVhaztjYXNlIDY6cj1pLmdldEZsb2F0MzIoZSwhMCk7YnJlYWs7Y2FzZSA3OnI9aS5nZXRGbG9hdDY0KGUsITApO2JyZWFrO2RlZmF1bHQ6dGhyb3dcXFwidGhlIGRlY29kZXIgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGlzIHBpeGVsIHR5cGVcXFwifXJldHVybiByfSxzd2FwRGltZW5zaW9uT3JkZXI6ZnVuY3Rpb24oQSxlLHQsaSxyKXt2YXIgST0wLGc9MCxuPTAsYT0wLG89QTtpZih0PjEpaWYobz1uZXcgaShlKnQpLHIpZm9yKEk9MDtJPGU7SSsrKWZvcihhPUksbj0wO248dDtuKyssYSs9ZSlvW2FdPUFbZysrXTtlbHNlIGZvcihJPTA7STxlO0krKylmb3IoYT1JLG49MDtuPHQ7bisrLGErPWUpb1tnKytdPUFbYV07cmV0dXJuIG99fSxFPWZ1bmN0aW9uKEEsZSx0KXt0aGlzLnZhbD1BLHRoaXMubGVmdD1lLHRoaXMucmlnaHQ9dH0se2RlY29kZTpmdW5jdGlvbihBLGUpe3ZhciB0PShlPWV8fHt9KS5ub0RhdGFWYWx1ZSxpPTAscj17fTtyLnB0cj1lLmlucHV0T2Zmc2V0fHwwLHIucGl4ZWxzPXt9LFEucmVhZEhlYWRlckluZm8oQSxyKTt2YXIgST1yLmhlYWRlckluZm8sZz1JLmZpbGVWZXJzaW9uLG49US5nZXREYXRhVHlwZUFycmF5KEkuaW1hZ2VUeXBlKTtpZihnPjUpdGhyb3dcXFwidW5zdXBwb3J0ZWQgbGVyYyB2ZXJzaW9uIDIuXFxcIitnO1EucmVhZE1hc2soQSxyKSxJLm51bVZhbGlkUGl4ZWw9PT1JLndpZHRoKkkuaGVpZ2h0fHxyLnBpeGVscy5yZXN1bHRNYXNrfHwoci5waXhlbHMucmVzdWx0TWFzaz1lLm1hc2tEYXRhKTt2YXIgYT1JLndpZHRoKkkuaGVpZ2h0O3IucGl4ZWxzLnJlc3VsdFBpeGVscz1uZXcgbihhKkkubnVtRGltcyksci5jb3VudGVyPXtvbmVzd2VlcDowLHVuY29tcHJlc3NlZDowLGx1dDowLGJpdHN0dWZmZXI6MCxjb25zdGFudDowLGNvbnN0YW50b2Zmc2V0OjB9O3ZhciBvLEI9IWUucmV0dXJuUGl4ZWxJbnRlcmxlYXZlZERpbXM7aWYoMCE9PUkubnVtVmFsaWRQaXhlbClpZihJLnpNYXg9PT1JLnpNaW4pUS5jb25zdHJ1Y3RDb25zdGFudFN1cmZhY2UocixCKTtlbHNlIGlmKGc+PTQmJlEuY2hlY2tNaW5NYXhSYW5nZXMoQSxyKSlRLmNvbnN0cnVjdENvbnN0YW50U3VyZmFjZShyLEIpO2Vsc2V7dmFyIEM9bmV3IERhdGFWaWV3KEEsci5wdHIsMiksRT1DLmdldFVpbnQ4KDApO2lmKHIucHRyKyssRSlRLnJlYWREYXRhT25lU3dlZXAoQSxyLG4sQik7ZWxzZSBpZihnPjEmJkkuaW1hZ2VUeXBlPD0xJiZNYXRoLmFicyhJLm1heFpFcnJvci0uNSk8MWUtNSl7dmFyIHM9Qy5nZXRVaW50OCgxKTtpZihyLnB0cisrLHIuZW5jb2RlTW9kZT1zLHM+Mnx8Zzw0JiZzPjEpdGhyb3dcXFwiSW52YWxpZCBIdWZmbWFuIGZsYWcgXFxcIitzO3M/US5yZWFkSHVmZm1hbihBLHIsbixCKTpRLnJlYWRUaWxlcyhBLHIsbixCKX1lbHNlIFEucmVhZFRpbGVzKEEscixuLEIpfXIuZW9mT2Zmc2V0PXIucHRyLGUuaW5wdXRPZmZzZXQ/KG89ci5oZWFkZXJJbmZvLmJsb2JTaXplK2UuaW5wdXRPZmZzZXQtci5wdHIsTWF0aC5hYnMobyk+PTEmJihyLmVvZk9mZnNldD1lLmlucHV0T2Zmc2V0K3IuaGVhZGVySW5mby5ibG9iU2l6ZSkpOihvPXIuaGVhZGVySW5mby5ibG9iU2l6ZS1yLnB0cixNYXRoLmFicyhvKT49MSYmKHIuZW9mT2Zmc2V0PXIuaGVhZGVySW5mby5ibG9iU2l6ZSkpO3ZhciBmPXt3aWR0aDpJLndpZHRoLGhlaWdodDpJLmhlaWdodCxwaXhlbERhdGE6ci5waXhlbHMucmVzdWx0UGl4ZWxzLG1pblZhbHVlOkkuek1pbixtYXhWYWx1ZTpJLnpNYXgsdmFsaWRQaXhlbENvdW50OkkubnVtVmFsaWRQaXhlbCxkaW1Db3VudDpJLm51bURpbXMsZGltU3RhdHM6e21pblZhbHVlczpJLm1pblZhbHVlcyxtYXhWYWx1ZXM6SS5tYXhWYWx1ZXN9LG1hc2tEYXRhOnIucGl4ZWxzLnJlc3VsdE1hc2t9O2lmKHIucGl4ZWxzLnJlc3VsdE1hc2smJlEuaXNWYWxpZFBpeGVsVmFsdWUoSS5pbWFnZVR5cGUsdCkpe3ZhciBjPXIucGl4ZWxzLnJlc3VsdE1hc2s7Zm9yKGk9MDtpPGE7aSsrKWNbaV18fChmLnBpeGVsRGF0YVtpXT10KTtmLm5vRGF0YVZhbHVlPXR9cmV0dXJuIHIubm9EYXRhVmFsdWU9dCxlLnJldHVybkZpbGVJbmZvJiYoZi5maWxlSW5mbz1RLmZvcm1hdEZpbGVJbmZvKHIpKSxmfSxnZXRCYW5kQ291bnQ6ZnVuY3Rpb24oQSl7Zm9yKHZhciBlPTAsdD0wLGk9e3B0cjowLHBpeGVsczp7fX07dDxBLmJ5dGVMZW5ndGgtNTg7KVEucmVhZEhlYWRlckluZm8oQSxpKSx0Kz1pLmhlYWRlckluZm8uYmxvYlNpemUsZSsrLGkucHRyPXQ7cmV0dXJuIGV9fSksbD0ocz1uZXcgQXJyYXlCdWZmZXIoNCksZj1uZXcgVWludDhBcnJheShzKSxuZXcgVWludDMyQXJyYXkocylbMF09MSwxPT09ZlswXSksdT17ZGVjb2RlOmZ1bmN0aW9uKEEsZSl7aWYoIWwpdGhyb3dcXFwiQmlnIGVuZGlhbiBzeXN0ZW0gaXMgbm90IHN1cHBvcnRlZC5cXFwiO3ZhciB0LGkscj0oZT1lfHx7fSkuaW5wdXRPZmZzZXR8fDAsST1uZXcgVWludDhBcnJheShBLHIsMTApLGc9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLEkpO2lmKFxcXCJDbnRaSW1hZ2VcXFwiPT09Zy50cmltKCkpdD1jLGk9MTtlbHNle2lmKFxcXCJMZXJjMlxcXCIhPT1nLnN1YnN0cmluZygwLDUpKXRocm93XFxcIlVuZXhwZWN0ZWQgZmlsZSBpZGVudGlmaWVyIHN0cmluZzogXFxcIitnO3Q9aCxpPTJ9Zm9yKHZhciBuLGEsbyxCLEMsUSxFPTAscz1BLmJ5dGVMZW5ndGgtMTAsZj1bXSx1PXt3aWR0aDowLGhlaWdodDowLHBpeGVsczpbXSxwaXhlbFR5cGU6ZS5waXhlbFR5cGUsbWFzazpudWxsLHN0YXRpc3RpY3M6W119LHc9MDtyPHM7KXt2YXIgZD10LmRlY29kZShBLHtpbnB1dE9mZnNldDpyLGVuY29kZWRNYXNrRGF0YTpuLG1hc2tEYXRhOm8scmV0dXJuTWFzazowPT09RSxyZXR1cm5FbmNvZGVkTWFzazowPT09RSxyZXR1cm5GaWxlSW5mbzohMCxyZXR1cm5QaXhlbEludGVybGVhdmVkRGltczplLnJldHVyblBpeGVsSW50ZXJsZWF2ZWREaW1zLHBpeGVsVHlwZTplLnBpeGVsVHlwZXx8bnVsbCxub0RhdGFWYWx1ZTplLm5vRGF0YVZhbHVlfHxudWxsfSk7cj1kLmZpbGVJbmZvLmVvZk9mZnNldCxvPWQubWFza0RhdGEsMD09PUUmJihuPWQuZW5jb2RlZE1hc2tEYXRhLHUud2lkdGg9ZC53aWR0aCx1LmhlaWdodD1kLmhlaWdodCx1LmRpbUNvdW50PWQuZGltQ291bnR8fDEsdS5waXhlbFR5cGU9ZC5waXhlbFR5cGV8fGQuZmlsZUluZm8ucGl4ZWxUeXBlLHUubWFzaz1vKSxpPjEmJihvJiZmLnB1c2gobyksZC5maWxlSW5mby5tYXNrJiZkLmZpbGVJbmZvLm1hc2subnVtQnl0ZXM+MCYmdysrKSxFKyssdS5waXhlbHMucHVzaChkLnBpeGVsRGF0YSksdS5zdGF0aXN0aWNzLnB1c2goe21pblZhbHVlOmQubWluVmFsdWUsbWF4VmFsdWU6ZC5tYXhWYWx1ZSxub0RhdGFWYWx1ZTpkLm5vRGF0YVZhbHVlLGRpbVN0YXRzOmQuZGltU3RhdHN9KX1pZihpPjEmJnc+MSl7Zm9yKFE9dS53aWR0aCp1LmhlaWdodCx1LmJhbmRNYXNrcz1mLChvPW5ldyBVaW50OEFycmF5KFEpKS5zZXQoZlswXSksQj0xO0I8Zi5sZW5ndGg7QisrKWZvcihhPWZbQl0sQz0wO0M8UTtDKyspb1tDXT1vW0NdJmFbQ107dS5tYXNrRGF0YT1vfXJldHVybiB1fX07VEEuZXhwb3J0cz9UQS5leHBvcnRzPXU6dGhpcy5MZXJjPXV9KCk7dmFyIFpBLGpBLFdBLHpBPVhBLmV4cG9ydHMsJEE9e2Vudjp7ZW1zY3JpcHRlbl9ub3RpZnlfbWVtb3J5X2dyb3d0aDpmdW5jdGlvbihBKXtXQT1uZXcgVWludDhBcnJheShqQS5leHBvcnRzLm1lbW9yeS5idWZmZXIpfX19LEFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gQSgpe0IodGhpcyxBKX1yZXR1cm4gUShBLFt7a2V5OlxcXCJpbml0XFxcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBaQXx8KFpBPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZmV0Y2g/ZmV0Y2goXFxcImRhdGE6YXBwbGljYXRpb24vd2FzbTtiYXNlNjQsXFxcIitlZSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIEEuYXJyYXlCdWZmZXIoKX0pKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSwkQSl9KSkudGhlbih0aGlzLl9pbml0KTpXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShCdWZmZXIuZnJvbShlZSxcXFwiYmFzZTY0XFxcIiksJEEpLnRoZW4odGhpcy5faW5pdCkpfX0se2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe2pBPUEuaW5zdGFuY2UsJEEuZW52LmVtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgoMCl9fSx7a2V5OlxcXCJkZWNvZGVcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO2lmKCFqQSl0aHJvdyBuZXcgRXJyb3IoXFxcIlpTVEREZWNvZGVyOiBBd2FpdCAuaW5pdCgpIGJlZm9yZSBkZWNvZGluZy5cXFwiKTt2YXIgdD1BLmJ5dGVMZW5ndGgsaT1qQS5leHBvcnRzLm1hbGxvYyh0KTtXQS5zZXQoQSxpKSxlPWV8fE51bWJlcihqQS5leHBvcnRzLlpTVERfZmluZERlY29tcHJlc3NlZFNpemUoaSx0KSk7dmFyIHI9akEuZXhwb3J0cy5tYWxsb2MoZSksST1qQS5leHBvcnRzLlpTVERfZGVjb21wcmVzcyhyLGUsaSx0KSxnPVdBLnNsaWNlKHIscitJKTtyZXR1cm4gakEuZXhwb3J0cy5mcmVlKGkpLGpBLmV4cG9ydHMuZnJlZShyKSxnfX1dKSxBfSgpLGVlPVxcXCJBR0Z6YlFFQUFBQUJwUUVWWUFGL0FYOWdBbjkvQUdBRGYzOS9BWDlnQlg5L2YzOS9BWDlnQVg4QVlBSi9md0YvWUFSL2YzOS9BWDlnQTM5L2Z3QmdCbjkvZjM5L2Z3Ri9ZQWQvZjM5L2YzOS9BWDlnQW45L0FYNWdBbjUrQVg1Z0FBQmdCWDkvZjM5L0FHQUdmMzkvZjM5L0FHQUlmMzkvZjM5L2YzOEFZQWwvZjM5L2YzOS9mMzhBWUFBQmYyQUlmMzkvZjM5L2YzOEJmMkFOZjM5L2YzOS9mMzkvZjM5L2Z3Ri9ZQUYvQVg0Q0p3RURaVzUySDJWdGMyTnlhWEIwWlc1ZmJtOTBhV1o1WDIxbGJXOXllVjluY205M2RHZ0FCQU5wYUFFRkFBQUZBZ0VGQ3dBQ0FRQUJBZ0lGQlFjQUF3QUJEZ3NCQVFjQUVoTUhBQVVCREFRRUFBQU5Cd1FDQWdZQ0JBZ0RBd01EQmdFQUNRa0hCZ0lDQUFZR0FnUVVCd1lHQXdJR0FBTUNBUWdCQndVR0Nnb0VFUUFFQkFFSUF3Z0RCUWdERUE4SUFBY0FCQVVCY0FFQ0FnVUVBUUNBQWdZSkFYOEJRYUNnd0FJTEIyQUhCbTFsYlc5eWVRSUFCbTFoYkd4dll3QW9CR1p5WldVQUpneGFVMVJFWDJselJYSnliM0lBYUJsYVUxUkVYMlpwYm1SRVpXTnZiWEJ5WlhOelpXUlRhWHBsQUZRUFdsTlVSRjlrWldOdmJYQnlaWE56QUVvR1gzTjBZWEowQUNRSkJ3RUFRUUVMQVNRS3Vzc0JhQThBSUFBZ0FDZ0NCQ0FCYWpZQ0JBc1pBQ0FBS0FJQUlBQW9BZ1JCSDNGMFFRQWdBV3RCSDNGMkN3Z0FJQUJCaUg5TEMzNEJCSDlCQXlFQklBQW9BZ1FpQTBFZ1RRUkFJQUFvQWdnaUFTQUFLQUlRVHdSQUlBQVFEUThMSUFBb0Fnd2lBaUFCUmdSQVFRRkJBaUFEUVNCSkd3OExJQUFnQVNBQklBSnJJQU5CQTNZaUJDQUJJQVJySUFKSklnRWJJZ0pySWdRMkFnZ2dBQ0FESUFKQkEzUnJOZ0lFSUFBZ0JDZ0FBRFlDQUFzZ0FRc1VBUUYvSUFBZ0FSQUNJUUlnQUNBQkVBRWdBZ3YzQVFFQ2Z5QUNSUVJBSUFCQ0FEY0NBQ0FBUVFBMkFoQWdBRUlBTndJSVFiaC9Ed3NnQUNBQk5nSU1JQUFnQVVFRWFqWUNFQ0FDUVFSUEJFQWdBQ0FCSUFKcUlnRkJmR29pQXpZQ0NDQUFJQU1vQUFBMkFnQWdBVUYvYWkwQUFDSUJCRUFnQUVFSUlBRVFGR3MyQWdRZ0FnOExJQUJCQURZQ0JFRi9Ed3NnQUNBQk5nSUlJQUFnQVMwQUFDSUROZ0lBSUFKQmZtb2lCRUVCVFFSQUlBUkJBV3RGQkVBZ0FDQUJMUUFDUVJCMElBTnlJZ00yQWdBTElBQWdBUzBBQVVFSWRDQURhallDQUFzZ0FTQUNha0YvYWkwQUFDSUJSUVJBSUFCQkFEWUNCRUZzRHdzZ0FFRW9JQUVRRkNBQ1FRTjBhbXMyQWdRZ0Fnc1dBQ0FBSUFFcEFBQTNBQUFnQUNBQktRQUlOd0FJQ3k4QkFYOGdBVUVDZEVHZ0hXb29BZ0FnQUNnQ0FFRWdJQUVnQUNnQ0JHcHJRUjl4ZG5FaEFpQUFJQUVRQVNBQ0N5RUFJQUZDejliVHZ0TEhxOWxDZmlBQWZFSWZpVUtIbGErdm1MYmVtNTUvZmdzZEFRRi9JQUFvQWdnZ0FDZ0NERVlFZnlBQUtBSUVRU0JHQlVFQUN3dUNCQUVEZnlBQ1FZREFBRThFUUNBQUlBRWdBaEJuSUFBUEN5QUFJQUpxSVFNQ1FDQUFJQUZ6UVFOeFJRUkFBa0FnQWtFQlNBUkFJQUFoQWd3QkN5QUFRUU54UlFSQUlBQWhBZ3dCQ3lBQUlRSURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURUdzBCSUFKQkEzRU5BQXNMQWtBZ0EwRjhjU0lFUWNBQVNRMEFJQUlnQkVGQWFpSUZTdzBBQTBBZ0FpQUJLQUlBTmdJQUlBSWdBU2dDQkRZQ0JDQUNJQUVvQWdnMkFnZ2dBaUFCS0FJTU5nSU1JQUlnQVNnQ0VEWUNFQ0FDSUFFb0FoUTJBaFFnQWlBQktBSVlOZ0lZSUFJZ0FTZ0NIRFlDSENBQ0lBRW9BaUEyQWlBZ0FpQUJLQUlrTmdJa0lBSWdBU2dDS0RZQ0tDQUNJQUVvQWl3MkFpd2dBaUFCS0FJd05nSXdJQUlnQVNnQ05EWUNOQ0FDSUFFb0FqZzJBamdnQWlBQktBSThOZ0k4SUFGQlFHc2hBU0FDUVVCcklnSWdCVTBOQUFzTElBSWdCRThOQVFOQUlBSWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0FrRUVhaUlDSUFSSkRRQUxEQUVMSUFOQkJFa0VRQ0FBSVFJTUFRc2dBMEY4YWlJRUlBQkpCRUFnQUNFQ0RBRUxJQUFoQWdOQUlBSWdBUzBBQURvQUFDQUNJQUV0QUFFNkFBRWdBaUFCTFFBQ09nQUNJQUlnQVMwQUF6b0FBeUFCUVFScUlRRWdBa0VFYWlJQ0lBUk5EUUFMQ3lBQ0lBTkpCRUFEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEUncwQUN3c2dBQXNNQUNBQUlBRXBBQUEzQUFBTFFRRUNmeUFBS0FJSUlnRWdBQ2dDRUVrRVFFRUREd3NnQUNBQUtBSUVJZ0pCQjNFMkFnUWdBQ0FCSUFKQkEzWnJJZ0UyQWdnZ0FDQUJLQUFBTmdJQVFRQUxEQUFnQUNBQktBSUFOZ0FBQy9jQ0FRSi9Ba0FnQUNBQlJnMEFBa0FnQVNBQ2FpQUFTd1JBSUFBZ0Ftb2lCQ0FCU3cwQkN5QUFJQUVnQWhBTER3c2dBQ0FCYzBFRGNTRURBa0FDUUNBQUlBRkpCRUFnQXdSQUlBQWhBd3dEQ3lBQVFRTnhSUVJBSUFBaEF3d0NDeUFBSVFNRFFDQUNSUTBFSUFNZ0FTMEFBRG9BQUNBQlFRRnFJUUVnQWtGL2FpRUNJQU5CQVdvaUEwRURjUTBBQ3d3QkN3SkFJQU1OQUNBRVFRTnhCRUFEUUNBQ1JRMEZJQUFnQWtGL2FpSUNhaUlESUFFZ0Ftb3RBQUE2QUFBZ0EwRURjUTBBQ3dzZ0FrRURUUTBBQTBBZ0FDQUNRWHhxSWdKcUlBRWdBbW9vQWdBMkFnQWdBa0VEU3cwQUN3c2dBa1VOQWdOQUlBQWdBa0YvYWlJQ2FpQUJJQUpxTFFBQU9nQUFJQUlOQUFzTUFnc2dBa0VEVFEwQUlBSWhCQU5BSUFNZ0FTZ0NBRFlDQUNBQlFRUnFJUUVnQTBFRWFpRURJQVJCZkdvaUJFRURTdzBBQ3lBQ1FRTnhJUUlMSUFKRkRRQURRQ0FESUFFdEFBQTZBQUFnQTBFQmFpRURJQUZCQVdvaEFTQUNRWDlxSWdJTkFBc0xJQUFMOHdJQ0FuOEJmZ0pBSUFKRkRRQWdBQ0FDYWlJRFFYOXFJQUU2QUFBZ0FDQUJPZ0FBSUFKQkEwa05BQ0FEUVg1cUlBRTZBQUFnQUNBQk9nQUJJQU5CZldvZ0FUb0FBQ0FBSUFFNkFBSWdBa0VIU1EwQUlBTkJmR29nQVRvQUFDQUFJQUU2QUFNZ0FrRUpTUTBBSUFCQkFDQUFhMEVEY1NJRWFpSURJQUZCL3dGeFFZR0NoQWhzSWdFMkFnQWdBeUFDSUFSclFYeHhJZ1JxSWdKQmZHb2dBVFlDQUNBRVFRbEpEUUFnQXlBQk5nSUlJQU1nQVRZQ0JDQUNRWGhxSUFFMkFnQWdBa0YwYWlBQk5nSUFJQVJCR1VrTkFDQURJQUUyQWhnZ0F5QUJOZ0lVSUFNZ0FUWUNFQ0FESUFFMkFnd2dBa0Z3YWlBQk5nSUFJQUpCYkdvZ0FUWUNBQ0FDUVdocUlBRTJBZ0FnQWtGa2FpQUJOZ0lBSUFRZ0EwRUVjVUVZY2lJRWF5SUNRU0JKRFFBZ0FhMGlCVUlnaGlBRmhDRUZJQU1nQkdvaEFRTkFJQUVnQlRjREdDQUJJQVUzQXhBZ0FTQUZOd01JSUFFZ0JUY0RBQ0FCUVNCcUlRRWdBa0ZnYWlJQ1FSOUxEUUFMQ3lBQUN5OEJBbjhnQUNnQ0JDQUFLQUlBUVFKMGFpSUNMUUFDSVFNZ0FDQUNMd0VBSUFFZ0FpMEFBeEFJYWpZQ0FDQURDeThCQW44Z0FDZ0NCQ0FBS0FJQVFRSjBhaUlDTFFBQ0lRTWdBQ0FDTHdFQUlBRWdBaTBBQXhBRmFqWUNBQ0FEQ3g4QUlBQWdBU0FDS0FJRUVBZzJBZ0FnQVJBRUdpQUFJQUpCQ0dvMkFnUUxDQUFnQUdkQkgzTUx1Z1VCRFg4akFFRVFheUlLSkFBQ2Z5QUVRUU5OQkVBZ0NrRUFOZ0lNSUFwQkRHb2dBeUFFRUFzYUlBQWdBU0FDSUFwQkRHcEJCQkFWSWdCQmJDQUFFQU1iSUFBZ0FDQUVTeHNNQVFzZ0FFRUFJQUVvQWdCQkFYUkJBbW9RRUNFTlFWUWdBeWdBQUNJR1FROXhJZ0JCQ2tzTkFCb2dBaUFBUVFWcU5nSUFJQU1nQkdvaUFrRjhhaUVNSUFKQmVXb2hEaUFDUVh0cUlSQWdBRUVHYWlFTFFRUWhCU0FHUVFSMklRUkJJQ0FBZENJQVFRRnlJUWtnQVNnQ0FDRVBRUUFoQWlBRElRWUNRQU5BSUFsQkFrZ2dBaUFQUzNKRkJFQWdBaUVIQWtBZ0NBUkFBMEFnQkVILy93TnhRZi8vQTBZRVFDQUhRUmhxSVFjZ0JpQVFTUVIvSUFaQkFtb2lCaWdBQUNBRmRnVWdCVUVRYWlFRklBUkJFSFlMSVFRTUFRc0xBMEFnQkVFRGNTSUlRUU5HQkVBZ0JVRUNhaUVGSUFSQkFuWWhCQ0FIUVFOcUlRY01BUXNMSUFjZ0NHb2lCeUFQU3cwRUlBVkJBbW9oQlFOQUlBSWdCMGtFUUNBTklBSkJBWFJxUVFBN0FRQWdBa0VCYWlFQ0RBRUxDeUFHSUE1TFFRQWdCaUFGUVFOMWFpSUhJQXhMRzBVRVFDQUhLQUFBSUFWQkIzRWlCWFloQkF3Q0N5QUVRUUoySVFRTElBWWhCd3NDZnlBTFFYOXFJQVFnQUVGL2FuRWlCaUFBUVFGMFFYOXFJZ2dnQ1dzaUVVa05BQm9nQkNBSWNTSUVRUUFnRVNBRUlBQklHMnNoQmlBTEN5RUlJQTBnQWtFQmRHb2dCa0YvYWlJRU93RUFJQWxCQVNBR2F5QUVJQVpCQVVnYmF5RUpBMEFnQ1NBQVNBUkFJQUJCQVhVaEFDQUxRWDlxSVFzTUFRc0xBbjhnQnlBT1MwRUFJQWNnQlNBSWFpSUZRUU4xYWlJR0lBeExHMFVFUUNBRlFRZHhEQUVMSUFVZ0RDSUdJQWRyUVFOMGF3c2hCU0FDUVFGcUlRSWdCRVVoQ0NBR0tBQUFJQVZCSDNGMklRUU1BUXNMUVd3Z0NVRUJSeUFGUVNCS2NnMEJHaUFCSUFKQmYybzJBZ0FnQmlBRlFRZHFRUU4xYWlBRGF3d0JDMEZRQ3lFQUlBcEJFR29rQUNBQUN3a0FRUUZCQlNBQUd3c01BQ0FBSUFFb0FBQTJBQUFMcWdNQkNuOGpBRUh3QUdzaUNpUUFJQUpCQVdvaERpQUFRUWhxSVF0QmdJQUVJQVZCZjJwMFFSQjFJUXhCQUNFQ1FRRWhCa0VCSUFWMElnbEJmMm9pRHlFSUEwQWdBaUFPUmtVRVFBSkFJQUVnQWtFQmRDSU5haThCQUNJSFFmLy9BMFlFUUNBTElBaEJBM1JxSUFJMkFnUWdDRUYvYWlFSVFRRWhCd3dCQ3lBR1FRQWdEQ0FIUVJCMFFSQjFTaHNoQmdzZ0NpQU5haUFIT3dFQUlBSkJBV29oQWd3QkN3c2dBQ0FGTmdJRUlBQWdCallDQUNBSlFRTjJJQWxCQVhacVFRTnFJUXhCQUNFQVFRQWhCa0VBSVFJRFFDQUdJQTVHQkVBRFFBSkFJQUFnQ1VZTkFDQUtJQXNnQUVFRGRHb2lBU2dDQkNJR1FRRjBhaUlDSUFJdkFRQWlBa0VCYWpzQkFDQUJJQVVnQWhBVWF5SUlPZ0FESUFFZ0FpQUlRZjhCY1hRZ0NXczdBUUFnQVNBRUlBWkJBblFpQW1vb0FnQTZBQUlnQVNBQ0lBTnFLQUlBTmdJRUlBQkJBV29oQUF3QkN3c0ZJQUVnQmtFQmRHb3VBUUFoRFVFQUlRY0RRQ0FISUExT1JRUkFJQXNnQWtFRGRHb2dCallDQkFOQUlBSWdER29nRDNFaUFpQUlTdzBBQ3lBSFFRRnFJUWNNQVFzTElBWkJBV29oQmd3QkN3c2dDa0h3QUdva0FBc2pBRUlBSUFFUUNTQUFoVUtIbGErdm1MYmVtNTUvZmtMajNNcVYvTTd5OVlWL2ZBc1FBQ0FBUW40M0F3Z2dBQ0FCTmdJQUN5UUJBWDhnQUFSQUlBRW9BZ1FpQWdSQUlBRW9BZ2dnQUNBQ0VRRUFEd3NnQUJBbUN3c2ZBQ0FBSUFFZ0FpOEJBQkFJTmdJQUlBRVFCQm9nQUNBQ1FRUnFOZ0lFQzBvQkFYOUJvQ0FvQWdBaUFTQUFhaUlBUVg5TUJFQkJpQ0JCTURZQ0FFRi9Ed3NDUUNBQVB3QkJFSFJORFFBZ0FCQm1EUUJCaUNCQk1EWUNBRUYvRHd0Qm9DQWdBRFlDQUNBQkM5Y0JBUWgvUWJwL0lRb0NRQ0FDS0FJRUlnZ2dBaWdDQUNJSmFpSU9JQUVnQUd0TERRQkJiQ0VLSUFrZ0JDQURLQUlBSWd0clN3MEFJQUFnQ1dvaUJDQUNLQUlJSWd4cklRMGdBQ0FCUVdCcUlnOGdDeUFKUVFBUUtTQURJQWtnQzJvMkFnQUNRQUpBSUF3Z0JDQUZhMDBFUUNBTklRVU1BUXNnRENBRUlBWnJTdzBDSUFjZ0RTQUZheUlBYWlJQklBaHFJQWROQkVBZ0JDQUJJQWdRRHhvTUFnc2dCQ0FCUVFBZ0FHc1FEeUVCSUFJZ0FDQUlhaUlJTmdJRUlBRWdBR3NoQkFzZ0JDQVBJQVVnQ0VFQkVDa0xJQTRoQ2dzZ0NndWJBZ0VCZnlNQVFZQUJheUlOSkFBZ0RTQUROZ0o4QWtBZ0FrRURTd1JBUVg4aENRd0JDd0pBQWtBQ1FBSkFJQUpCQVdzT0F3QURBZ0VMSUFaRkJFQkJ1SDhoQ1F3RUMwRnNJUWtnQlMwQUFDSUNJQU5MRFFNZ0FDQUhJQUpCQW5RaUFtb29BZ0FnQWlBSWFpZ0NBQkE3SUFFZ0FEWUNBRUVCSVFrTUF3c2dBU0FKTmdJQVFRQWhDUXdDQ3lBS1JRUkFRV3doQ1F3Q0MwRUFJUWtnQzBVZ0RFRVpTSElOQVVFSUlBUjBRUWhxSVFCQkFDRUNBMEFnQWlBQVR3MENJQUpCUUdzaEFnd0FBQXNBQzBGc0lRa2dEU0FOUWZ3QWFpQU5RZmdBYWlBRklBWVFGU0lDRUFNTkFDQU5LQUo0SWdNZ0JFc05BQ0FBSUEwZ0RTZ0NmQ0FISUFnZ0F4QVlJQUVnQURZQ0FDQUNJUWtMSUExQmdBRnFKQUFnQ1FzTEFDQUFJQUVnQWhBTEdnc1FBQ0FBTHdBQUlBQXRBQUpCRUhSeUN5OEFBbjlCdUg4Z0FVRUlTUTBBR2tGeUlBQW9BQVFpQUVGM1N3MEFHa0c0ZnlBQVFRaHFJZ0FnQUNBQlN4c0xDd2tBSUFBZ0FUc0FBQXNEQUFFTGlnWUJCWDhnQUNBQUtBSUFJZ1ZCZm5FMkFnQkJBQ0FBSUFWQkFYWnFRWVFnS0FJQUlnUWdBRVliSVFFQ1FBSkFJQUFvQWdRaUFrVU5BQ0FDS0FJQUlnTkJBWEVOQUNBQ1FRaHFJZ1VnQTBFQmRrRjRhaUlEUVFnZ0EwRUlTeHRuUVI5elFRSjBRWUFmYWlJREtBSUFSZ1JBSUFNZ0FpZ0NERFlDQUFzZ0FpZ0NDQ0lEQkVBZ0F5QUNLQUlNTmdJRUN5QUNLQUlNSWdNRVFDQURJQUlvQWdnMkFnQUxJQUlnQWlnQ0FDQUFLQUlBUVg1eGFqWUNBRUdFSUNFQUFrQUNRQ0FCUlEwQUlBRWdBallDQkNBQktBSUFJZ05CQVhFTkFTQURRUUYyUVhocUlnTkJDQ0FEUVFoTEcyZEJIM05CQW5SQmdCOXFJZ01vQWdBZ0FVRUlha1lFUUNBRElBRW9BZ3cyQWdBTElBRW9BZ2dpQXdSQUlBTWdBU2dDRERZQ0JBc2dBU2dDRENJREJFQWdBeUFCS0FJSU5nSUFRWVFnS0FJQUlRUUxJQUlnQWlnQ0FDQUJLQUlBUVg1eGFqWUNBQ0FCSUFSR0RRQWdBU0FCS0FJQVFRRjJha0VFYWlFQUN5QUFJQUkyQWdBTElBSW9BZ0JCQVhaQmVHb2lBRUVJSUFCQkNFc2JaMEVmYzBFQ2RFR0FIMm9pQVNnQ0FDRUFJQUVnQlRZQ0FDQUNJQUEyQWd3Z0FrRUFOZ0lJSUFCRkRRRWdBQ0FGTmdJQUR3c0NRQ0FCUlEwQUlBRW9BZ0FpQWtFQmNRMEFJQUpCQVhaQmVHb2lBa0VJSUFKQkNFc2JaMEVmYzBFQ2RFR0FIMm9pQWlnQ0FDQUJRUWhxUmdSQUlBSWdBU2dDRERZQ0FBc2dBU2dDQ0NJQ0JFQWdBaUFCS0FJTU5nSUVDeUFCS0FJTUlnSUVRQ0FDSUFFb0FnZzJBZ0JCaENBb0FnQWhCQXNnQUNBQUtBSUFJQUVvQWdCQmZuRnFJZ0kyQWdBQ1FDQUJJQVJIQkVBZ0FTQUJLQUlBUVFGMmFpQUFOZ0lFSUFBb0FnQWhBZ3dCQzBHRUlDQUFOZ0lBQ3lBQ1FRRjJRWGhxSWdGQkNDQUJRUWhMRzJkQkgzTkJBblJCZ0I5cUlnSW9BZ0FoQVNBQ0lBQkJDR29pQWpZQ0FDQUFJQUUyQWd3Z0FFRUFOZ0lJSUFGRkRRRWdBU0FDTmdJQUR3c2dCVUVCZGtGNGFpSUJRUWdnQVVFSVN4dG5RUjl6UVFKMFFZQWZhaUlDS0FJQUlRRWdBaUFBUVFocUlnSTJBZ0FnQUNBQk5nSU1JQUJCQURZQ0NDQUJSUTBBSUFFZ0FqWUNBQXNMRGdBZ0FBUkFJQUJCZUdvUUpRc0xnQUlCQTM4Q1FDQUFRUTlxUVhoeFFZUWdLQUlBS0FJQVFRRjJheUlDRUIxQmYwWU5BQUpBUVlRZ0tBSUFJZ0FvQWdBaUFVRUJjUTBBSUFGQkFYWkJlR29pQVVFSUlBRkJDRXNiWjBFZmMwRUNkRUdBSDJvaUFTZ0NBQ0FBUVFocVJnUkFJQUVnQUNnQ0REWUNBQXNnQUNnQ0NDSUJCRUFnQVNBQUtBSU1OZ0lFQ3lBQUtBSU1JZ0ZGRFFBZ0FTQUFLQUlJTmdJQUMwRUJJUUVnQUNBQUtBSUFJQUpCQVhScUlnSTJBZ0FnQWtFQmNRMEFJQUpCQVhaQmVHb2lBa0VJSUFKQkNFc2JaMEVmYzBFQ2RFR0FIMm9pQXlnQ0FDRUNJQU1nQUVFSWFpSUROZ0lBSUFBZ0FqWUNEQ0FBUVFBMkFnZ2dBa1VOQUNBQ0lBTTJBZ0FMSUFFTHR3SUJBMzhDUUFKQUlBQkJBU0FBR3lJQ0VEZ2lBQTBBQWtBQ1FFR0VJQ2dDQUNJQVJRMEFJQUFvQWdBaUEwRUJjUTBBSUFBZ0EwRUJjallDQUNBRFFRRjJRWGhxSWdGQkNDQUJRUWhMRzJkQkgzTkJBblJCZ0I5cUlnRW9BZ0FnQUVFSWFrWUVRQ0FCSUFBb0FndzJBZ0FMSUFBb0FnZ2lBUVJBSUFFZ0FDZ0NERFlDQkFzZ0FDZ0NEQ0lCQkVBZ0FTQUFLQUlJTmdJQUN5QUNFQ2NoQWtFQUlRRkJoQ0FvQWdBaEFDQUNEUUVnQUNBQUtBSUFRWDV4TmdJQVFRQVBDeUFDUVE5cVFYaHhJZ01RSFNJQ1FYOUdEUUlnQWtFSGFrRjRjU0lBSUFKSEJFQWdBQ0FDYXhBZFFYOUdEUU1MQWtCQmhDQW9BZ0FpQVVVRVFFR0FJQ0FBTmdJQURBRUxJQUFnQVRZQ0JBdEJoQ0FnQURZQ0FDQUFJQU5CQVhSQkFYSTJBZ0FNQVFzZ0FFVU5BUXNnQUVFSWFpRUJDeUFCQzdrREFRSi9JQUFnQTJvaEJRSkFJQU5CQjB3RVFBTkFJQUFnQlU4TkFpQUFJQUl0QUFBNkFBQWdBRUVCYWlFQUlBSkJBV29oQWd3QUFBc0FDeUFFUVFGR0JFQUNRQ0FBSUFKcklnWkJCMDBFUUNBQUlBSXRBQUE2QUFBZ0FDQUNMUUFCT2dBQklBQWdBaTBBQWpvQUFpQUFJQUl0QUFNNkFBTWdBRUVFYWlBQ0lBWkJBblFpQmtIQUhtb29BZ0JxSWdJUUZ5QUNJQVpCNEI1cUtBSUFheUVDREFFTElBQWdBaEFNQ3lBQ1FRaHFJUUlnQUVFSWFpRUFDd0pBQWtBQ1FBSkFJQVVnQVUwRVFDQUFJQU5xSVFFZ0JFRUJSeUFBSUFKclFROUtjZzBCQTBBZ0FDQUNFQXdnQWtFSWFpRUNJQUJCQ0dvaUFDQUJTUTBBQ3d3RkN5QUFJQUZMQkVBZ0FDRUJEQVFMSUFSQkFVY2dBQ0FDYTBFUFNuSU5BU0FBSVFNZ0FpRUVBMEFnQXlBRUVBd2dCRUVJYWlFRUlBTkJDR29pQXlBQlNRMEFDd3dDQ3dOQUlBQWdBaEFISUFKQkVHb2hBaUFBUVJCcUlnQWdBVWtOQUFzTUF3c2dBQ0VESUFJaEJBTkFJQU1nQkJBSElBUkJFR29oQkNBRFFSQnFJZ01nQVVrTkFBc0xJQUlnQVNBQWEyb2hBZ3NEUUNBQklBVlBEUUVnQVNBQ0xRQUFPZ0FBSUFGQkFXb2hBU0FDUVFGcUlRSU1BQUFMQUFzTFFRRUNmeUFBSUFBb0FyamdBU0lETmdMRTRBRWdBQ2dDdk9BQklRUWdBQ0FCTmdLODRBRWdBQ0FCSUFKcU5nSzQ0QUVnQUNBQklBUWdBMnRxTmdMQTRBRUxwZ0VCQVg4Z0FDQUFLQUxzNFFFUUZqWUN5T0FCSUFCQ0FEY0QrT0FCSUFCQ0FEY0R1T0FCSUFCQndPQUJha0lBTndNQUlBQkJxTkFBYWlJQlFZeUFnT0FBTmdJQUlBQkJBRFlDbU9JQklBQkNBRGNEaU9FQklBQkNBemNEZ09FQklBQkJyTkFCYWtIZ0Vpa0NBRGNDQUNBQVFiVFFBV3BCNkJJb0FnQTJBZ0FnQUNBQk5nSU1JQUFnQUVHWUlHbzJBZ2dnQUNBQVFhQXdhallDQkNBQUlBQkJFR28yQWdBTFlRRUJmMEc0ZnlFREFrQWdBVUVEU1EwQUlBSWdBQkFoSWdGQkEzWWlBRFlDQ0NBQ0lBRkJBWEUyQWdRZ0FpQUJRUUYyUVFOeElnTTJBZ0FDUUNBRFFYOXFJZ0ZCQWtzTkFBSkFJQUZCQVdzT0FnRUFBZ3RCYkE4TElBQWhBd3NnQXdzTUFDQUFJQUVnQWtFQUVDNExpQVFDQTM4Q2ZpQURFQlloQkNBQVFRQkJLQkFRSVFBZ0JDQUNTd1JBSUFRUEN5QUJSUVJBUVg4UEN3SkFBa0FnQTBFQlJnMEFJQUVvQUFBaUJrR282cjVwUmcwQVFYWWhBeUFHUVhCeFFkRFV0TUlCUncwQlFRZ2hBeUFDUVFoSkRRRWdBRUVBUVNnUUVDRUFJQUVvQUFRaEFTQUFRUUUyQWhRZ0FDQUJyVGNEQUVFQUR3c2dBU0FDSUFNUUx5SURJQUpMRFFBZ0FDQUROZ0lZUVhJaEF5QUJJQVJxSWdWQmYyb3RBQUFpQWtFSWNRMEFJQUpCSUhFaUJrVUVRRUZ3SVFNZ0JTMEFBQ0lGUWFjQlN3MEJJQVZCQjNHdFFnRWdCVUVEZGtFS2FxMkdJZ2RDQTRoK0lBZDhJUWdnQkVFQmFpRUVDeUFDUVFaMklRTWdBa0VDZGlFRkFrQWdBa0VEY1VGL2FpSUNRUUpMQkVCQkFDRUNEQUVMQWtBQ1FBSkFJQUpCQVdzT0FnRUNBQXNnQVNBRWFpMEFBQ0VDSUFSQkFXb2hCQXdDQ3lBQklBUnFMd0FBSVFJZ0JFRUNhaUVFREFFTElBRWdCR29vQUFBaEFpQUVRUVJxSVFRTElBVkJBWEVoQlFKK0FrQUNRQUpBSUFOQmYyb2lBMEVDVFFSQUlBTkJBV3NPQWdJREFRdENmeUFHUlEwREdpQUJJQVJxTVFBQURBTUxJQUVnQkdvdkFBQ3RRb0FDZkF3Q0N5QUJJQVJxS0FBQXJRd0JDeUFCSUFScUtRQUFDeUVISUFBZ0JUWUNJQ0FBSUFJMkFod2dBQ0FITndNQVFRQWhBeUFBUVFBMkFoUWdBQ0FISUFnZ0Joc2lCemNEQ0NBQUlBZENnSUFJSUFkQ2dJQUlWQnMrQWhBTElBTUxXd0VCZjBHNGZ5RURJQUlRRmlJQ0lBRk5CSDhnQUNBQ2FrRi9haTBBQUNJQVFRTnhRUUowUWFBZWFpZ0NBQ0FDYWlBQVFRWjJJZ0ZCQW5SQnNCNXFLQUlBYWlBQVFTQnhJZ0JGYWlBQlJTQUFRUVYyY1dvRlFiaC9Dd3NkQUNBQUtBS1E0Z0VRV2lBQVFRQTJBcURpQVNBQVFnQTNBNURpQVF1MUF3RUZmeU1BUVpBQ2F5SUtKQUJCdUg4aEJnSkFJQVZGRFFBZ0JDd0FBQ0lJUWY4QmNTRUhBa0FnQ0VGL1RBUkFJQWRCZ245cVFRRjJJZ2dnQlU4TkFrRnNJUVlnQjBHQmYyb2lCVUdBQWs4TkFpQUVRUUZxSVFkQkFDRUdBMEFnQmlBRlR3UkFJQVVoQmlBSUlRY01Bd1VnQUNBR2FpQUhJQVpCQVhacUlnUXRBQUJCQkhZNkFBQWdBQ0FHUVFGeWFpQUVMUUFBUVE5eE9nQUFJQVpCQW1vaEJnd0JDd0FBQ3dBTElBY2dCVThOQVNBQUlBUkJBV29nQnlBS0VGTWlCaEFERFFFTElBWWhCRUVBSVFZZ0FVRUFRVFFRRUNFSlFRQWhCUU5BSUFRZ0JrY0VRQ0FBSUFacUlnZ3RBQUFpQVVFTFN3UkFRV3doQmd3REJTQUpJQUZCQW5ScUlnRWdBU2dDQUVFQmFqWUNBQ0FHUVFGcUlRWkJBU0FJTFFBQWRFRUJkU0FGYWlFRkRBSUxBQXNMUVd3aEJpQUZSUTBBSUFVUUZFRUJhaUlCUVF4TERRQWdBeUFCTmdJQVFRRkJBU0FCZENBRmF5SURFQlFpQVhRZ0EwY05BQ0FBSUFScUlBRkJBV29pQURvQUFDQUpJQUJCQW5ScUlnQWdBQ2dDQUVFQmFqWUNBQ0FKS0FJRUlnQkJBa2tnQUVFQmNYSU5BQ0FDSUFSQkFXbzJBZ0FnQjBFQmFpRUdDeUFLUVpBQ2FpUUFJQVlMeGhFQkRIOGpBRUh3QUdzaUJTUUFRV3doQ3dKQUlBTkJDa2tOQUNBQ0x3QUFJUW9nQWk4QUFpRUpJQUl2QUFRaEJ5QUZRUWhxSUFRUURnSkFJQU1nQnlBSklBcHFha0VHYWlJTVNRMEFJQVV0QUFvaENDQUZRZGdBYWlBQ1FRWnFJZ0lnQ2hBR0lnc1FBdzBCSUFWQlFHc2dBaUFLYWlJQ0lBa1FCaUlMRUFNTkFTQUZRU2hxSUFJZ0NXb2lBaUFIRUFZaUN4QUREUUVnQlVFUWFpQUNJQWRxSUFNZ0RHc1FCaUlMRUFNTkFTQUFJQUZxSWc5QmZXb2hFQ0FFUVFScUlRWkJBU0VMSUFBZ0FVRURha0VDZGlJRGFpSU1JQU5xSWdJZ0Eyb2lEaUVESUFJaEJDQU1JUWNEUUNBTElBTWdFRWx4QkVBZ0FDQUdJQVZCMkFCcUlBZ1FBa0VDZEdvaUNTOEJBRHNBQUNBRlFkZ0FhaUFKTFFBQ0VBRWdDUzBBQXlFTElBY2dCaUFGUVVCcklBZ1FBa0VDZEdvaUNTOEJBRHNBQUNBRlFVQnJJQWt0QUFJUUFTQUpMUUFESVFvZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJSkx3RUFPd0FBSUFWQktHb2dDUzBBQWhBQklBa3RBQU1oQ1NBRElBWWdCVUVRYWlBSUVBSkJBblJxSWcwdkFRQTdBQUFnQlVFUWFpQU5MUUFDRUFFZ0RTMEFBeUVOSUFBZ0Myb2lDeUFHSUFWQjJBQnFJQWdRQWtFQ2RHb2lBQzhCQURzQUFDQUZRZGdBYWlBQUxRQUNFQUVnQUMwQUF5RUFJQWNnQ21vaUNpQUdJQVZCUUdzZ0NCQUNRUUowYWlJSEx3RUFPd0FBSUFWQlFHc2dCeTBBQWhBQklBY3RBQU1oQnlBRUlBbHFJZ2tnQmlBRlFTaHFJQWdRQWtFQ2RHb2lCQzhCQURzQUFDQUZRU2hxSUFRdEFBSVFBU0FFTFFBRElRUWdBeUFOYWlJRElBWWdCVUVRYWlBSUVBSkJBblJxSWcwdkFRQTdBQUFnQlVFUWFpQU5MUUFDRUFFZ0FDQUxhaUVBSUFjZ0Ntb2hCeUFFSUFscUlRUWdBeUFOTFFBRGFpRURJQVZCMkFCcUVBMGdCVUZBYXhBTmNpQUZRU2hxRUExeUlBVkJFR29RRFhKRklRc01BUXNMSUFRZ0Rrc2dCeUFDUzNJTkFFRnNJUXNnQUNBTVN3MEJJQXhCZldvaENRTkFRUUFnQUNBSlNTQUZRZGdBYWhBRUd3UkFJQUFnQmlBRlFkZ0FhaUFJRUFKQkFuUnFJZ292QVFBN0FBQWdCVUhZQUdvZ0NpMEFBaEFCSUFBZ0NpMEFBMm9pQUNBR0lBVkIyQUJxSUFnUUFrRUNkR29pQ2k4QkFEc0FBQ0FGUWRnQWFpQUtMUUFDRUFFZ0FDQUtMUUFEYWlFQURBRUZJQXhCZm1vaENnTkFJQVZCMkFCcUVBUWdBQ0FLUzNKRkJFQWdBQ0FHSUFWQjJBQnFJQWdRQWtFQ2RHb2lDUzhCQURzQUFDQUZRZGdBYWlBSkxRQUNFQUVnQUNBSkxRQURhaUVBREFFTEN3TkFJQUFnQ2swRVFDQUFJQVlnQlVIWUFHb2dDQkFDUVFKMGFpSUpMd0VBT3dBQUlBVkIyQUJxSUFrdEFBSVFBU0FBSUFrdEFBTnFJUUFNQVFzTEFrQWdBQ0FNVHcwQUlBQWdCaUFGUWRnQWFpQUlFQUlpQUVFQ2RHb2lEQzBBQURvQUFDQU1MUUFEUVFGR0JFQWdCVUhZQUdvZ0RDMEFBaEFCREFFTElBVW9BbHhCSDBzTkFDQUZRZGdBYWlBR0lBQkJBblJxTFFBQ0VBRWdCU2dDWEVFaFNRMEFJQVZCSURZQ1hBc2dBa0Y5YWlFTUEwQkJBQ0FISUF4SklBVkJRR3NRQkJzRVFDQUhJQVlnQlVGQWF5QUlFQUpCQW5ScUlnQXZBUUE3QUFBZ0JVRkFheUFBTFFBQ0VBRWdCeUFBTFFBRGFpSUFJQVlnQlVGQWF5QUlFQUpCQW5ScUlnY3ZBUUE3QUFBZ0JVRkFheUFITFFBQ0VBRWdBQ0FITFFBRGFpRUhEQUVGSUFKQmZtb2hEQU5BSUFWQlFHc1FCQ0FISUF4TGNrVUVRQ0FISUFZZ0JVRkFheUFJRUFKQkFuUnFJZ0F2QVFBN0FBQWdCVUZBYXlBQUxRQUNFQUVnQnlBQUxRQURhaUVIREFFTEN3TkFJQWNnREUwRVFDQUhJQVlnQlVGQWF5QUlFQUpCQW5ScUlnQXZBUUE3QUFBZ0JVRkFheUFBTFFBQ0VBRWdCeUFBTFFBRGFpRUhEQUVMQ3dKQUlBY2dBazhOQUNBSElBWWdCVUZBYXlBSUVBSWlBRUVDZEdvaUFpMEFBRG9BQUNBQ0xRQURRUUZHQkVBZ0JVRkFheUFDTFFBQ0VBRU1BUXNnQlNnQ1JFRWZTdzBBSUFWQlFHc2dCaUFBUVFKMGFpMEFBaEFCSUFVb0FrUkJJVWtOQUNBRlFTQTJBa1FMSUE1QmZXb2hBZ05BUVFBZ0JDQUNTU0FGUVNocUVBUWJCRUFnQkNBR0lBVkJLR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCS0dvZ0FDMEFBaEFCSUFRZ0FDMEFBMm9pQUNBR0lBVkJLR29nQ0JBQ1FRSjBhaUlFTHdFQU93QUFJQVZCS0dvZ0JDMEFBaEFCSUFBZ0JDMEFBMm9oQkF3QkJTQU9RWDVxSVFJRFFDQUZRU2hxRUFRZ0JDQUNTM0pGQkVBZ0JDQUdJQVZCS0dvZ0NCQUNRUUowYWlJQUx3RUFPd0FBSUFWQktHb2dBQzBBQWhBQklBUWdBQzBBQTJvaEJBd0JDd3NEUUNBRUlBSk5CRUFnQkNBR0lBVkJLR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCS0dvZ0FDMEFBaEFCSUFRZ0FDMEFBMm9oQkF3QkN3c0NRQ0FFSUE1UERRQWdCQ0FHSUFWQktHb2dDQkFDSWdCQkFuUnFJZ0l0QUFBNkFBQWdBaTBBQTBFQlJnUkFJQVZCS0dvZ0FpMEFBaEFCREFFTElBVW9BaXhCSDBzTkFDQUZRU2hxSUFZZ0FFRUNkR290QUFJUUFTQUZLQUlzUVNGSkRRQWdCVUVnTmdJc0N3TkFRUUFnQXlBUVNTQUZRUkJxRUFRYkJFQWdBeUFHSUFWQkVHb2dDQkFDUVFKMGFpSUFMd0VBT3dBQUlBVkJFR29nQUMwQUFoQUJJQU1nQUMwQUEyb2lBQ0FHSUFWQkVHb2dDQkFDUVFKMGFpSUNMd0VBT3dBQUlBVkJFR29nQWkwQUFoQUJJQUFnQWkwQUEyb2hBd3dCQlNBUFFYNXFJUUlEUUNBRlFSQnFFQVFnQXlBQ1MzSkZCRUFnQXlBR0lBVkJFR29nQ0JBQ1FRSjBhaUlBTHdFQU93QUFJQVZCRUdvZ0FDMEFBaEFCSUFNZ0FDMEFBMm9oQXd3QkN3c0RRQ0FESUFKTkJFQWdBeUFHSUFWQkVHb2dDQkFDUVFKMGFpSUFMd0VBT3dBQUlBVkJFR29nQUMwQUFoQUJJQU1nQUMwQUEyb2hBd3dCQ3dzQ1FDQURJQTlQRFFBZ0F5QUdJQVZCRUdvZ0NCQUNJZ0JCQW5ScUlnSXRBQUE2QUFBZ0FpMEFBMEVCUmdSQUlBVkJFR29nQWkwQUFoQUJEQUVMSUFVb0FoUkJIMHNOQUNBRlFSQnFJQVlnQUVFQ2RHb3RBQUlRQVNBRktBSVVRU0ZKRFFBZ0JVRWdOZ0lVQ3lBQlFXd2dCVUhZQUdvUUNpQUZRVUJyRUFweElBVkJLR29RQ25FZ0JVRVFhaEFLY1JzaEN3d0pDd0FBQ3dBTEFBQUxBQXNBQUFzQUN3QUFDd0FMUVd3aEN3c2dCVUh3QUdva0FDQUxDN1VFQVE1L0l3QkJFR3NpQmlRQUlBWkJCR29nQUJBT1FWUWhCUUpBSUFSQjNBdEpEUUFnQmkwQUJDRUhJQU5COEFScVFRQkI3QUFRRUNFSUlBZEJERXNOQUNBRFFkd0phaUlKSUFnZ0JrRUlhaUFHUVF4cUlBRWdBaEF4SWhBUUEwVUVRQ0FHS0FJTUlnUWdCMHNOQVNBRFFkd0ZhaUVQSUFOQnBBVnFJUkVnQUVFRWFpRVNJQU5CcUFWcUlRRWdCQ0VGQTBBZ0JTSUNRWDlxSVFVZ0NDQUNRUUowYWlnQ0FFVU5BQXNnQWtFQmFpRU9RUUVoQlFOQUlBVWdEazlGQkVBZ0NDQUZRUUowSWd0cUtBSUFJUXdnQVNBTGFpQUtOZ0lBSUFWQkFXb2hCU0FLSUF4cUlRb01BUXNMSUFFZ0NqWUNBRUVBSVFVZ0JpZ0NDQ0VMQTBBZ0JTQUxSa1VFUUNBQklBVWdDV290QUFBaURFRUNkR29pRFNBTktBSUFJZzFCQVdvMkFnQWdEeUFOUVFGMGFpSU5JQXc2QUFFZ0RTQUZPZ0FBSUFWQkFXb2hCUXdCQ3d0QkFDRUJJQU5CQURZQ3FBVWdCRUYvY3lBSGFpRUpRUUVoQlFOQUlBVWdEazlGQkVBZ0NDQUZRUUowSWd0cUtBSUFJUXdnQXlBTGFpQUJOZ0lBSUF3Z0JTQUphblFnQVdvaEFTQUZRUUZxSVFVTUFRc0xJQWNnQkVFQmFpSUJJQUpySWdSclFRRnFJUWdEUUVFQklRVWdCQ0FJVDBVRVFBTkFJQVVnRGs5RkJFQWdCVUVDZENJSklBTWdCRUUwYkdwcUlBTWdDV29vQWdBZ0JIWTJBZ0FnQlVFQmFpRUZEQUVMQ3lBRVFRRnFJUVFNQVFzTElCSWdCeUFQSUFvZ0VTQURJQUlnQVJCa0lBWkJBVG9BQlNBR0lBYzZBQVlnQUNBR0tBSUVOZ0lBQ3lBUUlRVUxJQVpCRUdva0FDQUZDOEVOQVF0L0l3QkI4QUJySWdVa0FFRnNJUWtDUUNBRFFRcEpEUUFnQWk4QUFDRUtJQUl2QUFJaERDQUNMd0FFSVFZZ0JVRUlhaUFFRUE0Q1FDQURJQVlnQ2lBTWFtcEJCbW9pRFVrTkFDQUZMUUFLSVFjZ0JVSFlBR29nQWtFR2FpSUNJQW9RQmlJSkVBTU5BU0FGUVVCcklBSWdDbW9pQWlBTUVBWWlDUkFERFFFZ0JVRW9haUFDSUF4cUlnSWdCaEFHSWdrUUF3MEJJQVZCRUdvZ0FpQUdhaUFESUExckVBWWlDUkFERFFFZ0FDQUJhaUlPUVgxcUlROGdCRUVFYWlFR1FRRWhDU0FBSUFGQkEycEJBbllpQW1vaUNpQUNhaUlNSUFKcUlnMGhBeUFNSVFRZ0NpRUNBMEFnQ1NBRElBOUpjUVJBSUFZZ0JVSFlBR29nQnhBQ1FRRjBhaUlJTFFBQUlRc2dCVUhZQUdvZ0NDMEFBUkFCSUFBZ0N6b0FBQ0FHSUFWQlFHc2dCeEFDUVFGMGFpSUlMUUFBSVFzZ0JVRkFheUFJTFFBQkVBRWdBaUFMT2dBQUlBWWdCVUVvYWlBSEVBSkJBWFJxSWdndEFBQWhDeUFGUVNocUlBZ3RBQUVRQVNBRUlBczZBQUFnQmlBRlFSQnFJQWNRQWtFQmRHb2lDQzBBQUNFTElBVkJFR29nQ0MwQUFSQUJJQU1nQ3pvQUFDQUdJQVZCMkFCcUlBY1FBa0VCZEdvaUNDMEFBQ0VMSUFWQjJBQnFJQWd0QUFFUUFTQUFJQXM2QUFFZ0JpQUZRVUJySUFjUUFrRUJkR29pQ0MwQUFDRUxJQVZCUUdzZ0NDMEFBUkFCSUFJZ0N6b0FBU0FHSUFWQktHb2dCeEFDUVFGMGFpSUlMUUFBSVFzZ0JVRW9haUFJTFFBQkVBRWdCQ0FMT2dBQklBWWdCVUVRYWlBSEVBSkJBWFJxSWdndEFBQWhDeUFGUVJCcUlBZ3RBQUVRQVNBRElBczZBQUVnQTBFQ2FpRURJQVJCQW1vaEJDQUNRUUpxSVFJZ0FFRUNhaUVBSUFrZ0JVSFlBR29RRFVWeElBVkJRR3NRRFVWeElBVkJLR29RRFVWeElBVkJFR29RRFVWeElRa01BUXNMSUFRZ0RVc2dBaUFNUzNJTkFFRnNJUWtnQUNBS1N3MEJJQXBCZldvaENRTkFJQVZCMkFCcUVBUWdBQ0FKVDNKRkJFQWdCaUFGUWRnQWFpQUhFQUpCQVhScUlnZ3RBQUFoQ3lBRlFkZ0FhaUFJTFFBQkVBRWdBQ0FMT2dBQUlBWWdCVUhZQUdvZ0J4QUNRUUYwYWlJSUxRQUFJUXNnQlVIWUFHb2dDQzBBQVJBQklBQWdDem9BQVNBQVFRSnFJUUFNQVFzTEEwQWdCVUhZQUdvUUJDQUFJQXBQY2tVRVFDQUdJQVZCMkFCcUlBY1FBa0VCZEdvaUNTMEFBQ0VJSUFWQjJBQnFJQWt0QUFFUUFTQUFJQWc2QUFBZ0FFRUJhaUVBREFFTEN3TkFJQUFnQ2trRVFDQUdJQVZCMkFCcUlBY1FBa0VCZEdvaUNTMEFBQ0VJSUFWQjJBQnFJQWt0QUFFUUFTQUFJQWc2QUFBZ0FFRUJhaUVBREFFTEN5QU1RWDFxSVFBRFFDQUZRVUJyRUFRZ0FpQUFUM0pGQkVBZ0JpQUZRVUJySUFjUUFrRUJkR29pQ2kwQUFDRUpJQVZCUUdzZ0NpMEFBUkFCSUFJZ0NUb0FBQ0FHSUFWQlFHc2dCeEFDUVFGMGFpSUtMUUFBSVFrZ0JVRkFheUFLTFFBQkVBRWdBaUFKT2dBQklBSkJBbW9oQWd3QkN3c0RRQ0FGUVVCckVBUWdBaUFNVDNKRkJFQWdCaUFGUVVCcklBY1FBa0VCZEdvaUFDMEFBQ0VLSUFWQlFHc2dBQzBBQVJBQklBSWdDam9BQUNBQ1FRRnFJUUlNQVFzTEEwQWdBaUFNU1FSQUlBWWdCVUZBYXlBSEVBSkJBWFJxSWdBdEFBQWhDaUFGUVVCcklBQXRBQUVRQVNBQ0lBbzZBQUFnQWtFQmFpRUNEQUVMQ3lBTlFYMXFJUUFEUUNBRlFTaHFFQVFnQkNBQVQzSkZCRUFnQmlBRlFTaHFJQWNRQWtFQmRHb2lBaTBBQUNFS0lBVkJLR29nQWkwQUFSQUJJQVFnQ2pvQUFDQUdJQVZCS0dvZ0J4QUNRUUYwYWlJQ0xRQUFJUW9nQlVFb2FpQUNMUUFCRUFFZ0JDQUtPZ0FCSUFSQkFtb2hCQXdCQ3dzRFFDQUZRU2hxRUFRZ0JDQU5UM0pGQkVBZ0JpQUZRU2hxSUFjUUFrRUJkR29pQUMwQUFDRUNJQVZCS0dvZ0FDMEFBUkFCSUFRZ0Fqb0FBQ0FFUVFGcUlRUU1BUXNMQTBBZ0JDQU5TUVJBSUFZZ0JVRW9haUFIRUFKQkFYUnFJZ0F0QUFBaEFpQUZRU2hxSUFBdEFBRVFBU0FFSUFJNkFBQWdCRUVCYWlFRURBRUxDd05BSUFWQkVHb1FCQ0FESUE5UGNrVUVRQ0FHSUFWQkVHb2dCeEFDUVFGMGFpSUFMUUFBSVFJZ0JVRVFhaUFBTFFBQkVBRWdBeUFDT2dBQUlBWWdCVUVRYWlBSEVBSkJBWFJxSWdBdEFBQWhBaUFGUVJCcUlBQXRBQUVRQVNBRElBSTZBQUVnQTBFQ2FpRUREQUVMQ3dOQUlBVkJFR29RQkNBRElBNVBja1VFUUNBR0lBVkJFR29nQnhBQ1FRRjBhaUlBTFFBQUlRSWdCVUVRYWlBQUxRQUJFQUVnQXlBQ09nQUFJQU5CQVdvaEF3d0JDd3NEUUNBRElBNUpCRUFnQmlBRlFSQnFJQWNRQWtFQmRHb2lBQzBBQUNFQ0lBVkJFR29nQUMwQUFSQUJJQU1nQWpvQUFDQURRUUZxSVFNTUFRc0xJQUZCYkNBRlFkZ0FhaEFLSUFWQlFHc1FDbkVnQlVFb2FoQUtjU0FGUVJCcUVBcHhHeUVKREFFTFFXd2hDUXNnQlVId0FHb2tBQ0FKQzhvQ0FRUi9Jd0JCSUdzaUJTUUFJQVVnQkJBT0lBVXRBQUloQnlBRlFRaHFJQUlnQXhBR0lnSVFBMFVFUUNBRVFRUnFJUUlnQUNBQmFpSURRWDFxSVFRRFFDQUZRUWhxRUFRZ0FDQUVUM0pGQkVBZ0FpQUZRUWhxSUFjUUFrRUJkR29pQmkwQUFDRUlJQVZCQ0dvZ0JpMEFBUkFCSUFBZ0NEb0FBQ0FDSUFWQkNHb2dCeEFDUVFGMGFpSUdMUUFBSVFnZ0JVRUlhaUFHTFFBQkVBRWdBQ0FJT2dBQklBQkJBbW9oQUF3QkN3c0RRQ0FGUVFocUVBUWdBQ0FEVDNKRkJFQWdBaUFGUVFocUlBY1FBa0VCZEdvaUJDMEFBQ0VHSUFWQkNHb2dCQzBBQVJBQklBQWdCam9BQUNBQVFRRnFJUUFNQVFzTEEwQWdBQ0FEVDBVRVFDQUNJQVZCQ0dvZ0J4QUNRUUYwYWlJRUxRQUFJUVlnQlVFSWFpQUVMUUFCRUFFZ0FDQUdPZ0FBSUFCQkFXb2hBQXdCQ3dzZ0FVRnNJQVZCQ0dvUUNoc2hBZ3NnQlVFZ2FpUUFJQUlMdGdNQkNYOGpBRUVRYXlJR0pBQWdCa0VBTmdJTUlBWkJBRFlDQ0VGVUlRUUNRQUpBSUFOQlFHc2lEQ0FESUFaQkNHb2dCa0VNYWlBQklBSVFNU0lDRUFNTkFDQUdRUVJxSUFBUURpQUdLQUlNSWdjZ0JpMEFCRUVCYWtzTkFTQUFRUVJxSVFvZ0JrRUFPZ0FGSUFZZ0J6b0FCaUFBSUFZb0FnUTJBZ0FnQjBFQmFpRUpRUUVoQkFOQUlBUWdDVWtFUUNBRElBUkJBblJxSWdFb0FnQWhBQ0FCSUFVMkFnQWdBQ0FFUVg5cWRDQUZhaUVGSUFSQkFXb2hCQXdCQ3dzZ0IwRUJhaUVIUVFBaEJTQUdLQUlJSVFrRFFDQUZJQWxHRFFFZ0F5QUZJQXhxTFFBQUlnUkJBblJxSWdCQkFTQUVkRUVCZFNJTElBQW9BZ0FpQVdvaUFEWUNBQ0FISUFScklRaEJBQ0VFQWtBZ0MwRURUUVJBQTBBZ0JDQUxSZzBDSUFvZ0FTQUVha0VCZEdvaUFDQUlPZ0FCSUFBZ0JUb0FBQ0FFUVFGcUlRUU1BQUFMQUFzRFFDQUJJQUJQRFFFZ0NpQUJRUUYwYWlJRUlBZzZBQUVnQkNBRk9nQUFJQVFnQ0RvQUF5QUVJQVU2QUFJZ0JDQUlPZ0FGSUFRZ0JUb0FCQ0FFSUFnNkFBY2dCQ0FGT2dBR0lBRkJCR29oQVF3QUFBc0FDeUFGUVFGcUlRVU1BQUFMQUFzZ0FpRUVDeUFHUVJCcUpBQWdCQXV0QVFFQ2Z3SkFRWVFnS0FJQUlBQkhJQUFvQWdCQkFYWWlBeUFCYTBGNGFpSUNRWGh4UVFoSGNnUi9JQUlGSUFNUUowVU5BU0FDUVFocUMwRVFTUTBBSUFBZ0FDZ0NBQ0lDUVFGeElBQWdBV3BCRDJwQmVIRWlBU0FBYTBFQmRISTJBZ0FnQVNBQU5nSUVJQUVnQVNnQ0FFRUJjU0FBSUFKQkFYWnFJQUZySWdKQkFYUnlOZ0lBUVlRZ0lBRWdBa0gvLy8vL0IzRnFRUVJxUVlRZ0tBSUFJQUJHR3lBQk5nSUFJQUVRSlFzTHlnSUJCWDhDUUFKQUFrQWdBRUVJSUFCQkNFc2JaMEVmY3lBQWFVRUJSMm9pQVVFRVNTQUFJQUYyY2cwQUlBRkJBblJCL0I1cUtBSUFJZ0pGRFFBRFFDQUNRWGhxSWdNb0FnQkJBWFpCZUdvaUJTQUFUd1JBSUFJZ0JVRUlJQVZCQ0VzYlowRWZjMEVDZEVHQUgyb2lBU2dDQUVZRVFDQUJJQUlvQWdRMkFnQUxEQU1MSUFSQkhrc05BU0FFUVFGcUlRUWdBaWdDQkNJQ0RRQUxDMEVBSVFNZ0FVRWdUdzBCQTBBZ0FVRUNkRUdBSDJvb0FnQWlBa1VFUUNBQlFSNUxJUUlnQVVFQmFpRUJJQUpGRFFFTUF3c0xJQUlnQWtGNGFpSURLQUlBUVFGMlFYaHFJZ0ZCQ0NBQlFRaExHMmRCSDNOQkFuUkJnQjlxSWdFb0FnQkdCRUFnQVNBQ0tBSUVOZ0lBQ3dzZ0FpZ0NBQ0lCQkVBZ0FTQUNLQUlFTmdJRUN5QUNLQUlFSWdFRVFDQUJJQUlvQWdBMkFnQUxJQU1nQXlnQ0FFRUJjallDQUNBRElBQVFOd3NnQXd2aEN3SU5md1YrSXdCQjhBQnJJZ2NrQUNBSElBQW9BdkRoQVNJSU5nSmNJQUVnQW1vaERTQUlJQUFvQW9EaUFXb2hEd0pBQWtBZ0JVVUVRQ0FCSVFRTUFRc2dBQ2dDeE9BQklSQWdBQ2dDd09BQklSRWdBQ2dDdk9BQklRNGdBRUVCTmdLTTRRRkJBQ0VJQTBBZ0NFRURSd1JBSUFjZ0NFRUNkQ0lDYWlBQUlBSnFRYXpRQVdvb0FnQTJBa1FnQ0VFQmFpRUlEQUVMQzBGc0lRd2dCMEVZYWlBRElBUVFCaEFERFFFZ0IwRXNhaUFIUVJocUlBQW9BZ0FRRXlBSFFUUnFJQWRCR0dvZ0FDZ0NDQkFUSUFkQlBHb2dCMEVZYWlBQUtBSUVFQk1nRFVGZ2FpRVNJQUVoQkVFQUlRd0RRQ0FIS0FJd0lBY29BaXhCQTNScUtRSUFJaFJDRUlpblFmOEJjU0VJSUFjb0FrQWdCeWdDUEVFRGRHb3BBZ0FpRlVJUWlLZEIvd0Z4SVFzZ0J5Z0NPQ0FIS0FJMFFRTjBhaWtDQUNJV1FpQ0lweUVKSUJWQ0lJZ2hGeUFVUWlDSXB5RUNBa0FnRmtJUWlLZEIvd0Z4SWdOQkFrOEVRQUpBSUFaRklBTkJHVWx5UlFSQUlBa2dCMEVZYWlBRFFTQWdCeWdDSEdzaUNpQUtJQU5MR3lJS0VBVWdBeUFLYXlJRGRHb2hDU0FIUVJocUVBUWFJQU5GRFFFZ0IwRVlhaUFERUFVZ0NXb2hDUXdCQ3lBSFFSaHFJQU1RQlNBSmFpRUpJQWRCR0dvUUJCb0xJQWNwQWtRaEdDQUhJQWsyQWtRZ0J5QVlOd05JREFFTEFrQWdBMFVFUUNBQ0JFQWdCeWdDUkNFSkRBTUxJQWNvQWtnaENRd0JDd0pBQWtBZ0IwRVlha0VCRUFVZ0NTQUNSV3BxSWdOQkEwWUVRQ0FIS0FKRVFYOXFJZ01nQTBWcUlRa01BUXNnQTBFQ2RDQUhhaWdDUkNJSklBbEZhaUVKSUFOQkFVWU5BUXNnQnlBSEtBSklOZ0pNQ3dzZ0J5QUhLQUpFTmdKSUlBY2dDVFlDUkFzZ0Y2Y2hBeUFMQkVBZ0IwRVlhaUFMRUFVZ0Eyb2hBd3NnQ0NBTGFrRVVUd1JBSUFkQkdHb1FCQm9MSUFnRVFDQUhRUmhxSUFnUUJTQUNhaUVDQ3lBSFFSaHFFQVFhSUFjZ0IwRVlhaUFVUWhpSXAwSC9BWEVRQ0NBVXAwSC8vd054YWpZQ0xDQUhJQWRCR0dvZ0ZVSVlpS2RCL3dGeEVBZ2dGYWRCLy84RGNXbzJBandnQjBFWWFoQUVHaUFISUFkQkdHb2dGa0lZaUtkQi93RnhFQWdnRnFkQi8vOERjV28yQWpRZ0J5QUNOZ0pnSUFjb0Fsd2hDaUFISUFrMkFtZ2dCeUFETmdKa0FrQUNRQUpBSUFRZ0FpQURhaUlMYWlBU1N3MEFJQUlnQ21vaUV5QVBTdzBBSUEwZ0JHc2dDMEVnYWs4TkFRc2dCeUFIS1FOb053TVFJQWNnQnlrRFlEY0RDQ0FFSUEwZ0IwRUlhaUFIUWR3QWFpQVBJQTRnRVNBUUVCNGhDd3dCQ3lBQ0lBUnFJUWdnQkNBS0VBY2dBa0VSVHdSQUlBUkJFR29oQWdOQUlBSWdDa0VRYWlJS0VBY2dBa0VRYWlJQ0lBaEpEUUFMQ3lBSUlBbHJJUUlnQnlBVE5nSmNJQWtnQ0NBT2Ewc0VRQ0FKSUFnZ0VXdExCRUJCYkNFTERBSUxJQkFnQWlBT2F5SUNhaUlLSUFOcUlCQk5CRUFnQ0NBS0lBTVFEeG9NQWdzZ0NDQUtRUUFnQW1zUUR5RUlJQWNnQWlBRGFpSUROZ0prSUFnZ0Ftc2hDQ0FPSVFJTElBbEJFRThFUUNBRElBaHFJUU1EUUNBSUlBSVFCeUFDUVJCcUlRSWdDRUVRYWlJSUlBTkpEUUFMREFFTEFrQWdDVUVIVFFSQUlBZ2dBaTBBQURvQUFDQUlJQUl0QUFFNkFBRWdDQ0FDTFFBQ09nQUNJQWdnQWkwQUF6b0FBeUFJUVFScUlBSWdDVUVDZENJRFFjQWVhaWdDQUdvaUFoQVhJQUlnQTBIZ0htb29BZ0JySVFJZ0J5Z0NaQ0VEREFFTElBZ2dBaEFNQ3lBRFFRbEpEUUFnQXlBSWFpRURJQWhCQ0dvaUNDQUNRUWhxSWdKclFROU1CRUFEUUNBSUlBSVFEQ0FDUVFocUlRSWdDRUVJYWlJSUlBTkpEUUFNQWdBTEFBc0RRQ0FJSUFJUUJ5QUNRUkJxSVFJZ0NFRVFhaUlJSUFOSkRRQUxDeUFIUVJocUVBUWFJQXNnRENBTEVBTWlBaHNoRENBRUlBUWdDMm9nQWhzaEJDQUZRWDlxSWdVTkFBc2dEQkFERFFGQmJDRU1JQWRCR0dvUUJFRUNTUTBCUVFBaENBTkFJQWhCQTBjRVFDQUFJQWhCQW5RaUFtcEJyTkFCYWlBQ0lBZHFLQUpFTmdJQUlBaEJBV29oQ0F3QkN3c2dCeWdDWENFSUMwRzZmeUVNSUE4Z0NHc2lBQ0FOSUFSclN3MEFJQVFFZnlBRUlBZ2dBQkFMSUFCcUJVRUFDeUFCYXlFTUN5QUhRZkFBYWlRQUlBd0xrUmNDRm44RmZpTUFRZEFCYXlJSEpBQWdCeUFBS0FMdzRRRWlDRFlDdkFFZ0FTQUNhaUVTSUFnZ0FDZ0NnT0lCYWlFVEFrQUNRQ0FGUlFSQUlBRWhBd3dCQ3lBQUtBTEU0QUVoRVNBQUtBTEE0QUVoRlNBQUtBSzg0QUVoRHlBQVFRRTJBb3poQVVFQUlRZ0RRQ0FJUVFOSEJFQWdCeUFJUVFKMElnSnFJQUFnQW1wQnJOQUJhaWdDQURZQ1ZDQUlRUUZxSVFnTUFRc0xJQWNnRVRZQ1pDQUhJQTgyQW1BZ0J5QUJJQTlyTmdKb1FXd2hFQ0FIUVNocUlBTWdCQkFHRUFNTkFTQUZRUVFnQlVFRVNCc2hGeUFIUVR4cUlBZEJLR29nQUNnQ0FCQVRJQWRCeEFCcUlBZEJLR29nQUNnQ0NCQVRJQWRCekFCcUlBZEJLR29nQUNnQ0JCQVRRUUFoQkNBSFFlQUFhaUVNSUFkQjVBQnFJUW9EUUNBSFFTaHFFQVJCQWtzZ0JDQVhUbkpGQkVBZ0J5Z0NRQ0FIS0FJOFFRTjBhaWtDQUNJZFFoQ0lwMEgvQVhFaEN5QUhLQUpRSUFjb0FreEJBM1JxS1FJQUloNUNFSWluUWY4QmNTRUpJQWNvQWtnZ0J5Z0NSRUVEZEdvcEFnQWlIMElnaUtjaENDQWVRaUNJSVNBZ0hVSWdpS2NoQWdKQUlCOUNFSWluUWY4QmNTSURRUUpQQkVBQ1FDQUdSU0FEUVJsSmNrVUVRQ0FJSUFkQktHb2dBMEVnSUFjb0FpeHJJZzBnRFNBRFN4c2lEUkFGSUFNZ0RXc2lBM1JxSVFnZ0IwRW9haEFFR2lBRFJRMEJJQWRCS0dvZ0F4QUZJQWhxSVFnTUFRc2dCMEVvYWlBREVBVWdDR29oQ0NBSFFTaHFFQVFhQ3lBSEtRSlVJU0VnQnlBSU5nSlVJQWNnSVRjRFdBd0JDd0pBSUFORkJFQWdBZ1JBSUFjb0FsUWhDQXdEQ3lBSEtBSllJUWdNQVFzQ1FBSkFJQWRCS0dwQkFSQUZJQWdnQWtWcWFpSURRUU5HQkVBZ0J5Z0NWRUYvYWlJRElBTkZhaUVJREFFTElBTkJBblFnQjJvb0FsUWlDQ0FJUldvaENDQURRUUZHRFFFTElBY2dCeWdDV0RZQ1hBc0xJQWNnQnlnQ1ZEWUNXQ0FISUFnMkFsUUxJQ0NuSVFNZ0NRUkFJQWRCS0dvZ0NSQUZJQU5xSVFNTElBa2dDMnBCRkU4RVFDQUhRU2hxRUFRYUN5QUxCRUFnQjBFb2FpQUxFQVVnQW1vaEFnc2dCMEVvYWhBRUdpQUhJQWNvQW1nZ0Ftb2lDU0FEYWpZQ2FDQUtJQXdnQ0NBSlN4c29BZ0FoRFNBSElBZEJLR29nSFVJWWlLZEIvd0Z4RUFnZ0hhZEIvLzhEY1dvMkFqd2dCeUFIUVNocUlCNUNHSWluUWY4QmNSQUlJQjZuUWYvL0EzRnFOZ0pNSUFkQktHb1FCQm9nQjBFb2FpQWZRaGlJcDBIL0FYRVFDQ0VPSUFkQjhBQnFJQVJCQkhScUlnc2dDU0FOYWlBSWF6WUNEQ0FMSUFnMkFnZ2dDeUFETmdJRUlBc2dBallDQUNBSElBNGdINmRCLy84RGNXbzJBa1FnQkVFQmFpRUVEQUVMQ3lBRUlCZElEUUVnRWtGZ2FpRVlJQWRCNEFCcUlSb2dCMEhrQUdvaEd5QUJJUU1EUUNBSFFTaHFFQVJCQWtzZ0JDQUZUbkpGQkVBZ0J5Z0NRQ0FIS0FJOFFRTjBhaWtDQUNJZFFoQ0lwMEgvQVhFaEN5QUhLQUpRSUFjb0FreEJBM1JxS1FJQUloNUNFSWluUWY4QmNTRUlJQWNvQWtnZ0J5Z0NSRUVEZEdvcEFnQWlIMElnaUtjaENTQWVRaUNJSVNBZ0hVSWdpS2NoREFKQUlCOUNFSWluUWY4QmNTSUNRUUpQQkVBQ1FDQUdSU0FDUVJsSmNrVUVRQ0FKSUFkQktHb2dBa0VnSUFjb0FpeHJJZ29nQ2lBQ1N4c2lDaEFGSUFJZ0Ntc2lBblJxSVFrZ0IwRW9haEFFR2lBQ1JRMEJJQWRCS0dvZ0FoQUZJQWxxSVFrTUFRc2dCMEVvYWlBQ0VBVWdDV29oQ1NBSFFTaHFFQVFhQ3lBSEtRSlVJU0VnQnlBSk5nSlVJQWNnSVRjRFdBd0JDd0pBSUFKRkJFQWdEQVJBSUFjb0FsUWhDUXdEQ3lBSEtBSllJUWtNQVFzQ1FBSkFJQWRCS0dwQkFSQUZJQWtnREVWcWFpSUNRUU5HQkVBZ0J5Z0NWRUYvYWlJQ0lBSkZhaUVKREFFTElBSkJBblFnQjJvb0FsUWlDU0FKUldvaENTQUNRUUZHRFFFTElBY2dCeWdDV0RZQ1hBc0xJQWNnQnlnQ1ZEWUNXQ0FISUFrMkFsUUxJQ0NuSVJRZ0NBUkFJQWRCS0dvZ0NCQUZJQlJxSVJRTElBZ2dDMnBCRkU4RVFDQUhRU2hxRUFRYUN5QUxCRUFnQjBFb2FpQUxFQVVnREdvaERBc2dCMEVvYWhBRUdpQUhJQWNvQW1nZ0RHb2lHU0FVYWpZQ2FDQWJJQm9nQ1NBWlN4c29BZ0FoSENBSElBZEJLR29nSFVJWWlLZEIvd0Z4RUFnZ0hhZEIvLzhEY1dvMkFqd2dCeUFIUVNocUlCNUNHSWluUWY4QmNSQUlJQjZuUWYvL0EzRnFOZ0pNSUFkQktHb1FCQm9nQnlBSFFTaHFJQjlDR0lpblFmOEJjUkFJSUIrblFmLy9BM0ZxTmdKRUlBY2dCMEh3QUdvZ0JFRURjVUVFZEdvaURTa0RDQ0lkTndQSUFTQUhJQTBwQXdBaUhqY0R3QUVDUUFKQUFrQWdCeWdDdkFFaURpQWVweUlDYWlJV0lCTkxEUUFnQXlBSEtBTEVBU0lLSUFKcUlndHFJQmhMRFFBZ0VpQURheUFMUVNCcVR3MEJDeUFISUFjcEE4Z0JOd01RSUFjZ0J5a0R3QUUzQXdnZ0F5QVNJQWRCQ0dvZ0IwRzhBV29nRXlBUElCVWdFUkFlSVFzTUFRc2dBaUFEYWlFSUlBTWdEaEFISUFKQkVVOEVRQ0FEUVJCcUlRSURRQ0FDSUE1QkVHb2lEaEFISUFKQkVHb2lBaUFJU1EwQUN3c2dDQ0FkcHlJT2F5RUNJQWNnRmpZQ3ZBRWdEaUFJSUE5clN3UkFJQTRnQ0NBVmEwc0VRRUZzSVFzTUFnc2dFU0FDSUE5cklnSnFJaFlnQ21vZ0VVMEVRQ0FJSUJZZ0NoQVBHZ3dDQ3lBSUlCWkJBQ0FDYXhBUElRZ2dCeUFDSUFwcUlnbzJBc1FCSUFnZ0Ftc2hDQ0FQSVFJTElBNUJFRThFUUNBSUlBcHFJUW9EUUNBSUlBSVFCeUFDUVJCcUlRSWdDRUVRYWlJSUlBcEpEUUFMREFFTEFrQWdEa0VIVFFSQUlBZ2dBaTBBQURvQUFDQUlJQUl0QUFFNkFBRWdDQ0FDTFFBQ09nQUNJQWdnQWkwQUF6b0FBeUFJUVFScUlBSWdEa0VDZENJS1FjQWVhaWdDQUdvaUFoQVhJQUlnQ2tIZ0htb29BZ0JySVFJZ0J5Z0N4QUVoQ2d3QkN5QUlJQUlRREFzZ0NrRUpTUTBBSUFnZ0Ntb2hDaUFJUVFocUlnZ2dBa0VJYWlJQ2EwRVBUQVJBQTBBZ0NDQUNFQXdnQWtFSWFpRUNJQWhCQ0dvaUNDQUtTUTBBREFJQUN3QUxBMEFnQ0NBQ0VBY2dBa0VRYWlFQ0lBaEJFR29pQ0NBS1NRMEFDd3NnQ3hBREJFQWdDeUVRREFRRklBMGdERFlDQUNBTklCa2dIR29nQ1dzMkFnd2dEU0FKTmdJSUlBMGdGRFlDQkNBRVFRRnFJUVFnQXlBTGFpRUREQUlMQUFzTElBUWdCVWdOQVNBRUlCZHJJUXRCQUNFRUEwQWdDeUFGU0FSQUlBY2dCMEh3QUdvZ0MwRURjVUVFZEdvaUFpa0RDQ0lkTndQSUFTQUhJQUlwQXdBaUhqY0R3QUVDUUFKQUFrQWdCeWdDdkFFaURDQWVweUlDYWlJS0lCTkxEUUFnQXlBSEtBTEVBU0lKSUFKcUloQnFJQmhMRFFBZ0VpQURheUFRUVNCcVR3MEJDeUFISUFjcEE4Z0JOd01nSUFjZ0J5a0R3QUUzQXhnZ0F5QVNJQWRCR0dvZ0IwRzhBV29nRXlBUElCVWdFUkFlSVJBTUFRc2dBaUFEYWlFSUlBTWdEQkFISUFKQkVVOEVRQ0FEUVJCcUlRSURRQ0FDSUF4QkVHb2lEQkFISUFKQkVHb2lBaUFJU1EwQUN3c2dDQ0FkcHlJR2F5RUNJQWNnQ2pZQ3ZBRWdCaUFJSUE5clN3UkFJQVlnQ0NBVmEwc0VRRUZzSVJBTUFnc2dFU0FDSUE5cklnSnFJZ3dnQ1dvZ0VVMEVRQ0FJSUF3Z0NSQVBHZ3dDQ3lBSUlBeEJBQ0FDYXhBUElRZ2dCeUFDSUFscUlnazJBc1FCSUFnZ0Ftc2hDQ0FQSVFJTElBWkJFRThFUUNBSUlBbHFJUVlEUUNBSUlBSVFCeUFDUVJCcUlRSWdDRUVRYWlJSUlBWkpEUUFMREFFTEFrQWdCa0VIVFFSQUlBZ2dBaTBBQURvQUFDQUlJQUl0QUFFNkFBRWdDQ0FDTFFBQ09nQUNJQWdnQWkwQUF6b0FBeUFJUVFScUlBSWdCa0VDZENJR1FjQWVhaWdDQUdvaUFoQVhJQUlnQmtIZ0htb29BZ0JySVFJZ0J5Z0N4QUVoQ1F3QkN5QUlJQUlRREFzZ0NVRUpTUTBBSUFnZ0NXb2hCaUFJUVFocUlnZ2dBa0VJYWlJQ2EwRVBUQVJBQTBBZ0NDQUNFQXdnQWtFSWFpRUNJQWhCQ0dvaUNDQUdTUTBBREFJQUN3QUxBMEFnQ0NBQ0VBY2dBa0VRYWlFQ0lBaEJFR29pQ0NBR1NRMEFDd3NnRUJBRERRTWdDMEVCYWlFTElBTWdFR29oQXd3QkN3c0RRQ0FFUVFOSEJFQWdBQ0FFUVFKMElnSnFRYXpRQVdvZ0FpQUhhaWdDVkRZQ0FDQUVRUUZxSVFRTUFRc0xJQWNvQXJ3QklRZ0xRYnAvSVJBZ0V5QUlheUlBSUJJZ0EydExEUUFnQXdSL0lBTWdDQ0FBRUFzZ0FHb0ZRUUFMSUFGcklSQUxJQWRCMEFGcUpBQWdFQXNsQUNBQVFnQTNBZ0FnQUVFQU93RUlJQUJCQURvQUN5QUFJQUUyQWd3Z0FDQUNPZ0FLQzdRRkFRTi9Jd0JCTUdzaUJDUUFJQUJCL3dGcUlnVkJmV29oQmdKQUlBTXZBUUlFUUNBRVFSaHFJQUVnQWhBR0lnSVFBdzBCSUFSQkVHb2dCRUVZYWlBREVCd2dCRUVJYWlBRVFSaHFJQU1RSENBQUlRTURRQUpBSUFSQkdHb1FCQ0FESUFaUGNrVUVRQ0FESUFSQkVHb2dCRUVZYWhBU09nQUFJQU1nQkVFSWFpQUVRUmhxRUJJNkFBRWdCRUVZYWhBRVJRMEJJQU5CQW1vaEF3c2dCVUYrYWlFRkFuOERRRUc2ZnlFQ0lBTWlBU0FGU3cwRklBRWdCRUVRYWlBRVFSaHFFQkk2QUFBZ0FVRUJhaUVESUFSQkdHb1FCRUVEUmdSQVFRSWhBaUFFUVFocURBSUxJQU1nQlVzTkJTQUJJQVJCQ0dvZ0JFRVlhaEFTT2dBQklBRkJBbW9oQTBFRElRSWdCRUVZYWhBRVFRTkhEUUFMSUFSQkVHb0xJUVVnQXlBRklBUkJHR29RRWpvQUFDQUJJQUpxSUFCcklRSU1Bd3NnQXlBRVFSQnFJQVJCR0dvUUVqb0FBaUFESUFSQkNHb2dCRUVZYWhBU09nQURJQU5CQkdvaEF3d0FBQXNBQ3lBRVFSaHFJQUVnQWhBR0lnSVFBdzBBSUFSQkVHb2dCRUVZYWlBREVCd2dCRUVJYWlBRVFSaHFJQU1RSENBQUlRTURRQUpBSUFSQkdHb1FCQ0FESUFaUGNrVUVRQ0FESUFSQkVHb2dCRUVZYWhBUk9nQUFJQU1nQkVFSWFpQUVRUmhxRUJFNkFBRWdCRUVZYWhBRVJRMEJJQU5CQW1vaEF3c2dCVUYrYWlFRkFuOERRRUc2ZnlFQ0lBTWlBU0FGU3cwRUlBRWdCRUVRYWlBRVFSaHFFQkU2QUFBZ0FVRUJhaUVESUFSQkdHb1FCRUVEUmdSQVFRSWhBaUFFUVFocURBSUxJQU1nQlVzTkJDQUJJQVJCQ0dvZ0JFRVlhaEFST2dBQklBRkJBbW9oQTBFRElRSWdCRUVZYWhBRVFRTkhEUUFMSUFSQkVHb0xJUVVnQXlBRklBUkJHR29RRVRvQUFDQUJJQUpxSUFCcklRSU1BZ3NnQXlBRVFSQnFJQVJCR0dvUUVUb0FBaUFESUFSQkNHb2dCRUVZYWhBUk9nQURJQU5CQkdvaEF3d0FBQXNBQ3lBRVFUQnFKQUFnQWd0cEFRRi9BbjhDUUFKQUlBSkJCMDBOQUNBQktBQUFRYmZJd3VGK1J3MEFJQUFnQVNnQUJEWUNtT0lCUVdJZ0FFRVFhaUFCSUFJUVBpSURFQU1OQWhvZ0FFS0JnSUNBRURjRGlPRUJJQUFnQVNBRGFpQUNJQU5yRUNvTUFRc2dBQ0FCSUFJUUtndEJBQXNMclFNQkJuOGpBRUdBQVdzaUF5UUFRV0loQ0FKQUlBSkJDVWtOQUNBQVFaalFBR29nQVVFSWFpSUVJQUpCZUdvZ0FFR1kwQUFRTXlJRkVBTWlCZzBBSUFOQkh6WUNmQ0FESUFOQi9BQnFJQU5CK0FCcUlBUWdCQ0FGYWlBR0d5SUVJQUVnQW1vaUFpQUVheEFWSWdVUUF3MEFJQU1vQW53aUJrRWZTdzBBSUFNb0FuZ2lCMEVKVHcwQUlBQkJpQ0JxSUFNZ0JrR0FDMEdBRENBSEVCZ2dBMEUwTmdKOElBTWdBMEg4QUdvZ0EwSDRBR29nQkNBRmFpSUVJQUlnQkdzUUZTSUZFQU1OQUNBREtBSjhJZ1pCTkVzTkFDQURLQUo0SWdkQkNrOE5BQ0FBUVpBd2FpQURJQVpCZ0ExQjRBNGdCeEFZSUFOQkl6WUNmQ0FESUFOQi9BQnFJQU5CK0FCcUlBUWdCV29pQkNBQ0lBUnJFQlVpQlJBRERRQWdBeWdDZkNJR1FTTkxEUUFnQXlnQ2VDSUhRUXBQRFFBZ0FDQURJQVpCd0JCQjBCRWdCeEFZSUFRZ0JXb2lCRUVNYWlJRklBSkxEUUFnQWlBRmF5RUZRUUFoQWdOQUlBSkJBMGNFUUNBRUtBQUFJZ1pCZjJvZ0JVOE5BaUFBSUFKQkFuUnFRWnpRQVdvZ0JqWUNBQ0FDUVFGcUlRSWdCRUVFYWlFRURBRUxDeUFFSUFGcklRZ0xJQU5CZ0FGcUpBQWdDQXRHQVFOL0lBQkJDR29oQXlBQUtBSUVJUUpCQUNFQUEwQWdBQ0FDZGtVRVFDQUJJQU1nQUVFRGRHb3RBQUpCRmt0cUlRRWdBRUVCYWlFQURBRUxDeUFCUVFnZ0FtdDBDNFlEQVFWL1FiaC9JUWNDUUNBRFJRMEFJQUl0QUFBaUJFVUVRQ0FCUVFBMkFnQkJBVUc0ZnlBRFFRRkdHdzhMQW44Z0FrRUJhaUlGSUFSQkdIUkJHSFVpQmtGL1NnMEFHaUFHUVg5R0JFQWdBMEVEU0EwQ0lBVXZBQUJCZ1A0QmFpRUVJQUpCQTJvTUFRc2dBMEVDU0EwQklBSXRBQUVnQkVFSWRISkJnSUIrYWlFRUlBSkJBbW9MSVFVZ0FTQUVOZ0lBSUFWQkFXb2lBU0FDSUFOcUlnTkxEUUJCYkNFSElBQkJFR29nQUNBRkxRQUFJZ1ZCQm5aQkkwRUpJQUVnQXlBQmEwSEFFRUhRRVVId0VpQUFLQUtNNFFFZ0FDZ0NuT0lCSUFRUUh5SUdFQU1pQ0EwQUlBQkJtQ0JxSUFCQkNHb2dCVUVFZGtFRGNVRWZRUWdnQVNBQklBWnFJQWdiSWdFZ0F5QUJhMEdBQzBHQURFR0FGeUFBS0FLTTRRRWdBQ2dDbk9JQklBUVFIeUlHRUFNaUNBMEFJQUJCb0RCcUlBQkJCR29nQlVFQ2RrRURjVUUwUVFrZ0FTQUJJQVpxSUFnYklnRWdBeUFCYTBHQURVSGdEa0dRR1NBQUtBS000UUVnQUNnQ25PSUJJQVFRSHlJQUVBTU5BQ0FBSUFGcUlBSnJJUWNMSUFjTHJRTUJDbjhqQUVHQUJHc2lDQ1FBQW45QlVpQUNRZjhCU3cwQUdrRlVJQU5CREVzTkFCb2dBa0VCYWlFTElBQkJCR29oQ1VHQWdBUWdBMEYvYW5SQkVIVWhDa0VBSVFKQkFTRUVRUUVnQTNRaUIwRi9haUlNSVFVRFFDQUNJQXRHUlFSQUFrQWdBU0FDUVFGMElnMXFMd0VBSWdaQi8vOERSZ1JBSUFrZ0JVRUNkR29nQWpvQUFpQUZRWDlxSVFWQkFTRUdEQUVMSUFSQkFDQUtJQVpCRUhSQkVIVktHeUVFQ3lBSUlBMXFJQVk3QVFBZ0FrRUJhaUVDREFFTEN5QUFJQVE3QVFJZ0FDQURPd0VBSUFkQkEzWWdCMEVCZG1wQkEyb2hCa0VBSVFSQkFDRUNBMEFnQkNBTFJrVUVRQ0FCSUFSQkFYUnFMZ0VBSVFwQkFDRUFBMEFnQUNBS1RrVUVRQ0FKSUFKQkFuUnFJQVE2QUFJRFFDQUNJQVpxSUF4eElnSWdCVXNOQUFzZ0FFRUJhaUVBREFFTEN5QUVRUUZxSVFRTUFRc0xRWDhnQWcwQUdrRUFJUUlEZnlBQ0lBZEdCSDlCQUFVZ0NDQUpJQUpCQW5ScUlnQXRBQUpCQVhScUlnRWdBUzhCQUNJQlFRRnFPd0VBSUFBZ0F5QUJFQlJySWdVNkFBTWdBQ0FCSUFWQi93RnhkQ0FIYXpzQkFDQUNRUUZxSVFJTUFRc0xDeUVGSUFoQmdBUnFKQUFnQlF2akJnRUlmMEZzSVFjQ1FDQUNRUU5KRFFBQ1FBSkFBa0FDUUNBQkxRQUFJZ05CQTNFaUNVRUJhdzREQXdFQUFnc2dBQ2dDaU9FQkRRQkJZZzhMSUFKQkJVa05Ba0VESVFZZ0FTZ0FBQ0VGQW44Q1FBSkFJQU5CQW5aQkEzRWlDRUYrYWlJRVFRRk5CRUFnQkVFQmF3MEJEQUlMSUFWQkRuWkIvd2R4SVFRZ0JVRUVka0gvQjNFaEF5QUlSUXdDQ3lBRlFSSjJJUVJCQkNFR0lBVkJCSFpCLy84QWNTRURRUUFNQVFzZ0JVRUVka0gvL3c5eElnTkJnSUFJU3cwRElBRXRBQVJCQ25RZ0JVRVdkbkloQkVFRklRWkJBQXNoQlNBRUlBWnFJZ29nQWtzTkFnSkFJQU5CZ1FaSkRRQWdBQ2dDbk9JQlJRMEFRUUFoQWdOQUlBSkJnNEFCU3cwQklBSkJRR3NoQWd3QUFBc0FDd0ovSUFsQkEwWUVRQ0FCSUFacUlRRWdBRUh3NGdGcUlRSWdBQ2dDRENFR0lBVUVRQ0FDSUFNZ0FTQUVJQVlRWHd3Q0N5QUNJQU1nQVNBRUlBWVFYUXdCQ3lBQVFialFBV29oQWlBQklBWnFJUUVnQUVIdzRnRnFJUVlnQUVHbzBBQnFJUWdnQlFSQUlBZ2dCaUFESUFFZ0JDQUNFRjRNQVFzZ0NDQUdJQU1nQVNBRUlBSVFYQXNRQXcwQ0lBQWdBellDZ09JQklBQkJBVFlDaU9FQklBQWdBRUh3NGdGcU5nTHc0UUVnQ1VFQ1JnUkFJQUFnQUVHbzBBQnFOZ0lNQ3lBQUlBTnFJZ0JCaU9NQmFrSUFOd0FBSUFCQmdPTUJha0lBTndBQUlBQkIrT0lCYWtJQU53QUFJQUJCOE9JQmFrSUFOd0FBSUFvUEN3Si9Ba0FDUUFKQUlBTkJBblpCQTNGQmYyb2lCRUVDU3cwQUlBUkJBV3NPQWdBQ0FRdEJBU0VFSUFOQkEzWU1BZ3RCQWlFRUlBRXZBQUJCQkhZTUFRdEJBeUVFSUFFUUlVRUVkZ3NpQXlBRWFpSUZRU0JxSUFKTEJFQWdCU0FDU3cwQ0lBQkI4T0lCYWlBQklBUnFJQU1RQ3lFQklBQWdBellDZ09JQklBQWdBVFlDOE9FQklBRWdBMm9pQUVJQU53QVlJQUJDQURjQUVDQUFRZ0EzQUFnZ0FFSUFOd0FBSUFVUEN5QUFJQU0yQW9EaUFTQUFJQUVnQkdvMkF2RGhBU0FGRHdzQ2Z3SkFBa0FDUUNBRFFRSjJRUU54UVg5cUlnUkJBa3NOQUNBRVFRRnJEZ0lBQWdFTFFRRWhCeUFEUVFOMkRBSUxRUUloQnlBQkx3QUFRUVIyREFFTElBSkJCRWtnQVJBaElnSkJqNENBQVV0eURRRkJBeUVISUFKQkJIWUxJUUlnQUVIdzRnRnFJQUVnQjJvdEFBQWdBa0VnYWhBUUlRRWdBQ0FDTmdLQTRnRWdBQ0FCTmdMdzRRRWdCMEVCYWlFSEN5QUhDMHNBSUFCQytlclEwT2ZKb2VUaEFEY0RJQ0FBUWdBM0F4Z2dBRUxQMXRPKzBzZXIyVUkzQXhBZ0FFTFc2NEx1NnYySjllQUFOd01JSUFCQ0FEY0RBQ0FBUVNocVFRQkJLQkFRR2d2aUFnSUNmd1YrSUFCQktHb2lBU0FBS0FKSWFpRUNBbjRnQUNrREFDSURRaUJhQkVBZ0FDa0RFQ0lFUWdlSklBQXBBd2dpQlVJQmlYd2dBQ2tER0NJR1FneUpmQ0FBS1FNZ0lnZENFb2w4SUFVUUdTQUVFQmtnQmhBWklBY1FHUXdCQ3lBQUtRTVlRc1hQMmJMeDVicnFKM3dMSUFOOElRTURRQ0FCUVFocUlnQWdBazBFUUVJQUlBRXBBQUFRQ1NBRGhVSWJpVUtIbGErdm1MYmVtNTUvZmtMajNNcVYvTTd5OVlWL2ZDRURJQUFoQVF3QkN3c0NRQ0FCUVFScUlnQWdBa3NFUUNBQklRQU1BUXNnQVNnQUFLMUNoNVd2cjVpMjNwdWVmMzRnQTRWQ0Y0bEN6OWJUdnRMSHE5bENma0w1ODkzeG1mYVpxeFo4SVFNTEEwQWdBQ0FDU1FSQUlBQXhBQUJDeGMvWnN2SGx1dW9uZmlBRGhVSUxpVUtIbGErdm1MYmVtNTUvZmlFRElBQkJBV29oQUF3QkN3c2dBMEloaUNBRGhVTFAxdE8rMHNlcjJVSitJZ05DSFlnZ0E0VkMrZlBkOFpuMm1hc1dmaUlEUWlDSUlBT0ZDKzhDQWdKL0JINGdBQ0FBS1FNQUlBS3RmRGNEQUFKQUFrQWdBQ2dDU0NJRElBSnFJZ1JCSDAwRVFDQUJSUTBCSUFBZ0EycEJLR29nQVNBQ0VDQWdBQ2dDU0NBQ2FpRUVEQUVMSUFFZ0Ftb2hBZ0ovSUFNRVFDQUFRU2hxSWdRZ0Eyb2dBVUVnSUFOckVDQWdBQ0FBS1FNSUlBUXBBQUFRQ1RjRENDQUFJQUFwQXhBZ0FDa0FNQkFKTndNUUlBQWdBQ2tER0NBQUtRQTRFQWszQXhnZ0FDQUFLUU1nSUFCQlFHc3BBQUFRQ1RjRElDQUFLQUpJSVFNZ0FFRUFOZ0pJSUFFZ0EydEJJR29oQVFzZ0FVRWdhaUFDVFFzRVFDQUNRV0JxSVFNZ0FDa0RJQ0VGSUFBcEF4Z2hCaUFBS1FNUUlRY2dBQ2tEQ0NFSUEwQWdDQ0FCS1FBQUVBa2hDQ0FISUFFcEFBZ1FDU0VISUFZZ0FTa0FFQkFKSVFZZ0JTQUJLUUFZRUFraEJTQUJRU0JxSWdFZ0EwME5BQXNnQUNBRk53TWdJQUFnQmpjREdDQUFJQWMzQXhBZ0FDQUlOd01JQ3lBQklBSlBEUUVnQUVFb2FpQUJJQUlnQVdzaUJCQWdDeUFBSUFRMkFrZ0xDeThCQVg4Z0FFVUVRRUcyZjBFQUlBTWJEd3RCdW44aEJDQURJQUZOQkg4Z0FDQUNJQU1RRUJvZ0F3VkJ1bjhMQ3k4QkFYOGdBRVVFUUVHMmYwRUFJQU1iRHd0QnVuOGhCQ0FESUFGTkJIOGdBQ0FDSUFNUUN4b2dBd1ZCdW44TEM2Z0NBUVovSXdCQkVHc2lCeVFBSUFCQjJPQUJhaWtEQUVLQWdJQVFWaUVJUWJoL0lRVUNRQ0FFUWYvL0Iwc05BQ0FBSUFNZ0JCQkNJZ1VRQXlJR0RRQWdBQ2dDbk9JQklRa2dBQ0FIUVF4cUlBTWdBeUFGYWlBR0d5SUtJQVJCQUNBRklBWWJheUlHRUVBaUF4QURCRUFnQXlFRkRBRUxJQWNvQWd3aEJDQUJSUVJBUWJwL0lRVWdCRUVBU2cwQkN5QUdJQU5ySVFVZ0F5QUthaUVEQWtBZ0NRUkFJQUJCQURZQ25PSUJEQUVMQWtBQ1FBSkFJQVJCQlVnTkFDQUFRZGpnQVdvcEF3QkNnSUNBQ0ZnTkFBd0JDeUFBUVFBMkFwemlBUXdCQ3lBQUtBSUlFRDhoQmlBQVFRQTJBcHppQVNBR1FSUlBEUUVMSUFBZ0FTQUNJQU1nQlNBRUlBZ1FPU0VGREFFTElBQWdBU0FDSUFNZ0JTQUVJQWdRT2lFRkN5QUhRUkJxSkFBZ0JRdG5BQ0FBUWREZ0FXb2dBU0FDSUFBb0F1emhBUkF1SWdFUUF3UkFJQUVQQzBHNGZ5RUNBa0FnQVEwQUlBQkI3T0FCYWlnQ0FDSUJCRUJCWUNFQ0lBQW9BcGppQVNBQlJ3MEJDMEVBSVFJZ0FFSHc0QUZxS0FJQVJRMEFJQUJCa09FQmFoQkRDeUFDQ3ljQkFYOFFWeUlFUlFSQVFVQVBDeUFFSUFBZ0FTQUNJQU1nQkJCTEVFOGhBQ0FFRUZZZ0FBcy9BUUYvQWtBQ1FBSkFJQUFvQXFEaUFVRUJhaUlCUVFKTERRQWdBVUVCYXc0Q0FBRUNDeUFBRURCQkFBOExJQUJCQURZQ29PSUJDeUFBS0FLVTRnRUx2QU1DQjM4QmZpTUFRUkJySWdra0FFRzRmeUVHQWtBZ0JDZ0NBQ0lJUVFWQkNTQUFLQUxzNFFFaUJSdEpEUUFnQXlnQ0FDSUhRUUZCQlNBRkd5QUZFQzhpQlJBREJFQWdCU0VHREFFTElBZ2dCVUVEYWtrTkFDQUFJQWNnQlJCSklnWVFBdzBBSUFFZ0Ftb2hDaUFBUVpEaEFXb2hDeUFJSUFWcklRSWdCU0FIYWlFSElBRWhCUU5BSUFjZ0FpQUpFQ3dpQmhBRERRRWdBa0Y5YWlJQ0lBWkpCRUJCdUg4aEJnd0NDeUFKS0FJQUlnaEJBa3NFUUVGc0lRWU1BZ3NnQjBFRGFpRUhBbjhDUUFKQUFrQWdDRUVCYXc0Q0FnQUJDeUFBSUFVZ0NpQUZheUFISUFZUVNBd0NDeUFGSUFvZ0JXc2dCeUFHRUVjTUFRc2dCU0FLSUFWcklBY3RBQUFnQ1NnQ0NCQkdDeUlJRUFNRVFDQUlJUVlNQWdzZ0FDZ0M4T0FCQkVBZ0N5QUZJQWdRUlFzZ0FpQUdheUVDSUFZZ0Iyb2hCeUFGSUFocUlRVWdDU2dDQkVVTkFBc2dBQ2tEME9BQklneENmMUlFUUVGc0lRWWdEQ0FGSUFGcnJGSU5BUXNnQUNnQzhPQUJCRUJCYWlFR0lBSkJCRWtOQVNBTEVFUWhEQ0FIS0FBQUlBeW5SdzBCSUFkQkJHb2hCeUFDUVh4cUlRSUxJQU1nQnpZQ0FDQUVJQUkyQWdBZ0JTQUJheUVHQ3lBSlFSQnFKQUFnQmdzdUFDQUFFQ3NDZjBFQVFRQVFBdzBBR2lBQlJTQUNSWEpGQkVCQllpQUFJQUVnQWhBOUVBTU5BUm9MUVFBTEN6Y0FJQUVFUUNBQUlBQW9Bc1RnQVNBQktBSUVJQUVvQWdocVJ6WUNuT0lCQ3lBQUVDdEJBQkFESUFGRmNrVUVRQ0FBSUFFUVd3c0wwUUlCQjM4akFFRVFheUlHSkFBZ0JpQUVOZ0lJSUFZZ0F6WUNEQ0FGQkVBZ0JTZ0NCQ0VLSUFVb0FnZ2hDUXNnQVNFSUFrQUNRQU5BSUFBb0F1emhBUkFXSVFzQ1FBTkFJQVFnQzBrTkFTQURLQUFBUVhCeFFkRFV0TUlCUmdSQUlBTWdCQkFpSWdjUUF3MEVJQVFnQjJzaEJDQURJQWRxSVFNTUFRc0xJQVlnQXpZQ0RDQUdJQVEyQWdnQ1FDQUZCRUFnQUNBRkVFNUJBQ0VIUVFBUUEwVU5BUXdGQ3lBQUlBb2dDUkJOSWdjUUF3MEVDeUFBSUFnUVVDQU1RUUZIUVFBZ0FDQUlJQUlnQmtFTWFpQUdRUWhxRUV3aUJ5SURhMEVBSUFNUUF4dEJDa2R5UlFSQVFiaC9JUWNNQkFzZ0J4QUREUU1nQWlBSGF5RUNJQWNnQ0dvaENFRUJJUXdnQmlnQ0RDRURJQVlvQWdnaEJBd0JDd3NnQmlBRE5nSU1JQVlnQkRZQ0NFRzRmeUVISUFRTkFTQUlJQUZySVFjTUFRc2dCaUFETmdJTUlBWWdCRFlDQ0FzZ0JrRVFhaVFBSUFjTFJnRUNmeUFCSUFBb0FyamdBU0lDUndSQUlBQWdBallDeE9BQklBQWdBVFlDdU9BQklBQW9BcnpnQVNFRElBQWdBVFlDdk9BQklBQWdBU0FESUFKcmFqWUN3T0FCQ3d1dEFnSUVmd0YrSXdCQlFHb2lCQ1FBQWtBQ1FDQUNRUWhKRFFBZ0FTZ0FBRUZ3Y1VIUTFMVENBVWNOQUNBQklBSVFJaUVCSUFCQ0FEY0RDQ0FBUVFBMkFnUWdBQ0FCTmdJQURBRUxJQVJCR0dvZ0FTQUNFQzBpQXhBREJFQWdBQ0FERUJvTUFRc2dBd1JBSUFCQnVIOFFHZ3dCQ3lBQ0lBUW9BakFpQTJzaEFpQUJJQU5xSVFNRFFBSkFJQUFnQXlBQ0lBUkJDR29RTENJRkVBTUVmeUFGQlNBQ0lBVkJBMm9pQlU4TkFVRzRmd3NRR2d3Q0N5QUdRUUZxSVFZZ0FpQUZheUVDSUFNZ0JXb2hBeUFFS0FJTVJRMEFDeUFFS0FJNEJFQWdBa0VEVFFSQUlBQkJ1SDhRR2d3Q0N5QURRUVJxSVFNTElBUW9BaWdoQWlBRUtRTVlJUWNnQUVFQU5nSUVJQUFnQXlBQmF6WUNBQ0FBSUFJZ0JteXRJQWNnQjBKL1VSczNBd2dMSUFSQlFHc2tBQXNsQVFGL0l3QkJFR3NpQWlRQUlBSWdBQ0FCRUZFZ0FpZ0NBQ0VBSUFKQkVHb2tBQ0FBQzMwQkJIOGpBRUdRQkdzaUJDUUFJQVJCL3dFMkFnZ0NRQ0FFUVJCcUlBUkJDR29nQkVFTWFpQUJJQUlRRlNJR0VBTUVRQ0FHSVFVTUFRdEJWQ0VGSUFRb0Fnd2lCMEVHU3cwQUlBTWdCRUVRYWlBRUtBSUlJQWNRUVNJRkVBTU5BQ0FBSUFFZ0Jtb2dBaUFHYXlBREVEd2hCUXNnQkVHUUJHb2tBQ0FGQzRjQkFnSi9BbjVCQUJBV0lRTUNRQU5BSUFFZ0EwOEVRQUpBSUFBb0FBQkJjSEZCME5TMHdnRkdCRUFnQUNBQkVDSWlBaEFEUlEwQlFuNFBDeUFBSUFFUVZTSUVRbjFXRFFNZ0JDQUZmQ0lGSUFSVUlRSkNmaUVFSUFJTkF5QUFJQUVRVWlJQ0VBTU5Bd3NnQVNBQ2F5RUJJQUFnQW1vaEFBd0JDd3RDZmlBRklBRWJJUVFMSUFRTFB3SUJmd0YrSXdCQk1Hc2lBaVFBQW41Q2ZpQUNRUWhxSUFBZ0FSQXREUUFhUWdBZ0FpZ0NIRUVCUmcwQUdpQUNLUU1JQ3lFRElBSkJNR29rQUNBREM0MEJBUUovSXdCQk1Hc2lBU1FBQWtBZ0FFVU5BQ0FBS0FLSTRnRU5BQ0FCSUFCQi9PRUJhaWdDQURZQ0tDQUJJQUFwQXZUaEFUY0RJQ0FBRURBZ0FDZ0NxT0lCSVFJZ0FTQUJLQUlvTmdJWUlBRWdBU2tESURjREVDQUNJQUZCRUdvUUd5QUFRUUEyQXFqaUFTQUJJQUVvQWlnMkFnZ2dBU0FCS1FNZ053TUFJQUFnQVJBYkN5QUJRVEJxSkFBTEtnRUNmeU1BUVJCcklnQWtBQ0FBUVFBMkFnZ2dBRUlBTndNQUlBQVFXQ0VCSUFCQkVHb2tBQ0FCQzRjQkFRTi9Jd0JCRUdzaUFpUUFBa0FnQUNnQ0FFVWdBQ2dDQkVWekRRQWdBaUFBS0FJSU5nSUlJQUlnQUNrQ0FEY0RBQUovSUFJb0FnQWlBUVJBSUFJb0FnaEJxT01KSUFFUkJRQU1BUXRCcU9NSkVDZ0xJZ0ZGRFFBZ0FTQUFLUUlBTndMMDRRRWdBVUg4NFFGcUlBQW9BZ2cyQWdBZ0FSQlpJQUVoQXdzZ0FrRVFhaVFBSUFNTHl3RUJBbjhqQUVFZ2F5SUJKQUFnQUVHQmdJREFBRFlDdE9JQklBQkJBRFlDaU9JQklBQkJBRFlDN09FQklBQkNBRGNEa09JQklBQkJBRFlDcE9NSklBQkJBRFlDM09JQklBQkNBRGNDek9JQklBQkJBRFlDdk9JQklBQkJBRFlDeE9BQklBQkNBRGNDbk9JQklBQkJwT0lCYWtJQU53SUFJQUJCck9JQmFrRUFOZ0lBSUFGQ0FEY0NFQ0FCUWdBM0FoZ2dBU0FCS1FNWU53TUlJQUVnQVNrREVEY0RBQ0FCS0FJSVFRaDJRUUZ4SVFJZ0FFRUFOZ0xnNGdFZ0FDQUNOZ0tNNGdFZ0FVRWdhaVFBQzNZQkEzOGpBRUV3YXlJQkpBQWdBQVJBSUFFZ0FFSEUwQUZxSWdJb0FnQTJBaWdnQVNBQUtRSzgwQUUzQXlBZ0FDZ0NBQ0VESUFFZ0FpZ0NBRFlDR0NBQklBQXBBcnpRQVRjREVDQURJQUZCRUdvUUd5QUJJQUVvQWlnMkFnZ2dBU0FCS1FNZ053TUFJQUFnQVJBYkN5QUJRVEJxSkFBTHpBRUJBWDhnQUNBQktBSzAwQUUyQXBqaUFTQUFJQUVvQWdRaUFqWUN3T0FCSUFBZ0FqWUN2T0FCSUFBZ0FpQUJLQUlJYWlJQ05nSzQ0QUVnQUNBQ05nTEU0QUVnQVNnQ3VOQUJCRUFnQUVLQmdJQ0FFRGNEaU9FQklBQWdBVUdrMEFCcU5nSU1JQUFnQVVHVUlHbzJBZ2dnQUNBQlFad3dhallDQkNBQUlBRkJER28yQWdBZ0FFR3MwQUZxSUFGQnFOQUJhaWdDQURZQ0FDQUFRYkRRQVdvZ0FVR3MwQUZxS0FJQU5nSUFJQUJCdE5BQmFpQUJRYkRRQVdvb0FnQTJBZ0FQQ3lBQVFnQTNBNGpoQVFzN0FDQUNSUVJBUWJwL0R3c2dCRVVFUUVGc0R3c2dBaUFFRUdBRVFDQUFJQUVnQWlBRElBUWdCUkJoRHdzZ0FDQUJJQUlnQXlBRUlBVVFaUXRHQVFGL0l3QkJFR3NpQlNRQUlBVkJDR29nQkJBT0FuOGdCUzBBQ1FSQUlBQWdBU0FDSUFNZ0JCQXlEQUVMSUFBZ0FTQUNJQU1nQkJBMEN5RUFJQVZCRUdva0FDQUFDelFBSUFBZ0F5QUVJQVVRTmlJRkVBTUVRQ0FGRHdzZ0JTQUVTUVIvSUFFZ0FpQURJQVZxSUFRZ0JXc2dBQkExQlVHNGZ3c0xSZ0VCZnlNQVFSQnJJZ1VrQUNBRlFRaHFJQVFRRGdKL0lBVXRBQWtFUUNBQUlBRWdBaUFESUFRUVlnd0JDeUFBSUFFZ0FpQURJQVFRTlFzaEFDQUZRUkJxSkFBZ0FBdFpBUUYvUVE4aEFpQUJJQUJKQkVBZ0FVRUVkQ0FBYmlFQ0N5QUFRUWgySWdFZ0FrRVliQ0lBUVl3SWFpZ0NBR3dnQUVHSUNHb29BZ0JxSWdKQkEzWWdBbW9nQUVHQUNHb29BZ0FnQUVHRUNHb29BZ0FnQVd4cVNRczNBQ0FBSUFNZ0JDQUZRWUFRRURNaUJSQURCRUFnQlE4TElBVWdCRWtFZnlBQklBSWdBeUFGYWlBRUlBVnJJQUFRTWdWQnVIOExDNzhEQVFOL0l3QkJJR3NpQlNRQUlBVkJDR29nQWlBREVBWWlBaEFEUlFSQUlBQWdBV29pQjBGOWFpRUdJQVVnQkJBT0lBUkJCR29oQWlBRkxRQUNJUU1EUUVFQUlBQWdCa2tnQlVFSWFoQUVHd1JBSUFBZ0FpQUZRUWhxSUFNUUFrRUNkR29pQkM4QkFEc0FBQ0FGUVFocUlBUXRBQUlRQVNBQUlBUXRBQU5xSWdRZ0FpQUZRUWhxSUFNUUFrRUNkR29pQUM4QkFEc0FBQ0FGUVFocUlBQXRBQUlRQVNBRUlBQXRBQU5xSVFBTUFRVWdCMEYrYWlFRUEwQWdCVUVJYWhBRUlBQWdCRXR5UlFSQUlBQWdBaUFGUVFocUlBTVFBa0VDZEdvaUJpOEJBRHNBQUNBRlFRaHFJQVl0QUFJUUFTQUFJQVl0QUFOcUlRQU1BUXNMQTBBZ0FDQUVTMFVFUUNBQUlBSWdCVUVJYWlBREVBSkJBblJxSWdZdkFRQTdBQUFnQlVFSWFpQUdMUUFDRUFFZ0FDQUdMUUFEYWlFQURBRUxDd0pBSUFBZ0IwOE5BQ0FBSUFJZ0JVRUlhaUFERUFJaUEwRUNkR29pQUMwQUFEb0FBQ0FBTFFBRFFRRkdCRUFnQlVFSWFpQUFMUUFDRUFFTUFRc2dCU2dDREVFZlN3MEFJQVZCQ0dvZ0FpQURRUUowYWkwQUFoQUJJQVVvQWd4QklVa05BQ0FGUVNBMkFnd0xJQUZCYkNBRlFRaHFFQW9iSVFJTEN3c2dCVUVnYWlRQUlBSUxrZ0lCQkg4akFFRkFhaUlKSkFBZ0NTQURRVFFRQ3lFREFrQWdCRUVDU0EwQUlBTWdCRUVDZEdvb0FnQWhDU0FEUVR4cUlBZ1FJeUFEUVFFNkFEOGdBeUFDT2dBK1FRQWhCQ0FES0FJOElRb0RRQ0FFSUFsR0RRRWdBQ0FFUVFKMGFpQUtOZ0VBSUFSQkFXb2hCQXdBQUFzQUMwRUFJUWtEUUNBR0lBbEdSUVJBSUFNZ0JTQUpRUUYwYWlJS0xRQUJJZ3RCQW5ScUlnd29BZ0FoQkNBRFFUeHFJQW90QUFCQkNIUWdDR3BCLy84RGNSQWpJQU5CQWpvQVB5QURJQWNnQzJzaUNpQUNham9BUGlBRVFRRWdBU0FLYTNScUlRb2dBeWdDUENFTEEwQWdBQ0FFUVFKMGFpQUxOZ0VBSUFSQkFXb2lCQ0FLU1EwQUN5QU1JQW8yQWdBZ0NVRUJhaUVKREFFTEN5QURRVUJySkFBTG93SUJDWDhqQUVIUUFHc2lDU1FBSUFsQkVHb2dCVUUwRUFzYUlBY2dCbXNoRHlBSElBRnJJUkFEUUFKQUlBTWdDa2NFUUVFQklBRWdCeUFDSUFwQkFYUnFJZ1l0QUFFaURHc2lDR3NpQzNRaERTQUdMUUFBSVE0Z0NVRVFhaUFNUVFKMGFpSU1LQUlBSVFZZ0N5QVBUd1JBSUFBZ0JrRUNkR29nQ3lBSUlBVWdDRUUwYkdvZ0NDQVFhaUlJUVFFZ0NFRUJTaHNpQ0NBQ0lBUWdDRUVDZEdvb0FnQWlDRUVCZEdvZ0F5QUlheUFISUE0UVl5QUdJQTFxSVFnTUFnc2dDVUVNYWlBT0VDTWdDVUVCT2dBUElBa2dDRG9BRGlBR0lBMXFJUWdnQ1NnQ0RDRUxBMEFnQmlBSVR3MENJQUFnQmtFQ2RHb2dDellCQUNBR1FRRnFJUVlNQUFBTEFBc2dDVUhRQUdva0FBOExJQXdnQ0RZQ0FDQUtRUUZxSVFvTUFBQUxBQXMwQUNBQUlBTWdCQ0FGRURZaUJSQURCRUFnQlE4TElBVWdCRWtFZnlBQklBSWdBeUFGYWlBRUlBVnJJQUFRTkFWQnVIOExDeU1BSUFBL0FFRVFkR3RCLy84RGFrRVFka0FBUVg5R0JFQkJBQThMUVFBUUFFRUJDenNCQVg4Z0FnUkFBMEFnQUNBQklBSkJnQ0FnQWtHQUlFa2JJZ01RQ3lFQUlBRkJnQ0JxSVFFZ0FFR0FJR29oQUNBQ0lBTnJJZ0lOQUFzTEN3WUFJQUFRQXdzTHFCVUpBRUdJQ0FzTkFRQUFBQUVBQUFBQ0FBQUFBZ0JCb0FnTHN3WUJBQUFBQVFBQUFBSUFBQUFDQUFBQUpnQUFBSUlBQUFBaEJRQUFTZ0FBQUdjSUFBQW1BQUFBd0FFQUFJQUFBQUJKQlFBQVNnQUFBTDRJQUFBcEFBQUFMQUlBQUlBQUFBQkpCUUFBU2dBQUFMNElBQUF2QUFBQXlnSUFBSUFBQUFDS0JRQUFTZ0FBQUlRSkFBQTFBQUFBY3dNQUFJQUFBQUNkQlFBQVNnQUFBS0FKQUFBOUFBQUFnUU1BQUlBQUFBRHJCUUFBU3dBQUFENEtBQUJFQUFBQW5nTUFBSUFBQUFCTkJnQUFTd0FBQUtvS0FBQkxBQUFBc3dNQUFJQUFBQURCQmdBQVRRQUFBQjhOQUFCTkFBQUFVd1FBQUlBQUFBQWpDQUFBVVFBQUFLWVBBQUJVQUFBQW1RUUFBSUFBQUFCTENRQUFWd0FBQUxFU0FBQllBQUFBMmdRQUFJQUFBQUJ2Q1FBQVhRQUFBQ01VQUFCVUFBQUFSUVVBQUlBQUFBQlVDZ0FBYWdBQUFJd1VBQUJxQUFBQXJ3VUFBSUFBQUFCMkNRQUFmQUFBQUU0UUFBQjhBQUFBMGdJQUFJQUFBQUJqQndBQWtRQUFBSkFIQUFDU0FBQUFBQUFBQUFFQUFBQUJBQUFBQlFBQUFBMEFBQUFkQUFBQVBRQUFBSDBBQUFEOUFBQUEvUUVBQVAwREFBRDlCd0FBL1E4QUFQMGZBQUQ5UHdBQS9YOEFBUDMvQUFEOS93RUEvZjhEQVAzL0J3RDkvdzhBL2Y4ZkFQMy9Qd0Q5LzM4QS9mLy9BUDMvL3dIOS8vOEQvZi8vQi8zLy93LzkvLzhmL2YvL1AvMy8vMzhBQUFBQUFRQUFBQUlBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTUFBQUFEUUFBQUE0QUFBQVBBQUFBRUFBQUFCRUFBQUFTQUFBQUV3QUFBQlFBQUFBVkFBQUFGZ0FBQUJjQUFBQVlBQUFBR1FBQUFCb0FBQUFiQUFBQUhBQUFBQjBBQUFBZUFBQUFId0FBQUFNQUFBQUVBQUFBQlFBQUFBWUFBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUFBQUVRQUFBQklBQUFBVEFBQUFGQUFBQUJVQUFBQVdBQUFBRndBQUFCZ0FBQUFaQUFBQUdnQUFBQnNBQUFBY0FBQUFIUUFBQUI0QUFBQWZBQUFBSUFBQUFDRUFBQUFpQUFBQUl3QUFBQ1VBQUFBbkFBQUFLUUFBQUNzQUFBQXZBQUFBTXdBQUFEc0FBQUJEQUFBQVV3QUFBR01BQUFDREFBQUFBd0VBQUFNQ0FBQURCQUFBQXdnQUFBTVFBQUFESUFBQUEwQUFBQU9BQUFBREFBRUFRZUFQQzFFQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFEQUFBQUF3QUFBQVFBQUFBRUFBQUFCUUFBQUFjQUFBQUlBQUFBQ1FBQUFBb0FBQUFMQUFBQURBQUFBQTBBQUFBT0FBQUFEd0FBQUJBQVFjUVFDNHNCQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFBQUFFQUFBQUJJQUFBQVVBQUFBRmdBQUFCZ0FBQUFjQUFBQUlBQUFBQ2dBQUFBd0FBQUFRQUFBQUlBQUFBQUFBUUFBQUFJQUFBQUVBQUFBQ0FBQUFCQUFBQUFnQUFBQVFBQUFBSUFBQUFBQUFRQkJrQklMNWdRQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFEQUFBQUF3QUFBQVFBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFBQUFFQUFBQUFFQUFBQUVBQUFBQ0FBQUFBQUFBQUFCQUFFQkJnQUFBQUFBQUFRQUFBQUFFQUFBQkFBQUFBQWdBQUFGQVFBQUFBQUFBQVVEQUFBQUFBQUFCUVFBQUFBQUFBQUZCZ0FBQUFBQUFBVUhBQUFBQUFBQUJRa0FBQUFBQUFBRkNnQUFBQUFBQUFVTUFBQUFBQUFBQmc0QUFBQUFBQUVGRUFBQUFBQUFBUVVVQUFBQUFBQUJCUllBQUFBQUFBSUZIQUFBQUFBQUF3VWdBQUFBQUFBRUJUQUFBQUFnQUFZRlFBQUFBQUFBQndXQUFBQUFBQUFJQmdBQkFBQUFBQW9HQUFRQUFBQUFEQVlBRUFBQUlBQUFCQUFBQUFBQUFBQUVBUUFBQUFBQUFBVUNBQUFBSUFBQUJRUUFBQUFBQUFBRkJRQUFBQ0FBQUFVSEFBQUFBQUFBQlFnQUFBQWdBQUFGQ2dBQUFBQUFBQVVMQUFBQUFBQUFCZzBBQUFBZ0FBRUZFQUFBQUFBQUFRVVNBQUFBSUFBQkJSWUFBQUFBQUFJRkdBQUFBQ0FBQXdVZ0FBQUFBQUFEQlNnQUFBQUFBQVlFUUFBQUFCQUFCZ1JBQUFBQUlBQUhCWUFBQUFBQUFBa0dBQUlBQUFBQUN3WUFDQUFBTUFBQUJBQUFBQUFRQUFBRUFRQUFBQ0FBQUFVQ0FBQUFJQUFBQlFNQUFBQWdBQUFGQlFBQUFDQUFBQVVHQUFBQUlBQUFCUWdBQUFBZ0FBQUZDUUFBQUNBQUFBVUxBQUFBSUFBQUJRd0FBQUFBQUFBR0R3QUFBQ0FBQVFVU0FBQUFJQUFCQlJRQUFBQWdBQUlGR0FBQUFDQUFBZ1VjQUFBQUlBQURCU2dBQUFBZ0FBUUZNQUFBQUFBQUVBWUFBQUVBQUFBUEJnQ0FBQUFBQUE0R0FFQUFBQUFBRFFZQUlBQkJnQmNMaHdJQkFBRUJCUUFBQUFBQUFBVUFBQUFBQUFBR0JEMEFBQUFBQUFrRi9RRUFBQUFBRHdYOWZ3QUFBQUFWQmYzL0h3QUFBQU1GQlFBQUFBQUFCd1I5QUFBQUFBQU1CZjBQQUFBQUFCSUYvZjhEQUFBQUZ3WDkvMzhBQUFBRkJSMEFBQUFBQUFnRS9RQUFBQUFBRGdYOVB3QUFBQUFVQmYzL0R3QUFBQUlGQVFBQUFCQUFCd1I5QUFBQUFBQUxCZjBIQUFBQUFCRUYvZjhCQUFBQUZnWDkvejhBQUFBRUJRMEFBQUFRQUFnRS9RQUFBQUFBRFFYOUh3QUFBQUFUQmYzL0J3QUFBQUVGQVFBQUFCQUFCZ1E5QUFBQUFBQUtCZjBEQUFBQUFCQUYvZjhBQUFBQUhBWDkvLzhQQUFBYkJmMy8vd2NBQUJvRi9mLy9Bd0FBR1FYOS8vOEJBQUFZQmYzLy93QkJrQmtMaGdRQkFBRUJCZ0FBQUFBQUFBWURBQUFBQUFBQUJBUUFBQUFnQUFBRkJRQUFBQUFBQUFVR0FBQUFBQUFBQlFnQUFBQUFBQUFGQ1FBQUFBQUFBQVVMQUFBQUFBQUFCZzBBQUFBQUFBQUdFQUFBQUFBQUFBWVRBQUFBQUFBQUJoWUFBQUFBQUFBR0dRQUFBQUFBQUFZY0FBQUFBQUFBQmg4QUFBQUFBQUFHSWdBQUFBQUFBUVlsQUFBQUFBQUJCaWtBQUFBQUFBSUdMd0FBQUFBQUF3WTdBQUFBQUFBRUJsTUFBQUFBQUFjR2d3QUFBQUFBQ1FZREFnQUFFQUFBQkFRQUFBQUFBQUFFQlFBQUFDQUFBQVVHQUFBQUFBQUFCUWNBQUFBZ0FBQUZDUUFBQUFBQUFBVUtBQUFBQUFBQUJnd0FBQUFBQUFBR0R3QUFBQUFBQUFZU0FBQUFBQUFBQmhVQUFBQUFBQUFHR0FBQUFBQUFBQVliQUFBQUFBQUFCaDRBQUFBQUFBQUdJUUFBQUFBQUFRWWpBQUFBQUFBQkJpY0FBQUFBQUFJR0t3QUFBQUFBQXdZekFBQUFBQUFFQmtNQUFBQUFBQVVHWXdBQUFBQUFDQVlEQVFBQUlBQUFCQVFBQUFBd0FBQUVCQUFBQUJBQUFBUUZBQUFBSUFBQUJRY0FBQUFnQUFBRkNBQUFBQ0FBQUFVS0FBQUFJQUFBQlFzQUFBQUFBQUFHRGdBQUFBQUFBQVlSQUFBQUFBQUFCaFFBQUFBQUFBQUdGd0FBQUFBQUFBWWFBQUFBQUFBQUJoMEFBQUFBQUFBR0lBQUFBQUFBRUFZREFBRUFBQUFQQmdPQUFBQUFBQTRHQTBBQUFBQUFEUVlESUFBQUFBQU1CZ01RQUFBQUFBc0dBd2dBQUFBQUNnWURCQUJCcEIwTDJRRUJBQUFBQXdBQUFBY0FBQUFQQUFBQUh3QUFBRDhBQUFCL0FBQUEvd0FBQVA4QkFBRC9Bd0FBL3djQUFQOFBBQUQvSHdBQS96OEFBUDkvQUFELy93QUEvLzhCQVAvL0F3RC8vd2NBLy84UEFQLy9Id0QvL3o4QS8vOS9BUC8vL3dELy8vOEIvLy8vQS8vLy93Zi8vLzhQLy8vL0gvLy8vei8vLy85L0FBQUFBQUVBQUFBQ0FBQUFCQUFBQUFBQUFBQUNBQUFBQkFBQUFBZ0FBQUFBQUFBQUFRQUFBQUlBQUFBQkFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBZ0FBQUFJQUFBQUNBQUFBQWNBQUFBSUFBQUFDUUFBQUFvQUFBQUxBRUdnSUFzRHdCQlFcXFwiLHRlPXszMTU6XFxcIkFydGlzdFxcXCIsMjU4OlxcXCJCaXRzUGVyU2FtcGxlXFxcIiwyNjU6XFxcIkNlbGxMZW5ndGhcXFwiLDI2NDpcXFwiQ2VsbFdpZHRoXFxcIiwzMjA6XFxcIkNvbG9yTWFwXFxcIiwyNTk6XFxcIkNvbXByZXNzaW9uXFxcIiwzMzQzMjpcXFwiQ29weXJpZ2h0XFxcIiwzMDY6XFxcIkRhdGVUaW1lXFxcIiwzMzg6XFxcIkV4dHJhU2FtcGxlc1xcXCIsMjY2OlxcXCJGaWxsT3JkZXJcXFwiLDI4OTpcXFwiRnJlZUJ5dGVDb3VudHNcXFwiLDI4ODpcXFwiRnJlZU9mZnNldHNcXFwiLDI5MTpcXFwiR3JheVJlc3BvbnNlQ3VydmVcXFwiLDI5MDpcXFwiR3JheVJlc3BvbnNlVW5pdFxcXCIsMzE2OlxcXCJIb3N0Q29tcHV0ZXJcXFwiLDI3MDpcXFwiSW1hZ2VEZXNjcmlwdGlvblxcXCIsMjU3OlxcXCJJbWFnZUxlbmd0aFxcXCIsMjU2OlxcXCJJbWFnZVdpZHRoXFxcIiwyNzE6XFxcIk1ha2VcXFwiLDI4MTpcXFwiTWF4U2FtcGxlVmFsdWVcXFwiLDI4MDpcXFwiTWluU2FtcGxlVmFsdWVcXFwiLDI3MjpcXFwiTW9kZWxcXFwiLDI1NDpcXFwiTmV3U3ViZmlsZVR5cGVcXFwiLDI3NDpcXFwiT3JpZW50YXRpb25cXFwiLDI2MjpcXFwiUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvblxcXCIsMjg0OlxcXCJQbGFuYXJDb25maWd1cmF0aW9uXFxcIiwyOTY6XFxcIlJlc29sdXRpb25Vbml0XFxcIiwyNzg6XFxcIlJvd3NQZXJTdHJpcFxcXCIsMjc3OlxcXCJTYW1wbGVzUGVyUGl4ZWxcXFwiLDMwNTpcXFwiU29mdHdhcmVcXFwiLDI3OTpcXFwiU3RyaXBCeXRlQ291bnRzXFxcIiwyNzM6XFxcIlN0cmlwT2Zmc2V0c1xcXCIsMjU1OlxcXCJTdWJmaWxlVHlwZVxcXCIsMjYzOlxcXCJUaHJlc2hob2xkaW5nXFxcIiwyODI6XFxcIlhSZXNvbHV0aW9uXFxcIiwyODM6XFxcIllSZXNvbHV0aW9uXFxcIiwzMjY6XFxcIkJhZEZheExpbmVzXFxcIiwzMjc6XFxcIkNsZWFuRmF4RGF0YVxcXCIsMzQzOlxcXCJDbGlwUGF0aFxcXCIsMzI4OlxcXCJDb25zZWN1dGl2ZUJhZEZheExpbmVzXFxcIiw0MzM6XFxcIkRlY29kZVxcXCIsNDM0OlxcXCJEZWZhdWx0SW1hZ2VDb2xvclxcXCIsMjY5OlxcXCJEb2N1bWVudE5hbWVcXFwiLDMzNjpcXFwiRG90UmFuZ2VcXFwiLDMyMTpcXFwiSGFsZnRvbmVIaW50c1xcXCIsMzQ2OlxcXCJJbmRleGVkXFxcIiwzNDc6XFxcIkpQRUdUYWJsZXNcXFwiLDI4NTpcXFwiUGFnZU5hbWVcXFwiLDI5NzpcXFwiUGFnZU51bWJlclxcXCIsMzE3OlxcXCJQcmVkaWN0b3JcXFwiLDMxOTpcXFwiUHJpbWFyeUNocm9tYXRpY2l0aWVzXFxcIiw1MzI6XFxcIlJlZmVyZW5jZUJsYWNrV2hpdGVcXFwiLDMzOTpcXFwiU2FtcGxlRm9ybWF0XFxcIiwzNDA6XFxcIlNNaW5TYW1wbGVWYWx1ZVxcXCIsMzQxOlxcXCJTTWF4U2FtcGxlVmFsdWVcXFwiLDU1OTpcXFwiU3RyaXBSb3dDb3VudHNcXFwiLDMzMDpcXFwiU3ViSUZEc1xcXCIsMjkyOlxcXCJUNE9wdGlvbnNcXFwiLDI5MzpcXFwiVDZPcHRpb25zXFxcIiwzMjU6XFxcIlRpbGVCeXRlQ291bnRzXFxcIiwzMjM6XFxcIlRpbGVMZW5ndGhcXFwiLDMyNDpcXFwiVGlsZU9mZnNldHNcXFwiLDMyMjpcXFwiVGlsZVdpZHRoXFxcIiwzMDE6XFxcIlRyYW5zZmVyRnVuY3Rpb25cXFwiLDMxODpcXFwiV2hpdGVQb2ludFxcXCIsMzQ0OlxcXCJYQ2xpcFBhdGhVbml0c1xcXCIsMjg2OlxcXCJYUG9zaXRpb25cXFwiLDUyOTpcXFwiWUNiQ3JDb2VmZmljaWVudHNcXFwiLDUzMTpcXFwiWUNiQ3JQb3NpdGlvbmluZ1xcXCIsNTMwOlxcXCJZQ2JDclN1YlNhbXBsaW5nXFxcIiwzNDU6XFxcIllDbGlwUGF0aFVuaXRzXFxcIiwyODc6XFxcIllQb3NpdGlvblxcXCIsMzczNzg6XFxcIkFwZXJ0dXJlVmFsdWVcXFwiLDQwOTYxOlxcXCJDb2xvclNwYWNlXFxcIiwzNjg2ODpcXFwiRGF0ZVRpbWVEaWdpdGl6ZWRcXFwiLDM2ODY3OlxcXCJEYXRlVGltZU9yaWdpbmFsXFxcIiwzNDY2NTpcXFwiRXhpZiBJRkRcXFwiLDM2ODY0OlxcXCJFeGlmVmVyc2lvblxcXCIsMzM0MzQ6XFxcIkV4cG9zdXJlVGltZVxcXCIsNDE3Mjg6XFxcIkZpbGVTb3VyY2VcXFwiLDM3Mzg1OlxcXCJGbGFzaFxcXCIsNDA5NjA6XFxcIkZsYXNocGl4VmVyc2lvblxcXCIsMzM0Mzc6XFxcIkZOdW1iZXJcXFwiLDQyMDE2OlxcXCJJbWFnZVVuaXF1ZUlEXFxcIiwzNzM4NDpcXFwiTGlnaHRTb3VyY2VcXFwiLDM3NTAwOlxcXCJNYWtlck5vdGVcXFwiLDM3Mzc3OlxcXCJTaHV0dGVyU3BlZWRWYWx1ZVxcXCIsMzc1MTA6XFxcIlVzZXJDb21tZW50XFxcIiwzMzcyMzpcXFwiSVBUQ1xcXCIsMzQ2NzU6XFxcIklDQyBQcm9maWxlXFxcIiw3MDA6XFxcIlhNUFxcXCIsNDIxMTI6XFxcIkdEQUxfTUVUQURBVEFcXFwiLDQyMTEzOlxcXCJHREFMX05PREFUQVxcXCIsMzQzNzc6XFxcIlBob3Rvc2hvcFxcXCIsMzM1NTA6XFxcIk1vZGVsUGl4ZWxTY2FsZVxcXCIsMzM5MjI6XFxcIk1vZGVsVGllcG9pbnRcXFwiLDM0MjY0OlxcXCJNb2RlbFRyYW5zZm9ybWF0aW9uXFxcIiwzNDczNTpcXFwiR2VvS2V5RGlyZWN0b3J5XFxcIiwzNDczNjpcXFwiR2VvRG91YmxlUGFyYW1zXFxcIiwzNDczNzpcXFwiR2VvQXNjaWlQYXJhbXNcXFwiLDUwNjc0OlxcXCJMZXJjUGFyYW1ldGVyc1xcXCJ9LGllPXt9O2Zvcih2YXIgcmUgaW4gdGUpdGUuaGFzT3duUHJvcGVydHkocmUpJiYoaWVbdGVbcmVdXT1wYXJzZUludChyZSwxMCkpO2llLkJpdHNQZXJTYW1wbGUsaWUuRXh0cmFTYW1wbGVzLGllLlNhbXBsZUZvcm1hdCxpZS5TdHJpcEJ5dGVDb3VudHMsaWUuU3RyaXBPZmZzZXRzLGllLlN0cmlwUm93Q291bnRzLGllLlRpbGVCeXRlQ291bnRzLGllLlRpbGVPZmZzZXRzLGllLlN1YklGRHM7dmFyIEllPXsxOlxcXCJCWVRFXFxcIiwyOlxcXCJBU0NJSVxcXCIsMzpcXFwiU0hPUlRcXFwiLDQ6XFxcIkxPTkdcXFwiLDU6XFxcIlJBVElPTkFMXFxcIiw2OlxcXCJTQllURVxcXCIsNzpcXFwiVU5ERUZJTkVEXFxcIiw4OlxcXCJTU0hPUlRcXFwiLDk6XFxcIlNMT05HXFxcIiwxMDpcXFwiU1JBVElPTkFMXFxcIiwxMTpcXFwiRkxPQVRcXFwiLDEyOlxcXCJET1VCTEVcXFwiLDEzOlxcXCJJRkRcXFwiLDE2OlxcXCJMT05HOFxcXCIsMTc6XFxcIlNMT05HOFxcXCIsMTg6XFxcIklGRDhcXFwifSxnZT17fTtmb3IodmFyIG5lIGluIEllKUllLmhhc093blByb3BlcnR5KG5lKSYmKGdlW0llW25lXV09cGFyc2VJbnQobmUsMTApKTt2YXIgYWU9MSxvZT0wLEJlPTEsQ2U9MixRZT17MTAyNDpcXFwiR1RNb2RlbFR5cGVHZW9LZXlcXFwiLDEwMjU6XFxcIkdUUmFzdGVyVHlwZUdlb0tleVxcXCIsMTAyNjpcXFwiR1RDaXRhdGlvbkdlb0tleVxcXCIsMjA0ODpcXFwiR2VvZ3JhcGhpY1R5cGVHZW9LZXlcXFwiLDIwNDk6XFxcIkdlb2dDaXRhdGlvbkdlb0tleVxcXCIsMjA1MDpcXFwiR2VvZ0dlb2RldGljRGF0dW1HZW9LZXlcXFwiLDIwNTE6XFxcIkdlb2dQcmltZU1lcmlkaWFuR2VvS2V5XFxcIiwyMDUyOlxcXCJHZW9nTGluZWFyVW5pdHNHZW9LZXlcXFwiLDIwNTM6XFxcIkdlb2dMaW5lYXJVbml0U2l6ZUdlb0tleVxcXCIsMjA1NDpcXFwiR2VvZ0FuZ3VsYXJVbml0c0dlb0tleVxcXCIsMjA1NTpcXFwiR2VvZ0FuZ3VsYXJVbml0U2l6ZUdlb0tleVxcXCIsMjA1NjpcXFwiR2VvZ0VsbGlwc29pZEdlb0tleVxcXCIsMjA1NzpcXFwiR2VvZ1NlbWlNYWpvckF4aXNHZW9LZXlcXFwiLDIwNTg6XFxcIkdlb2dTZW1pTWlub3JBeGlzR2VvS2V5XFxcIiwyMDU5OlxcXCJHZW9nSW52RmxhdHRlbmluZ0dlb0tleVxcXCIsMjA2MDpcXFwiR2VvZ0F6aW11dGhVbml0c0dlb0tleVxcXCIsMjA2MTpcXFwiR2VvZ1ByaW1lTWVyaWRpYW5Mb25nR2VvS2V5XFxcIiwyMDYyOlxcXCJHZW9nVE9XR1M4NEdlb0tleVxcXCIsMzA3MjpcXFwiUHJvamVjdGVkQ1NUeXBlR2VvS2V5XFxcIiwzMDczOlxcXCJQQ1NDaXRhdGlvbkdlb0tleVxcXCIsMzA3NDpcXFwiUHJvamVjdGlvbkdlb0tleVxcXCIsMzA3NTpcXFwiUHJvakNvb3JkVHJhbnNHZW9LZXlcXFwiLDMwNzY6XFxcIlByb2pMaW5lYXJVbml0c0dlb0tleVxcXCIsMzA3NzpcXFwiUHJvakxpbmVhclVuaXRTaXplR2VvS2V5XFxcIiwzMDc4OlxcXCJQcm9qU3RkUGFyYWxsZWwxR2VvS2V5XFxcIiwzMDc5OlxcXCJQcm9qU3RkUGFyYWxsZWwyR2VvS2V5XFxcIiwzMDgwOlxcXCJQcm9qTmF0T3JpZ2luTG9uZ0dlb0tleVxcXCIsMzA4MTpcXFwiUHJvak5hdE9yaWdpbkxhdEdlb0tleVxcXCIsMzA4MjpcXFwiUHJvakZhbHNlRWFzdGluZ0dlb0tleVxcXCIsMzA4MzpcXFwiUHJvakZhbHNlTm9ydGhpbmdHZW9LZXlcXFwiLDMwODQ6XFxcIlByb2pGYWxzZU9yaWdpbkxvbmdHZW9LZXlcXFwiLDMwODU6XFxcIlByb2pGYWxzZU9yaWdpbkxhdEdlb0tleVxcXCIsMzA4NjpcXFwiUHJvakZhbHNlT3JpZ2luRWFzdGluZ0dlb0tleVxcXCIsMzA4NzpcXFwiUHJvakZhbHNlT3JpZ2luTm9ydGhpbmdHZW9LZXlcXFwiLDMwODg6XFxcIlByb2pDZW50ZXJMb25nR2VvS2V5XFxcIiwzMDg5OlxcXCJQcm9qQ2VudGVyTGF0R2VvS2V5XFxcIiwzMDkwOlxcXCJQcm9qQ2VudGVyRWFzdGluZ0dlb0tleVxcXCIsMzA5MTpcXFwiUHJvakNlbnRlck5vcnRoaW5nR2VvS2V5XFxcIiwzMDkyOlxcXCJQcm9qU2NhbGVBdE5hdE9yaWdpbkdlb0tleVxcXCIsMzA5MzpcXFwiUHJvalNjYWxlQXRDZW50ZXJHZW9LZXlcXFwiLDMwOTQ6XFxcIlByb2pBemltdXRoQW5nbGVHZW9LZXlcXFwiLDMwOTU6XFxcIlByb2pTdHJhaWdodFZlcnRQb2xlTG9uZ0dlb0tleVxcXCIsMzA5NjpcXFwiUHJvalJlY3RpZmllZEdyaWRBbmdsZUdlb0tleVxcXCIsNDA5NjpcXFwiVmVydGljYWxDU1R5cGVHZW9LZXlcXFwiLDQwOTc6XFxcIlZlcnRpY2FsQ2l0YXRpb25HZW9LZXlcXFwiLDQwOTg6XFxcIlZlcnRpY2FsRGF0dW1HZW9LZXlcXFwiLDQwOTk6XFxcIlZlcnRpY2FsVW5pdHNHZW9LZXlcXFwifSxFZT17fTtmb3IodmFyIHNlIGluIFFlKVFlLmhhc093blByb3BlcnR5KHNlKSYmKEVlW1FlW3NlXV09cGFyc2VJbnQoc2UsMTApKTtmdW5jdGlvbiBmZShBKXt2YXIgZT1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChBKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsaT1jKEEpO2lmKGUpe3ZhciByPWModGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChpLGFyZ3VtZW50cyxyKX1lbHNlIHQ9aS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGYodGhpcyx0KX19dmFyIGNlPW5ldyBBZSxoZT1mdW5jdGlvbihBKXtzKHQsdyk7dmFyIGU9ZmUodCk7ZnVuY3Rpb24gdChBKXt2YXIgaTtyZXR1cm4gQih0aGlzLHQpLChpPWUuY2FsbCh0aGlzKSkucGxhbmFyQ29uZmlndXJhdGlvbj12b2lkIDAhPT1BLlBsYW5hckNvbmZpZ3VyYXRpb24/QS5QbGFuYXJDb25maWd1cmF0aW9uOjEsaS5zYW1wbGVzUGVyUGl4ZWw9dm9pZCAwIT09QS5TYW1wbGVzUGVyUGl4ZWw/QS5TYW1wbGVzUGVyUGl4ZWw6MSxpLmFkZENvbXByZXNzaW9uPUEuTGVyY1BhcmFtZXRlcnNbYWVdLGl9cmV0dXJuIFEodCxbe2tleTpcXFwiZGVjb2RlQmxvY2tcXFwiLHZhbHVlOmZ1bmN0aW9uKEEpe3N3aXRjaCh0aGlzLmFkZENvbXByZXNzaW9uKXtjYXNlIG9lOmJyZWFrO2Nhc2UgQmU6QT1ZQShuZXcgVWludDhBcnJheShBKSkuYnVmZmVyO2JyZWFrO2Nhc2UgQ2U6QT1jZS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoQSkpLmJ1ZmZlcjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcXFwiVW5zdXBwb3J0ZWQgTEVSQyBhZGRpdGlvbmFsIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiBcXFwiLmNvbmNhdCh0aGlzLmFkZENvbXByZXNzaW9uKSl9cmV0dXJuIHpBLmRlY29kZShBLHtyZXR1cm5QaXhlbEludGVybGVhdmVkRGltczoxPT09dGhpcy5wbGFuYXJDb25maWd1cmF0aW9ufSkucGl4ZWxzWzBdLmJ1ZmZlcn19XSksdH0oKSxsZT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCx6c3RkOmNlLGRlZmF1bHQ6aGV9KTtmdW5jdGlvbiB1ZShBKXt2YXIgZT1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaChBKXtyZXR1cm4hMX19KCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQsaT1jKEEpO2lmKGUpe3ZhciByPWModGhpcykuY29uc3RydWN0b3I7dD1SZWZsZWN0LmNvbnN0cnVjdChpLGFyZ3VtZW50cyxyKX1lbHNlIHQ9aS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIGYodGhpcyx0KX19dmFyIHdlPWZ1bmN0aW9uKEEpe3MoSSx3KTt2YXIgdCxpPXVlKEkpO2Z1bmN0aW9uIEkoKXt2YXIgQTtpZihCKHRoaXMsSSksQT1pLmNhbGwodGhpcyksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCl0aHJvdyBuZXcgRXJyb3IoXFxcIkNhbm5vdCBkZWNvZGUgV2ViSW1hZ2UgYXMgYGNyZWF0ZUltYWdlQml0bWFwYCBpcyBub3QgYXZhaWxhYmxlXFxcIik7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkb2N1bWVudCYmXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IEVycm9yKFxcXCJDYW5ub3QgZGVjb2RlIFdlYkltYWdlIGFzIG5laXRoZXIgYGRvY3VtZW50YCBub3IgYE9mZnNjcmVlbkNhbnZhc2AgaXMgbm90IGF2YWlsYWJsZVxcXCIpO3JldHVybiBBfXJldHVybiBRKEksW3trZXk6XFxcImRlY29kZVxcXCIsdmFsdWU6KHQ9ZShyLm1hcmsoKGZ1bmN0aW9uIEEoZSx0KXt2YXIgaSxJLGcsbjtyZXR1cm4gci53cmFwKChmdW5jdGlvbihBKXtmb3IoOzspc3dpdGNoKEEucHJldj1BLm5leHQpe2Nhc2UgMDpyZXR1cm4gaT1uZXcgQmxvYihbdF0pLEEubmV4dD0zLGNyZWF0ZUltYWdlQml0bWFwKGkpO2Nhc2UgMzpyZXR1cm4gST1BLnNlbnQsXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBkb2N1bWVudD8oKGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIikpLndpZHRoPUkud2lkdGgsZy5oZWlnaHQ9SS5oZWlnaHQpOmc9bmV3IE9mZnNjcmVlbkNhbnZhcyhJLndpZHRoLEkuaGVpZ2h0KSwobj1nLmdldENvbnRleHQoXFxcIjJkXFxcIikpLmRyYXdJbWFnZShJLDAsMCksQS5hYnJ1cHQoXFxcInJldHVyblxcXCIsbi5nZXRJbWFnZURhdGEoMCwwLEkud2lkdGgsSS5oZWlnaHQpLmRhdGEuYnVmZmVyKTtjYXNlIDg6Y2FzZVxcXCJlbmRcXFwiOnJldHVybiBBLnN0b3AoKX19KSxBKX0pKSksZnVuY3Rpb24oQSxlKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX1dKSxJfSgpLGRlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6d2V9KTtcIjtcbiAgICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyBcbiAgICAgICAgICAgID8gJ2RhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdDtiYXNlNjQsJyArIEJ1ZmZlci5mcm9tKHNvdXJjZSwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgOiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtzb3VyY2VdLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpKTtcbiAgICAgICAgfVxuICAgICAgXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geotiff/dist-module/worker/decoder.js\n");

/***/ })

};
;